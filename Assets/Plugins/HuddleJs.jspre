"use strict";
var HuddleWebCore = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/debug/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/debug/node_modules/ms/index.js"(exports, module) {
      "use strict";
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js
  var require_ua_parser = __commonJS({
    "../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
      "use strict";
      (function(window2, undefined2) {
        "use strict";
        var LIBVERSION = "1.0.37", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
        var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
        var extend = function(regexes2, extensions) {
          var mergedRegexes = {};
          for (var i in regexes2) {
            if (extensions[i] && extensions[i].length % 2 === 0) {
              mergedRegexes[i] = extensions[i].concat(regexes2[i]);
            } else {
              mergedRegexes[i] = regexes2[i];
            }
          }
          return mergedRegexes;
        }, enumerize = function(arr) {
          var enums = {};
          for (var i = 0; i < arr.length; i++) {
            enums[arr[i].toUpperCase()] = arr[i];
          }
          return enums;
        }, has = function(str1, str2) {
          return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        }, lowerize = function(str) {
          return str.toLowerCase();
        }, majorize = function(version) {
          return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
        }, trim = function(str, len) {
          if (typeof str === STR_TYPE) {
            str = str.replace(/^\s\s*/, EMPTY);
            return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
          }
        };
        var rgxMapper = function(ua, arrays) {
          var i = 0, j, k, p, q, matches, match;
          while (i < arrays.length && !matches) {
            var regex = arrays[i], props = arrays[i + 1];
            j = k = 0;
            while (j < regex.length && !matches) {
              if (!regex[j]) {
                break;
              }
              matches = regex[j++].exec(ua);
              if (!!matches) {
                for (p = 0; p < props.length; p++) {
                  match = matches[++k];
                  q = props[p];
                  if (typeof q === OBJ_TYPE && q.length > 0) {
                    if (q.length === 2) {
                      if (typeof q[1] == FUNC_TYPE) {
                        this[q[0]] = q[1].call(this, match);
                      } else {
                        this[q[0]] = q[1];
                      }
                    } else if (q.length === 3) {
                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                      } else {
                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                      }
                    } else if (q.length === 4) {
                      this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                    }
                  } else {
                    this[q] = match ? match : undefined2;
                  }
                }
              }
            }
            i += 2;
          }
        }, strMapper = function(str, map) {
          for (var i in map) {
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
              for (var j = 0; j < map[i].length; j++) {
                if (has(map[i][j], str)) {
                  return i === UNKNOWN ? undefined2 : i;
                }
              }
            } else if (has(map[i], str)) {
              return i === UNKNOWN ? undefined2 : i;
            }
          }
          return str;
        };
        var oldSafariMap = {
          "1.0": "/8",
          "1.2": "/1",
          "1.3": "/3",
          "2.0": "/412",
          "2.0.2": "/416",
          "2.0.3": "/417",
          "2.0.4": "/419",
          "?": "/"
        }, windowsVersionMap = {
          "ME": "4.90",
          "NT 3.11": "NT3.51",
          "NT 4.0": "NT4.0",
          "2000": "NT 5.0",
          "XP": ["NT 5.1", "NT 5.2"],
          "Vista": "NT 6.0",
          "7": "NT 6.1",
          "8": "NT 6.2",
          "8.1": "NT 6.3",
          "10": ["NT 6.4", "NT 10.0"],
          "RT": "ARM"
        };
        var regexes = {
          browser: [
            [
              /\b(?:crmo|crios)\/([\w\.]+)/i
              // Chrome for Android/iOS
            ],
            [VERSION, [NAME, "Chrome"]],
            [
              /edg(?:e|ios|a)?\/([\w\.]+)/i
              // Microsoft Edge
            ],
            [VERSION, [NAME, "Edge"]],
            [
              // Presto based
              /(opera mini)\/([-\w\.]+)/i,
              // Opera Mini
              /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
              // Opera Mobi/Tablet
              /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
              // Opera
            ],
            [NAME, VERSION],
            [
              /opios[\/ ]+([\w\.]+)/i
              // Opera mini on iphone >= 8.0
            ],
            [VERSION, [NAME, OPERA + " Mini"]],
            [
              /\bopr\/([\w\.]+)/i
              // Opera Webkit
            ],
            [VERSION, [NAME, OPERA]],
            [
              // Mixed
              /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
              // Baidu
            ],
            [VERSION, [NAME, "Baidu"]],
            [
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
              // Lunascape/Maxthon/Netfront/Jasmine/Blazer
              // Trident based
              /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
              // Avant/IEMobile/SlimBrowser
              /(?:ms|\()(ie) ([\w\.]+)/i,
              // Internet Explorer
              // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
              /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
              // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
              /(heytap|ovi)browser\/([\d\.]+)/i,
              // Heytap/Ovi
              /(weibo)__([\d\.]+)/i
              // Weibo
            ],
            [NAME, VERSION],
            [
              /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
              // UCBrowser
            ],
            [VERSION, [NAME, "UC" + BROWSER]],
            [
              /microm.+\bqbcore\/([\w\.]+)/i,
              // WeChat Desktop for Windows Built-in Browser
              /\bqbcore\/([\w\.]+).+microm/i,
              /micromessenger\/([\w\.]+)/i
              // WeChat
            ],
            [VERSION, [NAME, "WeChat"]],
            [
              /konqueror\/([\w\.]+)/i
              // Konqueror
            ],
            [VERSION, [NAME, "Konqueror"]],
            [
              /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
              // IE11
            ],
            [VERSION, [NAME, "IE"]],
            [
              /ya(?:search)?browser\/([\w\.]+)/i
              // Yandex
            ],
            [VERSION, [NAME, "Yandex"]],
            [
              /slbrowser\/([\w\.]+)/i
              // Smart Lenovo Browser
            ],
            [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
            [
              /(avast|avg)\/([\w\.]+)/i
              // Avast/AVG Secure Browser
            ],
            [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
            [
              /\bfocus\/([\w\.]+)/i
              // Firefox Focus
            ],
            [VERSION, [NAME, FIREFOX + " Focus"]],
            [
              /\bopt\/([\w\.]+)/i
              // Opera Touch
            ],
            [VERSION, [NAME, OPERA + " Touch"]],
            [
              /coc_coc\w+\/([\w\.]+)/i
              // Coc Coc Browser
            ],
            [VERSION, [NAME, "Coc Coc"]],
            [
              /dolfin\/([\w\.]+)/i
              // Dolphin
            ],
            [VERSION, [NAME, "Dolphin"]],
            [
              /coast\/([\w\.]+)/i
              // Opera Coast
            ],
            [VERSION, [NAME, OPERA + " Coast"]],
            [
              /miuibrowser\/([\w\.]+)/i
              // MIUI Browser
            ],
            [VERSION, [NAME, "MIUI " + BROWSER]],
            [
              /fxios\/([-\w\.]+)/i
              // Firefox for iOS
            ],
            [VERSION, [NAME, FIREFOX]],
            [
              /\bqihu|(qi?ho?o?|360)browser/i
              // 360
            ],
            [[NAME, "360 " + BROWSER]],
            [
              /(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i
            ],
            [[NAME, /(.+)/, "$1 " + BROWSER], VERSION],
            [
              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
              /samsungbrowser\/([\w\.]+)/i
              // Samsung Internet
            ],
            [VERSION, [NAME, SAMSUNG + " Internet"]],
            [
              /(comodo_dragon)\/([\w\.]+)/i
              // Comodo Dragon
            ],
            [[NAME, /_/g, " "], VERSION],
            [
              /metasr[\/ ]?([\d\.]+)/i
              // Sogou Explorer
            ],
            [VERSION, [NAME, "Sogou Explorer"]],
            [
              /(sogou)mo\w+\/([\d\.]+)/i
              // Sogou Mobile
            ],
            [[NAME, "Sogou Mobile"], VERSION],
            [
              /(electron)\/([\w\.]+) safari/i,
              // Electron-based App
              /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
              // Tesla
              /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
              // QQBrowser/2345 Browser
            ],
            [NAME, VERSION],
            [
              /(lbbrowser)/i,
              // LieBao Browser
              /\[(linkedin)app\]/i
              // LinkedIn App for iOS & Android
            ],
            [NAME],
            [
              // WebView
              /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
              // Facebook App for iOS & Android
            ],
            [[NAME, FACEBOOK], VERSION],
            [
              /(Klarna)\/([\w\.]+)/i,
              // Klarna Shopping Browser for iOS & Android
              /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
              // Kakao App
              /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
              // Naver InApp
              /safari (line)\/([\w\.]+)/i,
              // Line App for iOS
              /\b(line)\/([\w\.]+)\/iab/i,
              // Line App for Android
              /(alipay)client\/([\w\.]+)/i,
              // Alipay
              /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
              // Chromium/Instagram/Snapchat
            ],
            [NAME, VERSION],
            [
              /\bgsa\/([\w\.]+) .*safari\//i
              // Google Search Appliance on iOS
            ],
            [VERSION, [NAME, "GSA"]],
            [
              /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
              // TikTok
            ],
            [VERSION, [NAME, "TikTok"]],
            [
              /headlesschrome(?:\/([\w\.]+)| )/i
              // Chrome Headless
            ],
            [VERSION, [NAME, CHROME + " Headless"]],
            [
              / wv\).+(chrome)\/([\w\.]+)/i
              // Chrome WebView
            ],
            [[NAME, CHROME + " WebView"], VERSION],
            [
              /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
              // Android Browser
            ],
            [VERSION, [NAME, "Android " + BROWSER]],
            [
              /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
              // Chrome/OmniWeb/Arora/Tizen/Nokia
            ],
            [NAME, VERSION],
            [
              /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
              // Mobile Safari
            ],
            [VERSION, [NAME, "Mobile Safari"]],
            [
              /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
              // Safari & Safari Mobile
            ],
            [VERSION, NAME],
            [
              /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
              // Safari < 3.0
            ],
            [NAME, [VERSION, strMapper, oldSafariMap]],
            [
              /(webkit|khtml)\/([\w\.]+)/i
            ],
            [NAME, VERSION],
            [
              // Gecko based
              /(navigator|netscape\d?)\/([-\w\.]+)/i
              // Netscape
            ],
            [[NAME, "Netscape"], VERSION],
            [
              /mobile vr; rv:([\w\.]+)\).+firefox/i
              // Firefox Reality
            ],
            [VERSION, [NAME, FIREFOX + " Reality"]],
            [
              /ekiohf.+(flow)\/([\w\.]+)/i,
              // Flow
              /(swiftfox)/i,
              // Swiftfox
              /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
              // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
              /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
              // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
              /(firefox)\/([\w\.]+)/i,
              // Other Firefox-based
              /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
              // Mozilla
              // Other
              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
              // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
              /(links) \(([\w\.]+)/i,
              // Links
              /panasonic;(viera)/i
              // Panasonic Viera
            ],
            [NAME, VERSION],
            [
              /(cobalt)\/([\w\.]+)/i
              // Cobalt
            ],
            [NAME, [VERSION, /master.|lts./, ""]]
          ],
          cpu: [
            [
              /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
              // AMD64 (x64)
            ],
            [[ARCHITECTURE, "amd64"]],
            [
              /(ia32(?=;))/i
              // IA32 (quicktime)
            ],
            [[ARCHITECTURE, lowerize]],
            [
              /((?:i[346]|x)86)[;\)]/i
              // IA32 (x86)
            ],
            [[ARCHITECTURE, "ia32"]],
            [
              /\b(aarch64|arm(v?8e?l?|_?64))\b/i
              // ARM64
            ],
            [[ARCHITECTURE, "arm64"]],
            [
              /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
              // ARMHF
            ],
            [[ARCHITECTURE, "armhf"]],
            [
              // PocketPC mistakenly identified as PowerPC
              /windows (ce|mobile); ppc;/i
            ],
            [[ARCHITECTURE, "arm"]],
            [
              /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
              // PowerPC
            ],
            [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
            [
              /(sun4\w)[;\)]/i
              // SPARC
            ],
            [[ARCHITECTURE, "sparc"]],
            [
              /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
              // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ],
            [[ARCHITECTURE, lowerize]]
          ],
          device: [
            [
              //////////////////////////
              // MOBILES & TABLETS
              /////////////////////////
              // Samsung
              /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
            [
              /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
              /samsung[- ]([-\w]+)/i,
              /sec-(sgh\w+)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
            [
              // Apple
              /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
              // iPod/iPhone
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
            [
              /\((ipad);[-\w\),; ]+apple/i,
              // iPad
              /applecoremedia\/[\w\.]+ \((ipad)/i,
              /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
            [
              /(macintosh);/i
            ],
            [MODEL, [VENDOR, APPLE]],
            [
              // Sharp
              /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
            [
              // Huawei
              /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
            [
              /(?:huawei|honor)([-\w ]+)[;\)]/i,
              /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
            [
              // Xiaomi
              /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
              // Xiaomi POCO
              /\b; (\w+) build\/hm\1/i,
              // Xiaomi Hongmi 'numeric' models
              /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
              // Xiaomi Hongmi
              /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
              // Xiaomi Redmi
              /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
              // Xiaomi Redmi 'numeric' models
              /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
              // Xiaomi Mi
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
            [
              /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
              // Redmi Pad
              /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
              // Mi Pad tablets
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
            [
              // OPPO
              /; (\w+) bui.+ oppo/i,
              /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
            [
              // Vivo
              /vivo (\w+)(?: bui|\))/i,
              /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ],
            [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
            [
              // Realme
              /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
            ],
            [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
            [
              // Motorola
              /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
              /\bmot(?:orola)?[- ](\w*)/i,
              /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
            [
              /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
            [
              // LG
              /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, TABLET]],
            [
              /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
              /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
              /\blg-?([\d\w]+) bui/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
            [
              // Lenovo
              /(ideatab[-\w ]+)/i,
              /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
            [
              // Nokia
              /(?:maemo|nokia).*(n900|lumia \d+)/i,
              /nokia[-_ ]?([-\w\.]*)/i
            ],
            [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
            [
              // Google
              /(pixel c)\b/i
              // Google Pixel C
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
            [
              /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
              // Google Pixel
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
            [
              // Sony
              /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
            [
              /sony tablet [ps]/i,
              /\b(?:sony)?sgp\w+(?: bui|\))/i
            ],
            [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
            [
              // OnePlus
              / (kb2005|in20[12]5|be20[12][59])\b/i,
              /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
            [
              // Amazon
              /(alexa)webm/i,
              /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
              // Kindle Fire without Silk / Echo Show
              /(kf[a-z]+)( bui|\)).+silk\//i
              // Kindle Fire HD
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
            [
              /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
              // Fire Phone
            ],
            [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
            [
              // BlackBerry
              /(playbook);[-\w\),; ]+(rim)/i
              // BlackBerry PlayBook
            ],
            [MODEL, VENDOR, [TYPE, TABLET]],
            [
              /\b((?:bb[a-f]|st[hv])100-\d)/i,
              /\(bb10; (\w+)/i
              // BlackBerry 10
            ],
            [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
            [
              // Asus
              /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
            [
              / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
            [
              // HTC
              /(nexus 9)/i
              // HTC Nexus 9
            ],
            [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
            [
              /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
              // HTC
              // ZTE
              /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
              /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
              // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ],
            [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
            [
              // Acer
              /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ],
            [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
            [
              // Meizu
              /droid.+; (m[1-5] note) bui/i,
              /\bmz-([-\w]{2,})/i
            ],
            [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
            [
              // Ulefone
              /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
            ],
            [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
            [
              // MIXED
              /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
              // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
              /(hp) ([\w ]+\w)/i,
              // HP iPAQ
              /(asus)-?(\w+)/i,
              // Asus
              /(microsoft); (lumia[\w ]+)/i,
              // Microsoft Lumia
              /(lenovo)[-_ ]?([-\w]+)/i,
              // Lenovo
              /(jolla)/i,
              // Jolla
              /(oppo) ?([\w ]+) bui/i
              // OPPO
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kobo)\s(ereader|touch)/i,
              // Kobo
              /(archos) (gamepad2?)/i,
              // Archos
              /(hp).+(touchpad(?!.+tablet)|tablet)/i,
              // HP TouchPad
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(nook)[\w ]+build\/(\w+)/i,
              // Nook
              /(dell) (strea[kpr\d ]*[\dko])/i,
              // Dell Streak
              /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
              // Le Pan Tablets
              /(trinity)[- ]*(t\d{3}) bui/i,
              // Trinity Tablets
              /(gigaset)[- ]+(q\w{1,9}) bui/i,
              // Gigaset Tablets
              /(vodafone) ([\w ]+)(?:\)| bui)/i
              // Vodafone
            ],
            [VENDOR, MODEL, [TYPE, TABLET]],
            [
              /(surface duo)/i
              // Surface Duo
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
            [
              /droid [\d\.]+; (fp\du?)(?: b|\))/i
              // Fairphone
            ],
            [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
            [
              /(u304aa)/i
              // AT&T
            ],
            [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
            [
              /\bsie-(\w*)/i
              // Siemens
            ],
            [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
            [
              /\b(rct\w+) b/i
              // RCA Tablets
            ],
            [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
            [
              /\b(venue[\d ]{2,7}) b/i
              // Dell Venue Tablets
            ],
            [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
            [
              /\b(q(?:mv|ta)\w+) b/i
              // Verizon Tablet
            ],
            [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
            [
              /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
              // Barnes & Noble Tablet
            ],
            [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
            [
              /\b(tm\d{3}\w+) b/i
            ],
            [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
            [
              /\b(k88) b/i
              // ZTE K Series Tablet
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
            [
              /\b(nx\d{3}j) b/i
              // ZTE Nubia
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
            [
              /\b(gen\d{3}) b.+49h/i
              // Swiss GEN Mobile
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
            [
              /\b(zur\d{3}) b/i
              // Swiss ZUR Tablet
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
            [
              /\b((zeki)?tb.*\b) b/i
              // Zeki Tablets
            ],
            [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
            [
              /\b([yr]\d{2}) b/i,
              /\b(dragon[- ]+touch |dt)(\w{5}) b/i
              // Dragon Touch Tablet
            ],
            [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
            [
              /\b(ns-?\w{0,9}) b/i
              // Insignia Tablets
            ],
            [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
            [
              /\b((nxa|next)-?\w{0,9}) b/i
              // NextBook Tablets
            ],
            [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
            [
              /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
              // Voice Xtreme Phones
            ],
            [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
            [
              /\b(lvtel\-)?(v1[12]) b/i
              // LvTel Phones
            ],
            [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
            [
              /\b(ph-1) /i
              // Essential PH-1
            ],
            [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
            [
              /\b(v(100md|700na|7011|917g).*\b) b/i
              // Envizen Tablets
            ],
            [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
            [
              /\b(trio[-\w\. ]+) b/i
              // MachSpeed Tablets
            ],
            [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
            [
              /\btu_(1491) b/i
              // Rotor Tablets
            ],
            [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
            [
              /(shield[\w ]+) b/i
              // Nvidia Shield Tablets
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
            [
              /(sprint) (\w+)/i
              // Sprint Phones
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kin\.[onetw]{3})/i
              // Microsoft Kin
            ],
            [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
            [
              /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
              // Zebra
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
            [
              /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
            [
              ///////////////////
              // SMARTTVS
              ///////////////////
              /smart-tv.+(samsung)/i
              // Samsung
            ],
            [VENDOR, [TYPE, SMARTTV]],
            [
              /hbbtv.+maple;(\d+)/i
            ],
            [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
            [
              /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
              // LG SmartTV
            ],
            [[VENDOR, LG], [TYPE, SMARTTV]],
            [
              /(apple) ?tv/i
              // Apple TV
            ],
            [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
            [
              /crkey/i
              // Google Chromecast
            ],
            [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
            [
              /droid.+aft(\w+)( bui|\))/i
              // Fire TV
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
            [
              /\(dtv[\);].+(aquos)/i,
              /(aquos-tv[\w ]+)\)/i
              // Sharp
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
            [
              /(bravia[\w ]+)( bui|\))/i
              // Sony
            ],
            [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
            [
              /(mitv-\w{5}) bui/i
              // Xiaomi
            ],
            [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
            [
              /Hbbtv.*(technisat) (.*);/i
              // TechniSAT
            ],
            [VENDOR, MODEL, [TYPE, SMARTTV]],
            [
              /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
              // Roku
              /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
              // HbbTV devices
            ],
            [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
            [
              /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
              // SmartTV from Unidentified Vendors
            ],
            [[TYPE, SMARTTV]],
            [
              ///////////////////
              // CONSOLES
              ///////////////////
              /(ouya)/i,
              // Ouya
              /(nintendo) ([wids3utch]+)/i
              // Nintendo
            ],
            [VENDOR, MODEL, [TYPE, CONSOLE]],
            [
              /droid.+; (shield) bui/i
              // Nvidia
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
            [
              /(playstation [345portablevi]+)/i
              // Playstation
            ],
            [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
            [
              /\b(xbox(?: one)?(?!; xbox))[\); ]/i
              // Microsoft Xbox
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
            [
              ///////////////////
              // WEARABLES
              ///////////////////
              /((pebble))app/i
              // Pebble
            ],
            [VENDOR, MODEL, [TYPE, WEARABLE]],
            [
              /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
              // Apple Watch
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
            [
              /droid.+; (glass) \d/i
              // Google Glass
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
            [
              /droid.+; (wt63?0{2,3})\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
            [
              /(quest( 2| pro)?)/i
              // Oculus Quest
            ],
            [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
            [
              ///////////////////
              // EMBEDDED
              ///////////////////
              /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
              // Tesla
            ],
            [VENDOR, [TYPE, EMBEDDED]],
            [
              /(aeobc)\b/i
              // Echo Dot
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
            [
              ////////////////////
              // MIXED (GENERIC)
              ///////////////////
              /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
              // Android Phones from Unidentified Vendors
            ],
            [MODEL, [TYPE, MOBILE]],
            [
              /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
              // Android Tablets from Unidentified Vendors
            ],
            [MODEL, [TYPE, TABLET]],
            [
              /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
              // Unidentifiable Tablet
            ],
            [[TYPE, TABLET]],
            [
              /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
              // Unidentifiable Mobile
            ],
            [[TYPE, MOBILE]],
            [
              /(android[-\w\. ]{0,9});.+buil/i
              // Generic Android Device
            ],
            [MODEL, [VENDOR, "Generic"]]
          ],
          engine: [
            [
              /windows.+ edge\/([\w\.]+)/i
              // EdgeHTML
            ],
            [VERSION, [NAME, EDGE + "HTML"]],
            [
              /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
              // Blink
            ],
            [VERSION, [NAME, "Blink"]],
            [
              /(presto)\/([\w\.]+)/i,
              // Presto
              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
              // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
              /ekioh(flow)\/([\w\.]+)/i,
              // Flow
              /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
              // KHTML/Tasman/Links
              /(icab)[\/ ]([23]\.[\d\.]+)/i,
              // iCab
              /\b(libweb)/i
            ],
            [NAME, VERSION],
            [
              /rv\:([\w\.]{1,9})\b.+(gecko)/i
              // Gecko
            ],
            [VERSION, NAME]
          ],
          os: [
            [
              // Windows
              /microsoft (windows) (vista|xp)/i
              // Windows (iTunes)
            ],
            [NAME, VERSION],
            [
              /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
              // Windows Phone
            ],
            [NAME, [VERSION, strMapper, windowsVersionMap]],
            [
              /windows nt 6\.2; (arm)/i,
              // Windows RT
              /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
              /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ],
            [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
            [
              // iOS/macOS
              /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
              // iOS
              /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
              /cfnetwork\/.+darwin/i
            ],
            [[VERSION, /_/g, "."], [NAME, "iOS"]],
            [
              /(mac os x) ?([\w\. ]*)/i,
              /(macintosh|mac_powerpc\b)(?!.+haiku)/i
              // Mac OS
            ],
            [[NAME, MAC_OS], [VERSION, /_/g, "."]],
            [
              // Mobile OSes
              /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
              // Android-x86/HarmonyOS
            ],
            [VERSION, NAME],
            [
              // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
              /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
              /(blackberry)\w*\/([\w\.]*)/i,
              // Blackberry
              /(tizen|kaios)[\/ ]([\w\.]+)/i,
              // Tizen/KaiOS
              /\((series40);/i
              // Series 40
            ],
            [NAME, VERSION],
            [
              /\(bb(10);/i
              // BlackBerry 10
            ],
            [VERSION, [NAME, BLACKBERRY]],
            [
              /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
              // Symbian
            ],
            [VERSION, [NAME, "Symbian"]],
            [
              /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
              // Firefox OS
            ],
            [VERSION, [NAME, FIREFOX + " OS"]],
            [
              /web0s;.+rt(tv)/i,
              /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
              // WebOS
            ],
            [VERSION, [NAME, "webOS"]],
            [
              /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
              // watchOS
            ],
            [VERSION, [NAME, "watchOS"]],
            [
              // Google Chromecast
              /crkey\/([\d\.]+)/i
              // Google Chromecast
            ],
            [VERSION, [NAME, CHROME + "cast"]],
            [
              /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
              // Chromium OS
            ],
            [[NAME, CHROMIUM_OS], VERSION],
            [
              // Smart TVs
              /panasonic;(viera)/i,
              // Panasonic Viera
              /(netrange)mmh/i,
              // Netrange
              /(nettv)\/(\d+\.[\w\.]+)/i,
              // NetTV
              // Console
              /(nintendo|playstation) ([wids345portablevuch]+)/i,
              // Nintendo/Playstation
              /(xbox); +xbox ([^\);]+)/i,
              // Microsoft Xbox (360, One, X, S, Series X, Series S)
              // Other
              /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
              // Joli/Palm
              /(mint)[\/\(\) ]?(\w*)/i,
              // Mint
              /(mageia|vectorlinux)[; ]/i,
              // Mageia/VectorLinux
              /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
              // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
              /(hurd|linux) ?([\w\.]*)/i,
              // Hurd/Linux
              /(gnu) ?([\w\.]*)/i,
              // GNU
              /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
              // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
              /(haiku) (\w+)/i
              // Haiku
            ],
            [NAME, VERSION],
            [
              /(sunos) ?([\w\.\d]*)/i
              // Solaris
            ],
            [[NAME, "Solaris"], VERSION],
            [
              /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
              // Solaris
              /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
              // AIX
              /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
              // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
              /(unix) ?([\w\.]*)/i
              // UNIX
            ],
            [NAME, VERSION]
          ]
        };
        var UAParser = function(ua, extensions) {
          if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined2;
          }
          if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
          }
          var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
          var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
          var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
          var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
          var _isSelfNav = _navigator && _navigator.userAgent == _ua;
          this.getBrowser = function() {
            var _browser = {};
            _browser[NAME] = undefined2;
            _browser[VERSION] = undefined2;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
              _browser[NAME] = "Brave";
            }
            return _browser;
          };
          this.getCPU = function() {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined2;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
          };
          this.getDevice = function() {
            var _device = {};
            _device[VENDOR] = undefined2;
            _device[MODEL] = undefined2;
            _device[TYPE] = undefined2;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
              _device[TYPE] = MOBILE;
            }
            if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
              _device[MODEL] = "iPad";
              _device[TYPE] = TABLET;
            }
            return _device;
          };
          this.getEngine = function() {
            var _engine = {};
            _engine[NAME] = undefined2;
            _engine[VERSION] = undefined2;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
          };
          this.getOS = function() {
            var _os = {};
            _os[NAME] = undefined2;
            _os[VERSION] = undefined2;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != "Unknown") {
              _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
            }
            return _os;
          };
          this.getResult = function() {
            return {
              ua: this.getUA(),
              browser: this.getBrowser(),
              engine: this.getEngine(),
              os: this.getOS(),
              device: this.getDevice(),
              cpu: this.getCPU()
            };
          };
          this.getUA = function() {
            return _ua;
          };
          this.setUA = function(ua2) {
            _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
            return this;
          };
          this.setUA(_ua);
          return this;
        };
        UAParser.VERSION = LIBVERSION;
        UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
        UAParser.CPU = enumerize([ARCHITECTURE]);
        UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
        UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
        if (typeof exports !== UNDEF_TYPE) {
          if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
          }
          exports.UAParser = UAParser;
        } else {
          if (typeof define === FUNC_TYPE && define.amd) {
            define(function() {
              return UAParser;
            });
          } else if (typeof window2 !== UNDEF_TYPE) {
            window2.UAParser = UAParser;
          }
        }
        var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
        if ($ && !$.ua) {
          var parser = new UAParser();
          $.ua = parser.getResult();
          $.ua.get = function() {
            return parser.getUA();
          };
          $.ua.set = function(ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
              $.ua[prop] = result[prop];
            }
          };
        }
      })(typeof window === "object" ? window : exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/Logger.js
  var require_Logger = __commonJS({
    "../../node_modules/mediasoup-client/lib/Logger.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser());
      var APP_NAME = "mediasoup-client";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/events/events.js
  var require_events = __commonJS({
    "../../node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter2() {
        EventEmitter2.init.call(this);
      }
      module.exports = EventEmitter2;
      module.exports.once = once;
      EventEmitter2.EventEmitter = EventEmitter2;
      EventEmitter2.prototype._events = void 0;
      EventEmitter2.prototype._eventsCount = 0;
      EventEmitter2.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter2.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter2.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter2.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter2.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
      EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter2.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter2.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter2.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter2.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter2.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/EnhancedEventEmitter.js
  var require_EnhancedEventEmitter = __commonJS({
    "../../node_modules/mediasoup-client/lib/EnhancedEventEmitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EnhancedEventEmitter = void 0;
      var events_1 = require_events();
      var Logger_1 = require_Logger();
      var logger12 = new Logger_1.Logger("EnhancedEventEmitter");
      var EnhancedEventEmitter2 = class extends events_1.EventEmitter {
        constructor() {
          super();
          this.setMaxListeners(Infinity);
        }
        emit(eventName, ...args) {
          return super.emit(eventName, ...args);
        }
        /**
         * Special addition to the EventEmitter API.
         */
        safeEmit(eventName, ...args) {
          const numListeners = super.listenerCount(eventName);
          try {
            return super.emit(eventName, ...args);
          } catch (error) {
            logger12.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
            return Boolean(numListeners);
          }
        }
        on(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        off(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        addListener(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        prependListener(eventName, listener) {
          super.prependListener(eventName, listener);
          return this;
        }
        once(eventName, listener) {
          super.once(eventName, listener);
          return this;
        }
        prependOnceListener(eventName, listener) {
          super.prependOnceListener(eventName, listener);
          return this;
        }
        removeListener(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        removeAllListeners(eventName) {
          super.removeAllListeners(eventName);
          return this;
        }
        listenerCount(eventName) {
          return super.listenerCount(eventName);
        }
        listeners(eventName) {
          return super.listeners(eventName);
        }
        rawListeners(eventName) {
          return super.rawListeners(eventName);
        }
      };
      exports.EnhancedEventEmitter = EnhancedEventEmitter2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/errors.js
  var require_errors = __commonJS({
    "../../node_modules/mediasoup-client/lib/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidStateError = exports.UnsupportedError = void 0;
      var UnsupportedError = class _UnsupportedError extends Error {
        constructor(message) {
          super(message);
          this.name = "UnsupportedError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _UnsupportedError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.UnsupportedError = UnsupportedError;
      var InvalidStateError = class _InvalidStateError extends Error {
        constructor(message) {
          super(message);
          this.name = "InvalidStateError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _InvalidStateError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.InvalidStateError = InvalidStateError;
    }
  });

  // ../../node_modules/mediasoup-client/lib/utils.js
  var require_utils = __commonJS({
    "../../node_modules/mediasoup-client/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateRandomNumber = exports.clone = void 0;
      function clone(value) {
        if (value === void 0) {
          return void 0;
        } else if (Number.isNaN(value)) {
          return NaN;
        } else if (typeof structuredClone === "function") {
          return structuredClone(value);
        } else {
          return JSON.parse(JSON.stringify(value));
        }
      }
      exports.clone = clone;
      function generateRandomNumber() {
        return Math.round(Math.random() * 1e7);
      }
      exports.generateRandomNumber = generateRandomNumber;
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/Logger.js
  var require_Logger2 = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/Logger.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser());
      var APP_NAME = "h264-profile-level-id";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
      var Logger_1 = require_Logger2();
      var logger12 = new Logger_1.Logger();
      var Profile;
      (function(Profile2) {
        Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
        Profile2[Profile2["Baseline"] = 2] = "Baseline";
        Profile2[Profile2["Main"] = 3] = "Main";
        Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
        Profile2[Profile2["High"] = 5] = "High";
        Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
      })(Profile || (exports.Profile = Profile = {}));
      var Level;
      (function(Level2) {
        Level2[Level2["L1_b"] = 0] = "L1_b";
        Level2[Level2["L1"] = 10] = "L1";
        Level2[Level2["L1_1"] = 11] = "L1_1";
        Level2[Level2["L1_2"] = 12] = "L1_2";
        Level2[Level2["L1_3"] = 13] = "L1_3";
        Level2[Level2["L2"] = 20] = "L2";
        Level2[Level2["L2_1"] = 21] = "L2_1";
        Level2[Level2["L2_2"] = 22] = "L2_2";
        Level2[Level2["L3"] = 30] = "L3";
        Level2[Level2["L3_1"] = 31] = "L3_1";
        Level2[Level2["L3_2"] = 32] = "L3_2";
        Level2[Level2["L4"] = 40] = "L4";
        Level2[Level2["L4_1"] = 41] = "L4_1";
        Level2[Level2["L4_2"] = 42] = "L4_2";
        Level2[Level2["L5"] = 50] = "L5";
        Level2[Level2["L5_1"] = 51] = "L5_1";
        Level2[Level2["L5_2"] = 52] = "L5_2";
      })(Level || (exports.Level = Level = {}));
      var ProfileLevelId = class {
        constructor(profile, level) {
          this.profile = profile;
          this.level = level;
        }
      };
      exports.ProfileLevelId = ProfileLevelId;
      var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
      var BitPattern = class {
        constructor(str) {
          this.mask = ~byteMaskString("x", str);
          this.masked_value = byteMaskString("1", str);
        }
        isMatch(value) {
          return this.masked_value === (value & this.mask);
        }
      };
      var ProfilePattern = class {
        constructor(profile_idc, profile_iop, profile) {
          this.profile_idc = profile_idc;
          this.profile_iop = profile_iop;
          this.profile = profile;
        }
      };
      var ProfilePatterns = [
        new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
        new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
        new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
        new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
        new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
        new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
      ];
      function parseProfileLevelId(str) {
        const ConstraintSet3Flag = 16;
        if (typeof str !== "string" || str.length !== 6) {
          return void 0;
        }
        const profile_level_id_numeric = parseInt(str, 16);
        if (profile_level_id_numeric === 0) {
          return void 0;
        }
        const level_idc = profile_level_id_numeric & 255;
        const profile_iop = profile_level_id_numeric >> 8 & 255;
        const profile_idc = profile_level_id_numeric >> 16 & 255;
        let level;
        switch (level_idc) {
          case Level.L1_1: {
            level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
            break;
          }
          case Level.L1:
          case Level.L1_2:
          case Level.L1_3:
          case Level.L2:
          case Level.L2_1:
          case Level.L2_2:
          case Level.L3:
          case Level.L3_1:
          case Level.L3_2:
          case Level.L4:
          case Level.L4_1:
          case Level.L4_2:
          case Level.L5:
          case Level.L5_1:
          case Level.L5_2: {
            level = level_idc;
            break;
          }
          default: {
            logger12.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
            return void 0;
          }
        }
        for (const pattern of ProfilePatterns) {
          if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
          }
        }
        logger12.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
        return void 0;
      }
      exports.parseProfileLevelId = parseProfileLevelId;
      function profileLevelIdToString(profile_level_id) {
        if (profile_level_id.level == Level.L1_b) {
          switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline: {
              return "42f00b";
            }
            case Profile.Baseline: {
              return "42100b";
            }
            case Profile.Main: {
              return "4d100b";
            }
            default: {
              logger12.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
              return void 0;
            }
          }
        }
        let profile_idc_iop_string;
        switch (profile_level_id.profile) {
          case Profile.ConstrainedBaseline: {
            profile_idc_iop_string = "42e0";
            break;
          }
          case Profile.Baseline: {
            profile_idc_iop_string = "4200";
            break;
          }
          case Profile.Main: {
            profile_idc_iop_string = "4d00";
            break;
          }
          case Profile.ConstrainedHigh: {
            profile_idc_iop_string = "640c";
            break;
          }
          case Profile.High: {
            profile_idc_iop_string = "6400";
            break;
          }
          case Profile.PredictiveHigh444: {
            profile_idc_iop_string = "f400";
            break;
          }
          default: {
            logger12.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
            return void 0;
          }
        }
        let levelStr = profile_level_id.level.toString(16);
        if (levelStr.length === 1) {
          levelStr = `0${levelStr}`;
        }
        return `${profile_idc_iop_string}${levelStr}`;
      }
      exports.profileLevelIdToString = profileLevelIdToString;
      function profileToString(profile) {
        switch (profile) {
          case Profile.ConstrainedBaseline: {
            return "ConstrainedBaseline";
          }
          case Profile.Baseline: {
            return "Baseline";
          }
          case Profile.Main: {
            return "Main";
          }
          case Profile.ConstrainedHigh: {
            return "ConstrainedHigh";
          }
          case Profile.High: {
            return "High";
          }
          case Profile.PredictiveHigh444: {
            return "PredictiveHigh444";
          }
          default: {
            logger12.warn(`profileToString() | unrecognized profile ${profile}`);
            return void 0;
          }
        }
      }
      exports.profileToString = profileToString;
      function levelToString(level) {
        switch (level) {
          case Level.L1_b: {
            return "1b";
          }
          case Level.L1: {
            return "1";
          }
          case Level.L1_1: {
            return "1.1";
          }
          case Level.L1_2: {
            return "1.2";
          }
          case Level.L1_3: {
            return "1.3";
          }
          case Level.L2: {
            return "2";
          }
          case Level.L2_1: {
            return "2.1";
          }
          case Level.L2_2: {
            return "2.2";
          }
          case Level.L3: {
            return "3";
          }
          case Level.L3_1: {
            return "3.1";
          }
          case Level.L3_2: {
            return "3.2";
          }
          case Level.L4: {
            return "4";
          }
          case Level.L4_1: {
            return "4.1";
          }
          case Level.L4_2: {
            return "4.2";
          }
          case Level.L5: {
            return "5";
          }
          case Level.L5_1: {
            return "5.1";
          }
          case Level.L5_2: {
            return "5.2";
          }
          default: {
            logger12.warn(`levelToString() | unrecognized level ${level}`);
            return void 0;
          }
        }
      }
      exports.levelToString = levelToString;
      function parseSdpProfileLevelId(params = {}) {
        const profile_level_id = params["profile-level-id"];
        return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
      }
      exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
      function isSameProfile(params1 = {}, params2 = {}) {
        const profile_level_id_1 = parseSdpProfileLevelId(params1);
        const profile_level_id_2 = parseSdpProfileLevelId(params2);
        return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
      }
      exports.isSameProfile = isSameProfile;
      function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
        if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
          logger12.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
          return void 0;
        }
        const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
        const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
        if (!local_profile_level_id) {
          throw new TypeError("invalid local_profile_level_id");
        }
        if (!remote_profile_level_id) {
          throw new TypeError("invalid remote_profile_level_id");
        }
        if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
          throw new TypeError("H264 Profile mismatch");
        }
        const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
        const local_level = local_profile_level_id.level;
        const remote_level = remote_profile_level_id.level;
        const min_level = minLevel(local_level, remote_level);
        const answer_level = level_asymmetry_allowed ? local_level : min_level;
        logger12.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
        return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
      }
      exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
      function byteMaskString(c, str) {
        return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
      }
      function isLessLevel(a, b) {
        if (a === Level.L1_b) {
          return b !== Level.L1 && b !== Level.L1_b;
        }
        if (b === Level.L1_b) {
          return a !== Level.L1;
        }
        return a < b;
      }
      function minLevel(a, b) {
        return isLessLevel(a, b) ? a : b;
      }
      function isLevelAsymmetryAllowed(params = {}) {
        const level_asymmetry_allowed = params["level-asymmetry-allowed"];
        return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/ortc.js
  var require_ortc = __commonJS({
    "../../node_modules/mediasoup-client/lib/ortc.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
      var h264 = __importStar(require_lib());
      var utils = __importStar(require_utils());
      var RTP_PROBATOR_MID = "probator";
      var RTP_PROBATOR_SSRC = 1234;
      var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
      function validateRtpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (caps.codecs && !Array.isArray(caps.codecs)) {
          throw new TypeError("caps.codecs is not an array");
        } else if (!caps.codecs) {
          caps.codecs = [];
        }
        for (const codec of caps.codecs) {
          validateRtpCodecCapability(codec);
        }
        if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
          throw new TypeError("caps.headerExtensions is not an array");
        } else if (!caps.headerExtensions) {
          caps.headerExtensions = [];
        }
        for (const ext of caps.headerExtensions) {
          validateRtpHeaderExtension(ext);
        }
      }
      exports.validateRtpCapabilities = validateRtpCapabilities;
      function validateRtpCodecCapability(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        codec.kind = mimeTypeMatch[1].toLowerCase();
        if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== "number") {
          throw new TypeError("invalid codec.preferredPayloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        if (codec.kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      exports.validateRtpCodecCapability = validateRtpCodecCapability;
      function validateRtcpFeedback(fb) {
        if (typeof fb !== "object") {
          throw new TypeError("fb is not an object");
        }
        if (!fb.type || typeof fb.type !== "string") {
          throw new TypeError("missing fb.type");
        }
        if (!fb.parameter || typeof fb.parameter !== "string") {
          fb.parameter = "";
        }
      }
      exports.validateRtcpFeedback = validateRtcpFeedback;
      function validateRtpHeaderExtension(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (ext.kind !== "audio" && ext.kind !== "video") {
          throw new TypeError("invalid ext.kind");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.preferredId !== "number") {
          throw new TypeError("missing ext.preferredId");
        }
        if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
          throw new TypeError("invalid ext.preferredEncrypt");
        } else if (!ext.preferredEncrypt) {
          ext.preferredEncrypt = false;
        }
        if (ext.direction && typeof ext.direction !== "string") {
          throw new TypeError("invalid ext.direction");
        } else if (!ext.direction) {
          ext.direction = "sendrecv";
        }
      }
      exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
      function validateRtpParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (params.mid && typeof params.mid !== "string") {
          throw new TypeError("params.mid is not a string");
        }
        if (!Array.isArray(params.codecs)) {
          throw new TypeError("missing params.codecs");
        }
        for (const codec of params.codecs) {
          validateRtpCodecParameters(codec);
        }
        if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
          throw new TypeError("params.headerExtensions is not an array");
        } else if (!params.headerExtensions) {
          params.headerExtensions = [];
        }
        for (const ext of params.headerExtensions) {
          validateRtpHeaderExtensionParameters(ext);
        }
        if (params.encodings && !Array.isArray(params.encodings)) {
          throw new TypeError("params.encodings is not an array");
        } else if (!params.encodings) {
          params.encodings = [];
        }
        for (const encoding of params.encodings) {
          validateRtpEncodingParameters(encoding);
        }
        if (params.rtcp && typeof params.rtcp !== "object") {
          throw new TypeError("params.rtcp is not an object");
        } else if (!params.rtcp) {
          params.rtcp = {};
        }
        validateRtcpParameters(params.rtcp);
      }
      exports.validateRtpParameters = validateRtpParameters;
      function validateRtpCodecParameters(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        if (typeof codec.payloadType !== "number") {
          throw new TypeError("missing codec.payloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        const kind = mimeTypeMatch[1].toLowerCase();
        if (kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      exports.validateRtpCodecParameters = validateRtpCodecParameters;
      function validateRtpHeaderExtensionParameters(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.id !== "number") {
          throw new TypeError("missing ext.id");
        }
        if (ext.encrypt && typeof ext.encrypt !== "boolean") {
          throw new TypeError("invalid ext.encrypt");
        } else if (!ext.encrypt) {
          ext.encrypt = false;
        }
        if (!ext.parameters || typeof ext.parameters !== "object") {
          ext.parameters = {};
        }
        for (const key of Object.keys(ext.parameters)) {
          let value = ext.parameters[key];
          if (value === void 0) {
            ext.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError("invalid header extension parameter");
          }
        }
      }
      exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
      function validateRtpEncodingParameters(encoding) {
        if (typeof encoding !== "object") {
          throw new TypeError("encoding is not an object");
        }
        if (encoding.ssrc && typeof encoding.ssrc !== "number") {
          throw new TypeError("invalid encoding.ssrc");
        }
        if (encoding.rid && typeof encoding.rid !== "string") {
          throw new TypeError("invalid encoding.rid");
        }
        if (encoding.rtx && typeof encoding.rtx !== "object") {
          throw new TypeError("invalid encoding.rtx");
        } else if (encoding.rtx) {
          if (typeof encoding.rtx.ssrc !== "number") {
            throw new TypeError("missing encoding.rtx.ssrc");
          }
        }
        if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
          encoding.dtx = false;
        }
        if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
          throw new TypeError("invalid encoding.scalabilityMode");
        }
      }
      exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
      function validateRtcpParameters(rtcp) {
        if (typeof rtcp !== "object") {
          throw new TypeError("rtcp is not an object");
        }
        if (rtcp.cname && typeof rtcp.cname !== "string") {
          throw new TypeError("invalid rtcp.cname");
        }
        if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
          rtcp.reducedSize = true;
        }
      }
      exports.validateRtcpParameters = validateRtcpParameters;
      function validateSctpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (!caps.numStreams || typeof caps.numStreams !== "object") {
          throw new TypeError("missing caps.numStreams");
        }
        validateNumSctpStreams(caps.numStreams);
      }
      exports.validateSctpCapabilities = validateSctpCapabilities;
      function validateNumSctpStreams(numStreams) {
        if (typeof numStreams !== "object") {
          throw new TypeError("numStreams is not an object");
        }
        if (typeof numStreams.OS !== "number") {
          throw new TypeError("missing numStreams.OS");
        }
        if (typeof numStreams.MIS !== "number") {
          throw new TypeError("missing numStreams.MIS");
        }
      }
      exports.validateNumSctpStreams = validateNumSctpStreams;
      function validateSctpParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (typeof params.port !== "number") {
          throw new TypeError("missing params.port");
        }
        if (typeof params.OS !== "number") {
          throw new TypeError("missing params.OS");
        }
        if (typeof params.MIS !== "number") {
          throw new TypeError("missing params.MIS");
        }
        if (typeof params.maxMessageSize !== "number") {
          throw new TypeError("missing params.maxMessageSize");
        }
      }
      exports.validateSctpParameters = validateSctpParameters;
      function validateSctpStreamParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (typeof params.streamId !== "number") {
          throw new TypeError("missing params.streamId");
        }
        let orderedGiven = false;
        if (typeof params.ordered === "boolean") {
          orderedGiven = true;
        } else {
          params.ordered = true;
        }
        if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") {
          throw new TypeError("invalid params.maxPacketLifeTime");
        }
        if (params.maxRetransmits && typeof params.maxRetransmits !== "number") {
          throw new TypeError("invalid params.maxRetransmits");
        }
        if (params.maxPacketLifeTime && params.maxRetransmits) {
          throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
        }
        if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
          throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
        } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
          params.ordered = false;
        }
        if (params.label && typeof params.label !== "string") {
          throw new TypeError("invalid params.label");
        }
        if (params.protocol && typeof params.protocol !== "string") {
          throw new TypeError("invalid params.protocol");
        }
      }
      exports.validateSctpStreamParameters = validateSctpStreamParameters;
      function getExtendedRtpCapabilities(localCaps, remoteCaps) {
        const extendedRtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const remoteCodec of remoteCaps.codecs || []) {
          if (isRtxCodec(remoteCodec)) {
            continue;
          }
          const matchingLocalCodec = (localCaps.codecs || []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
          if (!matchingLocalCodec) {
            continue;
          }
          const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: void 0,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: void 0,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        }
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);
          const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
          if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
          }
        }
        for (const remoteExt of remoteCaps.headerExtensions) {
          const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
          if (!matchingLocalExt) {
            continue;
          }
          const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: "sendrecv"
          };
          switch (remoteExt.direction) {
            case "sendrecv": {
              extendedExt.direction = "sendrecv";
              break;
            }
            case "recvonly": {
              extendedExt.direction = "sendonly";
              break;
            }
            case "sendonly": {
              extendedExt.direction = "recvonly";
              break;
            }
            case "inactive": {
              extendedExt.direction = "inactive";
              break;
            }
          }
          extendedRtpCapabilities.headerExtensions.push(extendedExt);
        }
        return extendedRtpCapabilities;
      }
      exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
      function getRecvRtpCapabilities(extendedRtpCapabilities) {
        const rtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpCapabilities.codecs.push(codec);
          if (!extendedCodec.remoteRtxPayloadType) {
            continue;
          }
          const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
              apt: extendedCodec.remotePayloadType
            },
            rtcpFeedback: []
          };
          rtpCapabilities.codecs.push(rtxCodec);
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
            continue;
          }
          const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction
          };
          rtpCapabilities.headerExtensions.push(ext);
        }
        return rtpCapabilities;
      }
      exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
      function getSendingRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        return rtpParameters;
      }
      exports.getSendingRtpParameters = getSendingRtpParameters;
      function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "goog-remb");
          }
        } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "transport-cc");
          }
        } else {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
          }
        }
        return rtpParameters;
      }
      exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
      function reduceCodecs(codecs, capCodec) {
        const filteredCodecs = [];
        if (!capCodec) {
          filteredCodecs.push(codecs[0]);
          if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
          }
        } else {
          for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec)) {
              filteredCodecs.push(codecs[idx]);
              if (isRtxCodec(codecs[idx + 1])) {
                filteredCodecs.push(codecs[idx + 1]);
              }
              break;
            }
          }
          if (filteredCodecs.length === 0) {
            throw new TypeError("no matching codec found");
          }
        }
        return filteredCodecs;
      }
      exports.reduceCodecs = reduceCodecs;
      function generateProbatorRtpParameters(videoRtpParameters) {
        videoRtpParameters = utils.clone(videoRtpParameters);
        validateRtpParameters(videoRtpParameters);
        const rtpParameters = {
          mid: RTP_PROBATOR_MID,
          codecs: [],
          headerExtensions: [],
          encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
          rtcp: { cname: "probator" }
        };
        rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
        rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
        rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
        return rtpParameters;
      }
      exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
      function canSend(kind, extendedRtpCapabilities) {
        return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);
      }
      exports.canSend = canSend;
      function canReceive(rtpParameters, extendedRtpCapabilities) {
        validateRtpParameters(rtpParameters);
        if (rtpParameters.codecs.length === 0) {
          return false;
        }
        const firstMediaCodec = rtpParameters.codecs[0];
        return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
      }
      exports.canReceive = canReceive;
      function isRtxCodec(codec) {
        if (!codec) {
          return false;
        }
        return /.+\/rtx$/i.test(codec.mimeType);
      }
      function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
        const aMimeType = aCodec.mimeType.toLowerCase();
        const bMimeType = bCodec.mimeType.toLowerCase();
        if (aMimeType !== bMimeType) {
          return false;
        }
        if (aCodec.clockRate !== bCodec.clockRate) {
          return false;
        }
        if (aCodec.channels !== bCodec.channels) {
          return false;
        }
        switch (aMimeType) {
          case "video/h264": {
            if (strict) {
              const aPacketizationMode = aCodec.parameters["packetization-mode"] || 0;
              const bPacketizationMode = bCodec.parameters["packetization-mode"] || 0;
              if (aPacketizationMode !== bPacketizationMode) {
                return false;
              }
              if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                return false;
              }
              let selectedProfileLevelId;
              try {
                selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
              } catch (error) {
                return false;
              }
              if (modify) {
                if (selectedProfileLevelId) {
                  aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                  bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                } else {
                  delete aCodec.parameters["profile-level-id"];
                  delete bCodec.parameters["profile-level-id"];
                }
              }
            }
            break;
          }
          case "video/vp9": {
            if (strict) {
              const aProfileId = aCodec.parameters["profile-id"] || 0;
              const bProfileId = bCodec.parameters["profile-id"] || 0;
              if (aProfileId !== bProfileId) {
                return false;
              }
            }
            break;
          }
        }
        return true;
      }
      function matchHeaderExtensions(aExt, bExt) {
        if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
          return false;
        }
        if (aExt.uri !== bExt.uri) {
          return false;
        }
        return true;
      }
      function reduceRtcpFeedback(codecA, codecB) {
        const reducedRtcpFeedback = [];
        for (const aFb of codecA.rtcpFeedback || []) {
          const matchingBFb = (codecB.rtcpFeedback || []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
          if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
          }
        }
        return reducedRtcpFeedback;
      }
    }
  });

  // ../../node_modules/awaitqueue/lib/Logger.js
  var require_Logger3 = __commonJS({
    "../../node_modules/awaitqueue/lib/Logger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = require_browser();
      var LIB_NAME = "awaitqueue";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/awaitqueue/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/awaitqueue/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
      var Logger_1 = require_Logger3();
      var logger12 = new Logger_1.Logger();
      var AwaitQueueStoppedError = class _AwaitQueueStoppedError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue stopped");
          this.name = "AwaitQueueStoppedError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueStoppedError);
          }
        }
      };
      exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
      var AwaitQueueRemovedTaskError = class _AwaitQueueRemovedTaskError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue task removed");
          this.name = "AwaitQueueRemovedTaskError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueRemovedTaskError);
          }
        }
      };
      exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
      var AwaitQueue = class {
        constructor() {
          this.pendingTasks = /* @__PURE__ */ new Map();
          this.nextTaskId = 0;
          this.stopping = false;
        }
        get size() {
          return this.pendingTasks.size;
        }
        async push(task, name) {
          name = name ?? task.name;
          logger12.debug(`push() [name:${name}]`);
          if (typeof task !== "function") {
            throw new TypeError("given task is not a function");
          }
          if (name) {
            try {
              Object.defineProperty(task, "name", { value: name });
            } catch (error) {
            }
          }
          return new Promise((resolve, reject) => {
            const pendingTask = {
              id: this.nextTaskId++,
              task,
              name,
              enqueuedAt: Date.now(),
              executedAt: void 0,
              completed: false,
              resolve: (result) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger12.debug(`resolving task [name:${pendingTask.name}]`);
                resolve(result);
                const [nextPendingTask] = this.pendingTasks.values();
                if (nextPendingTask && !nextPendingTask.executedAt) {
                  void this.execute(nextPendingTask);
                }
              },
              reject: (error) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger12.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                reject(error);
                if (!this.stopping) {
                  const [nextPendingTask] = this.pendingTasks.values();
                  if (nextPendingTask && !nextPendingTask.executedAt) {
                    void this.execute(nextPendingTask);
                  }
                }
              }
            };
            this.pendingTasks.set(pendingTask.id, pendingTask);
            if (this.pendingTasks.size === 1) {
              void this.execute(pendingTask);
            }
          });
        }
        stop() {
          logger12.debug("stop()");
          this.stopping = true;
          for (const pendingTask of this.pendingTasks.values()) {
            logger12.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
          }
          this.stopping = false;
        }
        remove(taskIdx) {
          logger12.debug(`remove() [taskIdx:${taskIdx}]`);
          const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
          if (!pendingTask) {
            logger12.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
          }
          pendingTask.reject(new AwaitQueueRemovedTaskError());
        }
        dump() {
          const now = Date.now();
          let idx = 0;
          return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
          }));
        }
        async execute(pendingTask) {
          logger12.debug(`execute() [name:${pendingTask.name}]`);
          if (pendingTask.executedAt) {
            throw new Error("task already being executed");
          }
          pendingTask.executedAt = Date.now();
          try {
            const result = await pendingTask.task();
            pendingTask.resolve(result);
          } catch (error) {
            pendingTask.reject(error);
          }
        }
      };
      exports.AwaitQueue = AwaitQueue;
    }
  });

  // ../../node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "../../node_modules/queue-microtask/index.js"(exports, module) {
      "use strict";
      var promise;
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // ../../node_modules/mediasoup-client/lib/Producer.js
  var require_Producer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Producer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Producer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("Producer");
      var Producer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._rtpSender = rtpSender;
          this._track = track;
          this._kind = track.kind;
          this._rtpParameters = rtpParameters;
          this._paused = disableTrackOnPause ? !track.enabled : false;
          this._maxSpatialLayer = void 0;
          this._stopTracks = stopTracks;
          this._disableTrackOnPause = disableTrackOnPause;
          this._zeroRtpOnPause = zeroRtpOnPause;
          this._appData = appData || {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Producer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Whether the Producer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._kind;
        }
        /**
         * Associated RTCRtpSender.
         */
        get rtpSender() {
          return this._rtpSender;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Producer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * Max spatial layer.
         *
         * @type {Number | undefined}
         */
        get maxSpatialLayer() {
          return this._maxSpatialLayer;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Producer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpSender stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses sending media.
         */
        pause() {
          logger12.debug("pause()");
          if (this._closed) {
            logger12.error("pause() | Producer closed");
            return;
          }
          this._paused = true;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@pause", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes sending media.
         */
        resume() {
          logger12.debug("resume()");
          if (this._closed) {
            logger12.error("resume() | Producer closed");
            return;
          }
          this._paused = false;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@resume", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("resume");
        }
        /**
         * Replaces the current track with a new one or null.
         */
        async replaceTrack({ track }) {
          logger12.debug("replaceTrack() [track:%o]", track);
          if (this._closed) {
            if (track && this._stopTracks) {
              try {
                track.stop();
              } catch (error) {
              }
            }
            throw new errors_1.InvalidStateError("closed");
          } else if (track && track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          }
          if (track === this._track) {
            logger12.debug("replaceTrack() | same track, ignored");
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@replacetrack", track, resolve, reject);
          });
          this.destroyTrack();
          this._track = track;
          if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
              this._track.enabled = true;
            } else if (this._paused) {
              this._track.enabled = false;
            }
          }
          this.handleTrack();
        }
        /**
         * Sets the video max spatial layer to be sent.
         */
        async setMaxSpatialLayer(spatialLayer) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._kind !== "video") {
            throw new errors_1.UnsupportedError("not a video Producer");
          } else if (typeof spatialLayer !== "number") {
            throw new TypeError("invalid spatialLayer");
          }
          if (spatialLayer === this._maxSpatialLayer) {
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
          }).catch(() => {
          });
          this._maxSpatialLayer = spatialLayer;
        }
        async setRtpEncodingParameters(params) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (typeof params !== "object") {
            throw new TypeError("invalid params");
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
          });
        }
        onTrackEnded() {
          logger12.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          if (!this._track) {
            return;
          }
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          if (!this._track) {
            return;
          }
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            if (this._stopTracks) {
              this._track.stop();
            }
          } catch (error) {
          }
        }
      };
      exports.Producer = Producer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Consumer.js
  var require_Consumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Consumer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Consumer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("Consumer");
      var Consumer2 = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._producerId = producerId;
          this._rtpReceiver = rtpReceiver;
          this._track = track;
          this._rtpParameters = rtpParameters;
          this._paused = !track.enabled;
          this._appData = appData || {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Consumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Associated Producer id.
         */
        get producerId() {
          return this._producerId;
        }
        /**
         * Whether the Consumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._track.kind;
        }
        /**
         * Associated RTCRtpReceiver.
         */
        get rtpReceiver() {
          return this._rtpReceiver;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Consumer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Consumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpReceiver stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses receiving media.
         */
        pause() {
          logger12.debug("pause()");
          if (this._closed) {
            logger12.error("pause() | Consumer closed");
            return;
          }
          if (this._paused) {
            logger12.debug("pause() | Consumer is already paused");
            return;
          }
          this._paused = true;
          this._track.enabled = false;
          this.emit("@pause");
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes receiving media.
         */
        resume() {
          logger12.debug("resume()");
          if (this._closed) {
            logger12.error("resume() | Consumer closed");
            return;
          }
          if (!this._paused) {
            logger12.debug("resume() | Consumer is already resumed");
            return;
          }
          this._paused = false;
          this._track.enabled = true;
          this.emit("@resume");
          this._observer.safeEmit("resume");
        }
        onTrackEnded() {
          logger12.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            this._track.stop();
          } catch (error) {
          }
        }
      };
      exports.Consumer = Consumer2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataProducer.js
  var require_DataProducer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataProducer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataProducer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("DataProducer");
      var DataProducer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData || {};
          this.handleDataChannel();
        }
        /**
         * DataProducer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the DataProducer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel bufferedAmount.
         */
        get bufferedAmount() {
          return this._dataChannel.bufferedAmount;
        }
        /**
         * DataChannel bufferedAmountLowThreshold.
         */
        get bufferedAmountLowThreshold() {
          return this._dataChannel.bufferedAmountLowThreshold;
        }
        /**
         * Set DataChannel bufferedAmountLowThreshold.
         */
        set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
          this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataProducer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Send a message.
         *
         * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
         */
        send(data) {
          logger12.debug("send()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          this._dataChannel.send(data);
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger12.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger12.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger12.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "message" event in a DataProducer, message discarded');
          });
          this._dataChannel.addEventListener("bufferedamountlow", () => {
            if (this._closed) {
              return;
            }
            this.safeEmit("bufferedamountlow");
          });
        }
      };
      exports.DataProducer = DataProducer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataConsumer.js
  var require_DataConsumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataConsumer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataConsumer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var logger12 = new Logger_1.Logger("DataConsumer");
      var DataConsumer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._dataProducerId = dataProducerId;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData || {};
          this.handleDataChannel();
        }
        /**
         * DataConsumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Associated DataProducer id.
         */
        get dataProducerId() {
          return this._dataProducerId;
        }
        /**
         * Whether the DataConsumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel binaryType.
         */
        get binaryType() {
          return this._dataChannel.binaryType;
        }
        /**
         * Set DataChannel binaryType.
         */
        set binaryType(binaryType) {
          this._dataChannel.binaryType = binaryType;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataConsumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger12.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger12.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger12.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", (event) => {
            if (this._closed) {
              return;
            }
            this.safeEmit("message", event.data);
          });
        }
      };
      exports.DataConsumer = DataConsumer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Transport.js
  var require_Transport = __commonJS({
    "../../node_modules/mediasoup-client/lib/Transport.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transport = void 0;
      var awaitqueue_1 = require_lib2();
      var queue_microtask_1 = __importDefault(require_queue_microtask());
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Producer_1 = require_Producer();
      var Consumer_1 = require_Consumer();
      var DataProducer_1 = require_DataProducer();
      var DataConsumer_1 = require_DataConsumer();
      var logger12 = new Logger_1.Logger("Transport");
      var ConsumerCreationTask = class {
        constructor(consumerOptions) {
          this.consumerOptions = consumerOptions;
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
        }
      };
      var Transport2 = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {
          super();
          this._closed = false;
          this._iceGatheringState = "new";
          this._connectionState = "new";
          this._producers = /* @__PURE__ */ new Map();
          this._consumers = /* @__PURE__ */ new Map();
          this._dataProducers = /* @__PURE__ */ new Map();
          this._dataConsumers = /* @__PURE__ */ new Map();
          this._probatorConsumerCreated = false;
          this._awaitQueue = new awaitqueue_1.AwaitQueue();
          this._pendingConsumerTasks = [];
          this._consumerCreationInProgress = false;
          this._pendingPauseConsumers = /* @__PURE__ */ new Map();
          this._consumerPauseInProgress = false;
          this._pendingResumeConsumers = /* @__PURE__ */ new Map();
          this._consumerResumeInProgress = false;
          this._pendingCloseConsumers = /* @__PURE__ */ new Map();
          this._consumerCloseInProgress = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor() [id:%s, direction:%s]", id, direction);
          this._id = id;
          this._direction = direction;
          this._extendedRtpCapabilities = extendedRtpCapabilities;
          this._canProduceByKind = canProduceByKind;
          this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
          additionalSettings = utils.clone(additionalSettings) || {};
          delete additionalSettings.iceServers;
          delete additionalSettings.iceTransportPolicy;
          delete additionalSettings.bundlePolicy;
          delete additionalSettings.rtcpMuxPolicy;
          delete additionalSettings.sdpSemantics;
          this._handler = handlerFactory();
          this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities
          });
          this._appData = appData || {};
          this.handleHandler();
        }
        /**
         * Transport id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the Transport is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Transport direction.
         */
        get direction() {
          return this._direction;
        }
        /**
         * RTC handler instance.
         */
        get handler() {
          return this._handler;
        }
        /**
         * ICE gathering state.
         */
        get iceGatheringState() {
          return this._iceGatheringState;
        }
        /**
         * Connection state.
         */
        get connectionState() {
          return this._connectionState;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Close the Transport.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._awaitQueue.stop();
          this._handler.close();
          this._connectionState = "closed";
          for (const producer of this._producers.values()) {
            producer.transportClosed();
          }
          this._producers.clear();
          for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
          }
          this._consumers.clear();
          for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
          }
          this._dataProducers.clear();
          for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
          }
          this._dataConsumers.clear();
          this._observer.safeEmit("close");
        }
        /**
         * Get associated Transport (RTCPeerConnection) stats.
         *
         * @returns {RTCStatsReport}
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return this._handler.getTransportStats();
        }
        /**
         * Restart ICE connection.
         */
        async restartIce({ iceParameters }) {
          logger12.debug("restartIce()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!iceParameters) {
            throw new TypeError("missing iceParameters");
          }
          return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
        }
        /**
         * Update ICE servers.
         */
        async updateIceServers({ iceServers } = {}) {
          logger12.debug("updateIceServers()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!Array.isArray(iceServers)) {
            throw new TypeError("missing iceServers");
          }
          return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
        }
        /**
         * Create a Producer.
         */
        async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {
          logger12.debug("produce() [track:%o]", track);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!track) {
            throw new TypeError("missing track");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
          } else if (track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("produce") === 0) {
            throw new TypeError('no "produce" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          return this._awaitQueue.push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
              throw TypeError("encodings must be an array");
            } else if (encodings && encodings.length === 0) {
              normalizedEncodings = void 0;
            } else if (encodings) {
              normalizedEncodings = encodings.map((encoding) => {
                const normalizedEncoding = { active: true };
                if (encoding.active === false) {
                  normalizedEncoding.active = false;
                }
                if (typeof encoding.dtx === "boolean") {
                  normalizedEncoding.dtx = encoding.dtx;
                }
                if (typeof encoding.scalabilityMode === "string") {
                  normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                }
                if (typeof encoding.scaleResolutionDownBy === "number") {
                  normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                }
                if (typeof encoding.maxBitrate === "number") {
                  normalizedEncoding.maxBitrate = encoding.maxBitrate;
                }
                if (typeof encoding.maxFramerate === "number") {
                  normalizedEncoding.maxFramerate = encoding.maxFramerate;
                }
                if (typeof encoding.adaptivePtime === "boolean") {
                  normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                }
                if (typeof encoding.priority === "string") {
                  normalizedEncoding.priority = encoding.priority;
                }
                if (typeof encoding.networkPriority === "string") {
                  normalizedEncoding.networkPriority = encoding.networkPriority;
                }
                return normalizedEncoding;
              });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
              track,
              encodings: normalizedEncodings,
              codecOptions,
              codec
            });
            try {
              ortc.validateRtpParameters(rtpParameters);
              const { id } = await new Promise((resolve, reject) => {
                this.safeEmit("produce", {
                  kind: track.kind,
                  rtpParameters,
                  appData
                }, resolve, reject);
              });
              const producer = new Producer_1.Producer({
                id,
                localId,
                rtpSender,
                track,
                rtpParameters,
                stopTracks,
                disableTrackOnPause,
                zeroRtpOnPause,
                appData
              });
              this._producers.set(producer.id, producer);
              this.handleProducer(producer);
              this._observer.safeEmit("newproducer", producer);
              return producer;
            } catch (error) {
              this._handler.stopSending(localId).catch(() => {
              });
              throw error;
            }
          }, "transport.produce()").catch((error) => {
            if (stopTracks) {
              try {
                track.stop();
              } catch (error2) {
              }
            }
            throw error;
          });
        }
        /**
         * Create a Consumer to consume a remote Producer.
         */
        async consume({ id, producerId, kind, rtpParameters, streamId, appData = {} }) {
          logger12.debug("consume()");
          rtpParameters = utils.clone(rtpParameters);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof producerId !== "string") {
            throw new TypeError("missing producerId");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind '${kind}'`);
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
          if (!canConsume) {
            throw new errors_1.UnsupportedError("cannot consume this Producer");
          }
          const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters,
            streamId,
            appData
          });
          this._pendingConsumerTasks.push(consumerCreationTask);
          (0, queue_microtask_1.default)(() => {
            if (this._closed) {
              return;
            }
            if (this._consumerCreationInProgress === false) {
              this.createPendingConsumers();
            }
          });
          return consumerCreationTask.promise;
        }
        /**
         * Create a DataProducer
         */
        async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol = "", appData = {} } = {}) {
          logger12.debug("produceData()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("producedata") === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
          }
          return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              label,
              protocol
            });
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
              this.safeEmit("producedata", {
                sctpStreamParameters,
                label,
                protocol,
                appData
              }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
              id,
              dataChannel,
              sctpStreamParameters,
              appData
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            this._observer.safeEmit("newdataproducer", dataProducer);
            return dataProducer;
          }, "transport.produceData()");
        }
        /**
         * Create a DataConsumer
         */
        async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol = "", appData = {} }) {
          logger12.debug("consumeData()");
          sctpStreamParameters = utils.clone(sctpStreamParameters);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof dataProducerId !== "string") {
            throw new TypeError("missing dataProducerId");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          ortc.validateSctpStreamParameters(sctpStreamParameters);
          return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
              sctpStreamParameters,
              label,
              protocol
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
              id,
              dataProducerId,
              dataChannel,
              sctpStreamParameters,
              appData
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            this._observer.safeEmit("newdataconsumer", dataConsumer);
            return dataConsumer;
          }, "transport.consumeData()");
        }
        // This method is guaranteed to never throw.
        async createPendingConsumers() {
          this._consumerCreationInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
              logger12.debug("createPendingConsumers() | there is no Consumer to be created");
              return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            this._pendingConsumerTasks = [];
            let videoConsumerForProbator = void 0;
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
              const { id, kind, rtpParameters, streamId } = task.consumerOptions;
              optionsList.push({
                trackId: id,
                kind,
                rtpParameters,
                streamId
              });
            }
            try {
              const results = await this._handler.receive(optionsList);
              for (let idx = 0; idx < results.length; ++idx) {
                const task = pendingConsumerTasks[idx];
                const result = results[idx];
                const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                const { localId, rtpReceiver, track } = result;
                const consumer = new Consumer_1.Consumer({
                  id,
                  localId,
                  producerId,
                  rtpReceiver,
                  track,
                  rtpParameters,
                  appData
                });
                this._consumers.set(consumer.id, consumer);
                this.handleConsumer(consumer);
                if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
                  videoConsumerForProbator = consumer;
                }
                this._observer.safeEmit("newconsumer", consumer);
                task.resolve(consumer);
              }
            } catch (error) {
              for (const task of pendingConsumerTasks) {
                task.reject(error);
              }
            }
            if (videoConsumerForProbator) {
              try {
                const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                await this._handler.receive([
                  {
                    trackId: "probator",
                    kind: "video",
                    rtpParameters: probatorRtpParameters
                  }
                ]);
                logger12.debug("createPendingConsumers() | Consumer for RTP probation created");
                this._probatorConsumerCreated = true;
              } catch (error) {
                logger12.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
              }
            }
          }, "transport.createPendingConsumers()").then(() => {
            this._consumerCreationInProgress = false;
            if (this._pendingConsumerTasks.length > 0) {
              this.createPendingConsumers();
            }
          }).catch(() => {
          });
        }
        pausePendingConsumers() {
          this._consumerPauseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
              logger12.debug("pausePendingConsumers() | there is no Consumer to be paused");
              return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            this._pendingPauseConsumers.clear();
            try {
              const localIds = pendingPauseConsumers.map((consumer) => consumer.localId);
              await this._handler.pauseReceiving(localIds);
            } catch (error) {
              logger12.error("pausePendingConsumers() | failed to pause Consumers:", error);
            }
          }, "transport.pausePendingConsumers").then(() => {
            this._consumerPauseInProgress = false;
            if (this._pendingPauseConsumers.size > 0) {
              this.pausePendingConsumers();
            }
          }).catch(() => {
          });
        }
        resumePendingConsumers() {
          this._consumerResumeInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
              logger12.debug("resumePendingConsumers() | there is no Consumer to be resumed");
              return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            this._pendingResumeConsumers.clear();
            try {
              const localIds = pendingResumeConsumers.map((consumer) => consumer.localId);
              await this._handler.resumeReceiving(localIds);
            } catch (error) {
              logger12.error("resumePendingConsumers() | failed to resume Consumers:", error);
            }
          }, "transport.resumePendingConsumers").then(() => {
            this._consumerResumeInProgress = false;
            if (this._pendingResumeConsumers.size > 0) {
              this.resumePendingConsumers();
            }
          }).catch(() => {
          });
        }
        closePendingConsumers() {
          this._consumerCloseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
              logger12.debug("closePendingConsumers() | there is no Consumer to be closed");
              return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            this._pendingCloseConsumers.clear();
            try {
              await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));
            } catch (error) {
              logger12.error("closePendingConsumers() | failed to close Consumers:", error);
            }
          }, "transport.closePendingConsumers").then(() => {
            this._consumerCloseInProgress = false;
            if (this._pendingCloseConsumers.size > 0) {
              this.closePendingConsumers();
            }
          }).catch(() => {
          });
        }
        handleHandler() {
          const handler = this._handler;
          handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
              errback(new errors_1.InvalidStateError("closed"));
              return;
            }
            this.safeEmit("connect", { dtlsParameters }, callback, errback);
          });
          handler.on("@icegatheringstatechange", (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
              return;
            }
            logger12.debug("ICE gathering state changed to %s", iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
              this.safeEmit("icegatheringstatechange", iceGatheringState);
            }
          });
          handler.on("@connectionstatechange", (connectionState) => {
            if (connectionState === this._connectionState) {
              return;
            }
            logger12.debug("connection state changed to %s", connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
              this.safeEmit("connectionstatechange", connectionState);
            }
          });
        }
        handleProducer(producer) {
          producer.on("@close", () => {
            this._producers.delete(producer.id);
            if (this._closed) {
              return;
            }
            this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), "producer @close event").catch((error) => logger12.warn("producer.close() failed:%o", error));
          });
          producer.on("@pause", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
          });
          producer.on("@resume", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
          });
          producer.on("@replacetrack", (track, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
          });
          producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
          });
          producer.on("@setrtpencodingparameters", (params, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
          });
          producer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
          });
        }
        handleConsumer(consumer) {
          consumer.on("@close", () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
              return;
            }
            this._pendingCloseConsumers.set(consumer.id, consumer);
            if (this._consumerCloseInProgress === false) {
              this.closePendingConsumers();
            }
          });
          consumer.on("@pause", () => {
            if (this._pendingResumeConsumers.has(consumer.id)) {
              this._pendingResumeConsumers.delete(consumer.id);
            }
            this._pendingPauseConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerPauseInProgress === false) {
                this.pausePendingConsumers();
              }
            });
          });
          consumer.on("@resume", () => {
            if (this._pendingPauseConsumers.has(consumer.id)) {
              this._pendingPauseConsumers.delete(consumer.id);
            }
            this._pendingResumeConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerResumeInProgress === false) {
                this.resumePendingConsumers();
              }
            });
          });
          consumer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
          });
        }
        handleDataProducer(dataProducer) {
          dataProducer.on("@close", () => {
            this._dataProducers.delete(dataProducer.id);
          });
        }
        handleDataConsumer(dataConsumer) {
          dataConsumer.on("@close", () => {
            this._dataConsumers.delete(dataConsumer.id);
          });
        }
      };
      exports.Transport = Transport2;
    }
  });

  // ../../node_modules/sdp-transform/lib/grammar.js
  var require_grammar = __commonJS({
    "../../node_modules/sdp-transform/lib/grammar.js"(exports, module) {
      "use strict";
      var grammar = module.exports = {
        v: [{
          name: "version",
          reg: /^(\d*)$/
        }],
        o: [{
          // o=- 20518 0 IN IP4 203.0.113.1
          // NB: sessionId will be a String in most cases because it is huge
          name: "origin",
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
          format: "%s %s %d %s IP%d %s"
        }],
        // default parsing of these only (though some of these feel outdated)
        s: [{ name: "name" }],
        i: [{ name: "description" }],
        u: [{ name: "uri" }],
        e: [{ name: "email" }],
        p: [{ name: "phone" }],
        z: [{ name: "timezones" }],
        // TODO: this one can actually be parsed properly...
        r: [{ name: "repeats" }],
        // TODO: this one can also be parsed properly
        // k: [{}], // outdated thing ignored
        t: [{
          // t=0 0
          name: "timing",
          reg: /^(\d*) (\d*)/,
          names: ["start", "stop"],
          format: "%d %d"
        }],
        c: [{
          // c=IN IP4 10.47.197.26
          name: "connection",
          reg: /^IN IP(\d) (\S*)/,
          names: ["version", "ip"],
          format: "IN IP%d %s"
        }],
        b: [{
          // b=AS:4000
          push: "bandwidth",
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ["type", "limit"],
          format: "%s:%s"
        }],
        m: [{
          // m=video 51744 RTP/AVP 126 97 98 34 31
          // NB: special - pushes to session
          // TODO: rtp/fmtp should be filtered by the payloads found here?
          reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
          names: ["type", "port", "protocol", "payloads"],
          format: "%s %d %s %s"
        }],
        a: [
          {
            // a=rtpmap:110 opus/48000/2
            push: "rtp",
            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
            names: ["payload", "codec", "rate", "encoding"],
            format: function(o) {
              return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
            }
          },
          {
            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
            // a=fmtp:111 minptime=10; useinbandfec=1
            push: "fmtp",
            reg: /^fmtp:(\d*) ([\S| ]*)/,
            names: ["payload", "config"],
            format: "fmtp:%d %s"
          },
          {
            // a=control:streamid=0
            name: "control",
            reg: /^control:(.*)/,
            format: "control:%s"
          },
          {
            // a=rtcp:65179 IN IP4 193.84.77.194
            name: "rtcp",
            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
            names: ["port", "netType", "ipVer", "address"],
            format: function(o) {
              return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
            }
          },
          {
            // a=rtcp-fb:98 trr-int 100
            push: "rtcpFbTrrInt",
            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
            names: ["payload", "value"],
            format: "rtcp-fb:%s trr-int %d"
          },
          {
            // a=rtcp-fb:98 nack rpsi
            push: "rtcpFb",
            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
            names: ["payload", "type", "subtype"],
            format: function(o) {
              return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
            }
          },
          {
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:1/recvonly URI-gps-string
            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
            push: "ext",
            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
            names: ["value", "direction", "encrypt-uri", "uri", "config"],
            format: function(o) {
              return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
            }
          },
          {
            // a=extmap-allow-mixed
            name: "extmapAllowMixed",
            reg: /^(extmap-allow-mixed)/
          },
          {
            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
            push: "crypto",
            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
            names: ["id", "suite", "config", "sessionConfig"],
            format: function(o) {
              return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
            }
          },
          {
            // a=setup:actpass
            name: "setup",
            reg: /^setup:(\w*)/,
            format: "setup:%s"
          },
          {
            // a=connection:new
            name: "connectionType",
            reg: /^connection:(new|existing)/,
            format: "connection:%s"
          },
          {
            // a=mid:1
            name: "mid",
            reg: /^mid:([^\s]*)/,
            format: "mid:%s"
          },
          {
            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
            name: "msid",
            reg: /^msid:(.*)/,
            format: "msid:%s"
          },
          {
            // a=ptime:20
            name: "ptime",
            reg: /^ptime:(\d*(?:\.\d*)*)/,
            format: "ptime:%d"
          },
          {
            // a=maxptime:60
            name: "maxptime",
            reg: /^maxptime:(\d*(?:\.\d*)*)/,
            format: "maxptime:%d"
          },
          {
            // a=sendrecv
            name: "direction",
            reg: /^(sendrecv|recvonly|sendonly|inactive)/
          },
          {
            // a=ice-lite
            name: "icelite",
            reg: /^(ice-lite)/
          },
          {
            // a=ice-ufrag:F7gI
            name: "iceUfrag",
            reg: /^ice-ufrag:(\S*)/,
            format: "ice-ufrag:%s"
          },
          {
            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
            name: "icePwd",
            reg: /^ice-pwd:(\S*)/,
            format: "ice-pwd:%s"
          },
          {
            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
            name: "fingerprint",
            reg: /^fingerprint:(\S*) (\S*)/,
            names: ["type", "hash"],
            format: "fingerprint:%s %s"
          },
          {
            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
            push: "candidates",
            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
            format: function(o) {
              var str = "candidate:%s %d %s %d %s %d typ %s";
              str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
              str += o.tcptype != null ? " tcptype %s" : "%v";
              if (o.generation != null) {
                str += " generation %d";
              }
              str += o["network-id"] != null ? " network-id %d" : "%v";
              str += o["network-cost"] != null ? " network-cost %d" : "%v";
              return str;
            }
          },
          {
            // a=end-of-candidates (keep after the candidates line for readability)
            name: "endOfCandidates",
            reg: /^(end-of-candidates)/
          },
          {
            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
            name: "remoteCandidates",
            reg: /^remote-candidates:(.*)/,
            format: "remote-candidates:%s"
          },
          {
            // a=ice-options:google-ice
            name: "iceOptions",
            reg: /^ice-options:(\S*)/,
            format: "ice-options:%s"
          },
          {
            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
            push: "ssrcs",
            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
            names: ["id", "attribute", "value"],
            format: function(o) {
              var str = "ssrc:%d";
              if (o.attribute != null) {
                str += " %s";
                if (o.value != null) {
                  str += ":%s";
                }
              }
              return str;
            }
          },
          {
            // a=ssrc-group:FEC 1 2
            // a=ssrc-group:FEC-FR 3004364195 1080772241
            push: "ssrcGroups",
            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
            names: ["semantics", "ssrcs"],
            format: "ssrc-group:%s %s"
          },
          {
            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
            name: "msidSemantic",
            reg: /^msid-semantic:\s?(\w*) (\S*)/,
            names: ["semantic", "token"],
            format: "msid-semantic: %s %s"
            // space after ':' is not accidental
          },
          {
            // a=group:BUNDLE audio video
            push: "groups",
            reg: /^group:(\w*) (.*)/,
            names: ["type", "mids"],
            format: "group:%s %s"
          },
          {
            // a=rtcp-mux
            name: "rtcpMux",
            reg: /^(rtcp-mux)/
          },
          {
            // a=rtcp-rsize
            name: "rtcpRsize",
            reg: /^(rtcp-rsize)/
          },
          {
            // a=sctpmap:5000 webrtc-datachannel 1024
            name: "sctpmap",
            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
            names: ["sctpmapNumber", "app", "maxMessageSize"],
            format: function(o) {
              return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
            }
          },
          {
            // a=x-google-flag:conference
            name: "xGoogleFlag",
            reg: /^x-google-flag:([^\s]*)/,
            format: "x-google-flag:%s"
          },
          {
            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
            push: "rids",
            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
            names: ["id", "direction", "params"],
            format: function(o) {
              return o.params ? "rid:%s %s %s" : "rid:%s %s";
            }
          },
          {
            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
            // a=imageattr:* send [x=800,y=640] recv *
            // a=imageattr:100 recv [x=320,y=240]
            push: "imageattrs",
            reg: new RegExp(
              // a=imageattr:97
              "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
            ),
            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
            format: function(o) {
              return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
            // a=simulcast:recv 1;4,5 send 6;7
            name: "simulcast",
            reg: new RegExp(
              // a=simulcast:
              "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
            ),
            names: ["dir1", "list1", "dir2", "list2"],
            format: function(o) {
              return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // old simulcast draft 03 (implemented by Firefox)
            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
            // a=simulcast: recv pt=97;98 send pt=97
            // a=simulcast: send rid=5;6;7 paused=6,7
            name: "simulcast_03",
            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
            names: ["value"],
            format: "simulcast: %s"
          },
          {
            // a=framerate:25
            // a=framerate:29.97
            name: "framerate",
            reg: /^framerate:(\d+(?:$|\.\d+))/,
            format: "framerate:%s"
          },
          {
            // RFC4570
            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
            name: "sourceFilter",
            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
            names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
            format: "source-filter: %s %s %s %s %s"
          },
          {
            // a=bundle-only
            name: "bundleOnly",
            reg: /^(bundle-only)/
          },
          {
            // a=label:1
            name: "label",
            reg: /^label:(.+)/,
            format: "label:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
            name: "sctpPort",
            reg: /^sctp-port:(\d+)$/,
            format: "sctp-port:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
            name: "maxMessageSize",
            reg: /^max-message-size:(\d+)$/,
            format: "max-message-size:%s"
          },
          {
            // RFC7273
            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
            push: "tsRefClocks",
            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
            names: ["clksrc", "clksrcExt"],
            format: function(o) {
              return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
            }
          },
          {
            // RFC7273
            // a=mediaclk:direct=963214424
            name: "mediaClk",
            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
            names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
            format: function(o) {
              var str = "mediaclk:";
              str += o.id != null ? "id=%s %s" : "%v%s";
              str += o.mediaClockValue != null ? "=%s" : "";
              str += o.rateNumerator != null ? " rate=%s" : "";
              str += o.rateDenominator != null ? "/%s" : "";
              return str;
            }
          },
          {
            // a=keywds:keywords
            name: "keywords",
            reg: /^keywds:(.+)$/,
            format: "keywds:%s"
          },
          {
            // a=content:main
            name: "content",
            reg: /^content:(.+)/,
            format: "content:%s"
          },
          // BFCP https://tools.ietf.org/html/rfc4583
          {
            // a=floorctrl:c-s
            name: "bfcpFloorCtrl",
            reg: /^floorctrl:(c-only|s-only|c-s)/,
            format: "floorctrl:%s"
          },
          {
            // a=confid:1
            name: "bfcpConfId",
            reg: /^confid:(\d+)/,
            format: "confid:%s"
          },
          {
            // a=userid:1
            name: "bfcpUserId",
            reg: /^userid:(\d+)/,
            format: "userid:%s"
          },
          {
            // a=floorid:1
            name: "bfcpFloorId",
            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
            names: ["id", "mStream"],
            format: "floorid:%s mstrm:%s"
          },
          {
            // any a= that we don't understand is kept verbatim on media.invalid
            push: "invalid",
            names: ["value"]
          }
        ]
      };
      Object.keys(grammar).forEach(function(key) {
        var objs = grammar[key];
        objs.forEach(function(obj) {
          if (!obj.reg) {
            obj.reg = /(.*)/;
          }
          if (!obj.format) {
            obj.format = "%s";
          }
        });
      });
    }
  });

  // ../../node_modules/sdp-transform/lib/parser.js
  var require_parser = __commonJS({
    "../../node_modules/sdp-transform/lib/parser.js"(exports) {
      "use strict";
      var toIntIfInt = function(v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function(match, location, names, rawName) {
        if (rawName && !names) {
          location[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i = 0; i < names.length; i += 1) {
            if (match[i + 1] != null) {
              location[names[i]] = toIntIfInt(match[i + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
          location[obj.push] = [];
        } else if (needsBlank && !location[obj.name]) {
          location[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location[obj.name] : location
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location[obj.push].push(keyLocation);
        }
      };
      var grammar = require_grammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp) {
        var session = {}, media = [], location = session;
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
          var type = l[0];
          var content = l.slice(2);
          if (type === "m") {
            media.push({ rtp: [], fmtp: [] });
            location = media[media.length - 1];
          }
          for (var j = 0; j < (grammar[type] || []).length; j += 1) {
            var obj = grammar[type][j];
            if (obj.reg.test(content)) {
              return parseReg(obj, location, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        } else if (s.length === 1 && expr.length > 1) {
          acc[s[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
          candidates.push({
            component: parts[i],
            ip: parts[i + 1],
            port: parts[i + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream) {
          return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/writer.js
  var require_writer = __commonJS({
    "../../node_modules/sdp-transform/lib/writer.js"(exports, module) {
      "use strict";
      var grammar = require_grammar();
      var formatRegExp = /%[sdv%]/g;
      var format = function(formatStr) {
        var i = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function(x) {
          if (i >= len) {
            return x;
          }
          var arg = args[i];
          i += 1;
          switch (x) {
            case "%%":
              return "%";
            case "%s":
              return String(arg);
            case "%d":
              return Number(arg);
            case "%v":
              return "";
          }
        });
      };
      var makeLine = function(type, obj, location) {
        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
        var args = [type + "=" + str];
        if (obj.names) {
          for (var i = 0; i < obj.names.length; i += 1) {
            var n = obj.names[i];
            if (obj.name) {
              args.push(location[obj.name][n]);
            } else {
              args.push(location[obj.names[i]]);
            }
          }
        } else {
          args.push(location[obj.name]);
        }
        return format.apply(null, args);
      };
      var defaultOuterOrder = [
        "v",
        "o",
        "s",
        "i",
        "u",
        "e",
        "p",
        "c",
        "b",
        "t",
        "r",
        "z",
        "a"
      ];
      var defaultInnerOrder = ["i", "c", "b", "a"];
      module.exports = function(session, opts) {
        opts = opts || {};
        if (session.version == null) {
          session.version = 0;
        }
        if (session.name == null) {
          session.name = " ";
        }
        session.media.forEach(function(mLine) {
          if (mLine.payloads == null) {
            mLine.payloads = "";
          }
        });
        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [];
        outerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) {
              sdp.push(makeLine(type, obj, session));
            } else if (obj.push in session && session[obj.push] != null) {
              session[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
        session.media.forEach(function(mLine) {
          sdp.push(makeLine("m", grammar.m[0], mLine));
          innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
              if (obj.name in mLine && mLine[obj.name] != null) {
                sdp.push(makeLine(type, obj, mLine));
              } else if (obj.push in mLine && mLine[obj.push] != null) {
                mLine[obj.push].forEach(function(el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });
        });
        return sdp.join("\r\n") + "\r\n";
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/sdp-transform/lib/index.js"(exports) {
      "use strict";
      var parser = require_parser();
      var writer = require_writer();
      exports.write = writer;
      exports.parse = parser.parse;
      exports.parseParams = parser.parseParams;
      exports.parseFmtpConfig = parser.parseFmtpConfig;
      exports.parsePayloads = parser.parsePayloads;
      exports.parseRemoteCandidates = parser.parseRemoteCandidates;
      exports.parseImageAttributes = parser.parseImageAttributes;
      exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js
  var require_commonUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
      var sdpTransform = __importStar(require_lib3());
      function extractRtpCapabilities({ sdpObject }) {
        const codecsMap = /* @__PURE__ */ new Map();
        const headerExtensions = [];
        let gotAudio = false;
        let gotVideo = false;
        for (const m of sdpObject.media) {
          const kind = m.type;
          switch (kind) {
            case "audio": {
              if (gotAudio) {
                continue;
              }
              gotAudio = true;
              break;
            }
            case "video": {
              if (gotVideo) {
                continue;
              }
              gotVideo = true;
              break;
            }
            default: {
              continue;
            }
          }
          for (const rtp of m.rtp) {
            const codec = {
              kind,
              mimeType: `${kind}/${rtp.codec}`,
              preferredPayloadType: rtp.payload,
              clockRate: rtp.rate,
              channels: rtp.encoding,
              parameters: {},
              rtcpFeedback: []
            };
            codecsMap.set(codec.preferredPayloadType, codec);
          }
          for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
              continue;
            }
            if (parameters && parameters.hasOwnProperty("profile-level-id")) {
              parameters["profile-level-id"] = String(parameters["profile-level-id"]);
            }
            codec.parameters = parameters;
          }
          for (const fb of m.rtcpFb || []) {
            const feedback = {
              type: fb.type,
              parameter: fb.subtype
            };
            if (!feedback.parameter) {
              delete feedback.parameter;
            }
            if (fb.payload !== "*") {
              const codec = codecsMap.get(fb.payload);
              if (!codec) {
                continue;
              }
              codec.rtcpFeedback.push(feedback);
            } else {
              for (const codec of codecsMap.values()) {
                if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                  codec.rtcpFeedback.push(feedback);
                }
              }
            }
          }
          for (const ext of m.ext || []) {
            if (ext["encrypt-uri"]) {
              continue;
            }
            const headerExtension = {
              kind,
              uri: ext.uri,
              preferredId: ext.value
            };
            headerExtensions.push(headerExtension);
          }
        }
        const rtpCapabilities = {
          codecs: Array.from(codecsMap.values()),
          headerExtensions
        };
        return rtpCapabilities;
      }
      exports.extractRtpCapabilities = extractRtpCapabilities;
      function extractDtlsParameters({ sdpObject }) {
        let setup = sdpObject.setup;
        let fingerprint = sdpObject.fingerprint;
        if (!setup || !fingerprint) {
          const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);
          if (mediaObject) {
            setup ?? (setup = mediaObject.setup);
            fingerprint ?? (fingerprint = mediaObject.fingerprint);
          }
        }
        if (!setup) {
          throw new Error("no a=setup found at SDP session or media level");
        } else if (!fingerprint) {
          throw new Error("no a=fingerprint found at SDP session or media level");
        }
        let role;
        switch (setup) {
          case "active": {
            role = "client";
            break;
          }
          case "passive": {
            role = "server";
            break;
          }
          case "actpass": {
            role = "auto";
            break;
          }
        }
        const dtlsParameters = {
          role,
          fingerprints: [
            {
              algorithm: fingerprint.type,
              value: fingerprint.hash
            }
          ]
        };
        return dtlsParameters;
      }
      exports.extractDtlsParameters = extractDtlsParameters;
      function getCname({ offerMediaObject }) {
        const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          return "";
        }
        return ssrcCnameLine.value;
      }
      exports.getCname = getCname;
      function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
        for (const codec of offerRtpParameters.codecs) {
          const mimeType = codec.mimeType.toLowerCase();
          if (mimeType !== "audio/opus") {
            continue;
          }
          const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);
          if (!rtp) {
            continue;
          }
          answerMediaObject.fmtp = answerMediaObject.fmtp || [];
          let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
          if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: "" };
            answerMediaObject.fmtp.push(fmtp);
          }
          const parameters = sdpTransform.parseParams(fmtp.config);
          switch (mimeType) {
            case "audio/opus": {
              const spropStereo = codec.parameters["sprop-stereo"];
              if (spropStereo !== void 0) {
                parameters.stereo = spropStereo ? 1 : 0;
              }
              break;
            }
          }
          fmtp.config = "";
          for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
              fmtp.config += ";";
            }
            fmtp.config += `${key}=${parameters[key]}`;
          }
        }
      }
      exports.applyCodecParameters = applyCodecParameters;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js
  var require_unifiedPlanUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
      function getRtpEncodings({ offerMediaObject }) {
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          const ssrc = line.id;
          ssrcs.add(ssrc);
        }
        if (ssrcs.size === 0) {
          throw new Error("no a=ssrc lines found");
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      exports.getRtpEncodings = getRtpEncodings;
      function addLegacySimulcast({ offerMediaObject, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "msid");
        if (!ssrcMsidLine) {
          throw new Error("a=ssrc line with msid information not found");
        }
        const [streamId, trackId] = ssrcMsidLine.value.split(" ");
        const firstSsrc = ssrcMsidLine.id;
        let firstRtxSsrc;
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          throw new Error("a=ssrc line with cname information not found");
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = [];
        offerMediaObject.ssrcs = [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
      exports.addLegacySimulcast = addLegacySimulcast;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addNackSuppportForOpus = void 0;
      function addNackSuppportForOpus(rtpCapabilities) {
        for (const codec of rtpCapabilities.codecs || []) {
          if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !codec.rtcpFeedback?.some((fb) => fb.type === "nack" && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
              codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: "nack" });
          }
        }
      }
      exports.addNackSuppportForOpus = addNackSuppportForOpus;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js
  var require_HandlerInterface = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HandlerInterface = void 0;
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var HandlerInterface = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor() {
          super();
        }
      };
      exports.HandlerInterface = HandlerInterface;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js
  var require_MediaSection = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
      var sdpTransform = __importStar(require_lib3());
      var utils = __importStar(require_utils());
      var MediaSection = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {
          this._mediaObject = {};
          this._planB = planB;
          if (iceParameters) {
            this.setIceParameters(iceParameters);
          }
          if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
              const candidateObject = {};
              candidateObject.component = 1;
              candidateObject.foundation = candidate.foundation;
              candidateObject.ip = candidate.ip;
              candidateObject.port = candidate.port;
              candidateObject.priority = candidate.priority;
              candidateObject.transport = candidate.protocol;
              candidateObject.type = candidate.type;
              if (candidate.tcpType) {
                candidateObject.tcptype = candidate.tcpType;
              }
              this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = "end-of-candidates";
            this._mediaObject.iceOptions = "renomination";
          }
          if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
          }
        }
        get mid() {
          return String(this._mediaObject.mid);
        }
        get closed() {
          return this._mediaObject.port === 0;
        }
        getObject() {
          return this._mediaObject;
        }
        setIceParameters(iceParameters) {
          this._mediaObject.iceUfrag = iceParameters.usernameFragment;
          this._mediaObject.icePwd = iceParameters.password;
        }
        pause() {
          this._mediaObject.direction = "inactive";
        }
        disable() {
          this.pause();
          delete this._mediaObject.ext;
          delete this._mediaObject.ssrcs;
          delete this._mediaObject.ssrcGroups;
          delete this._mediaObject.simulcast;
          delete this._mediaObject.simulcast_03;
          delete this._mediaObject.rids;
          delete this._mediaObject.extmapAllowMixed;
        }
        close() {
          this.disable();
          this._mediaObject.port = 0;
        }
      };
      exports.MediaSection = MediaSection;
      var AnswerMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(offerMediaObject.mid);
          this._mediaObject.type = offerMediaObject.type;
          this._mediaObject.protocol = offerMediaObject.protocol;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (offerMediaObject.type) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "recvonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              for (const codec of answerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const codecParameters = utils.clone(codec.parameters) ?? {};
                let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                if (codecOptions) {
                  const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                  const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                  switch (codec.mimeType.toLowerCase()) {
                    case "audio/opus":
                    case "audio/multiopus": {
                      if (opusStereo !== void 0) {
                        offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                        codecParameters.stereo = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== void 0) {
                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                        codecParameters.useinbandfec = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== void 0) {
                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                        codecParameters.usedtx = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== void 0) {
                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== void 0) {
                        codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== void 0) {
                        offerCodec.parameters.ptime = opusPtime;
                        codecParameters.ptime = opusPtime;
                      }
                      if (!opusNack) {
                        offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                        codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                      }
                      break;
                    }
                    case "video/vp8":
                    case "video/vp9":
                    case "video/h264":
                    case "video/h265": {
                      if (videoGoogleStartBitrate !== void 0) {
                        codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                      }
                      if (videoGoogleMaxBitrate !== void 0) {
                        codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                      }
                      if (videoGoogleMinBitrate !== void 0) {
                        codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                      }
                      break;
                    }
                  }
                }
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codecParameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codecParameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codecRtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of answerRtpParameters.headerExtensions) {
                const found = (offerMediaObject.ext || []).some((localExt) => localExt.uri === ext.uri);
                if (!found) {
                  continue;
                }
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
                this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
              }
              if (offerMediaObject.simulcast) {
                this._mediaObject.simulcast = {
                  dir1: "recv",
                  list1: offerMediaObject.simulcast.list1
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids || []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              } else if (offerMediaObject.simulcast_03) {
                this._mediaObject.simulcast_03 = {
                  value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids || []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              if (this._planB && this._mediaObject.type === "video") {
                this._mediaObject.xGoogleFlag = "conference";
              }
              break;
            }
            case "application": {
              if (typeof offerMediaObject.sctpPort === "number") {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else if (offerMediaObject.sctpmap) {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        setDtlsRole(role) {
          switch (role) {
            case "client": {
              this._mediaObject.setup = "active";
              break;
            }
            case "server": {
              this._mediaObject.setup = "passive";
              break;
            }
            case "auto": {
              this._mediaObject.setup = "actpass";
              break;
            }
          }
        }
        resume() {
          this._mediaObject.direction = "recvonly";
        }
        muxSimulcastStreams(encodings) {
          if (!this._mediaObject.simulcast || !this._mediaObject.simulcast.list1) {
            return;
          }
          const layers = {};
          for (const encoding of encodings) {
            if (encoding.rid) {
              layers[encoding.rid] = encoding;
            }
          }
          const raw = this._mediaObject.simulcast.list1;
          const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
          for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
              simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
          }
          this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f) => `${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
        }
      };
      exports.AnswerMediaSection = AnswerMediaSection;
      var OfferMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(mid);
          this._mediaObject.type = kind;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            if (!sctpParameters) {
              this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
            } else {
              this._mediaObject.protocol = "UDP/DTLS/SCTP";
            }
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.protocol = "RTP/AVP";
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (kind) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "sendonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              if (!this._planB) {
                this._mediaObject.msid = `${streamId || "-"} ${trackId}`;
              }
              for (const codec of offerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codec.parameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codec.parameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codec.rtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of offerRtpParameters.headerExtensions) {
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              const encoding = offerRtpParameters.encodings[0];
              const ssrc = encoding.ssrc;
              const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
              this._mediaObject.ssrcs = [];
              this._mediaObject.ssrcGroups = [];
              if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "cname",
                  value: offerRtpParameters.rtcp.cname
                });
              }
              if (this._planB) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "msid",
                  value: `${streamId || "-"} ${trackId}`
                });
              }
              if (rtxSsrc) {
                if (offerRtpParameters.rtcp.cname) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "cname",
                    value: offerRtpParameters.rtcp.cname
                  });
                }
                if (this._planB) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "msid",
                    value: `${streamId || "-"} ${trackId}`
                  });
                }
                this._mediaObject.ssrcGroups.push({
                  semantics: "FID",
                  ssrcs: `${ssrc} ${rtxSsrc}`
                });
              }
              break;
            }
            case "application": {
              if (!oldDataChannelSpec) {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        setDtlsRole(role) {
          this._mediaObject.setup = "actpass";
        }
        resume() {
          this._mediaObject.direction = "sendonly";
        }
        planBReceive({ offerRtpParameters, streamId, trackId }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
          const payloads = this._mediaObject.payloads.split(" ");
          for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
              continue;
            }
            const rtp = {
              payload: codec.payloadType,
              codec: getCodecName(codec),
              rate: codec.clockRate
            };
            if (codec.channels > 1) {
              rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
              payload: codec.payloadType,
              config: ""
            };
            for (const key of Object.keys(codec.parameters)) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
              this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          }
          this._mediaObject.payloads += ` ${offerRtpParameters.codecs.filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType)).map((codec) => codec.payloadType).join(" ")}`;
          this._mediaObject.payloads = this._mediaObject.payloads.trim();
          if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: offerRtpParameters.rtcp.cname
            });
          }
          this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId || "-"} ${trackId}`
          });
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
              });
            }
            this._mediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "msid",
              value: `${streamId || "-"} ${trackId}`
            });
            this._mediaObject.ssrcGroups.push({
              semantics: "FID",
              ssrcs: `${ssrc} ${rtxSsrc}`
            });
          }
        }
        planBStopReceiving({ offerRtpParameters }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
          this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
          if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
          }
        }
      };
      exports.OfferMediaSection = OfferMediaSection;
      function getCodecName(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        return mimeTypeMatch[2];
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js
  var require_RemoteSdp = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RemoteSdp = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var MediaSection_1 = require_MediaSection();
      var logger12 = new Logger_1.Logger("RemoteSdp");
      var RemoteSdp = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {
          this._mediaSections = [];
          this._midToIndex = /* @__PURE__ */ new Map();
          this._iceParameters = iceParameters;
          this._iceCandidates = iceCandidates;
          this._dtlsParameters = dtlsParameters;
          this._sctpParameters = sctpParameters;
          this._plainRtpParameters = plainRtpParameters;
          this._planB = planB;
          this._sdpObject = {
            version: 0,
            origin: {
              address: "0.0.0.0",
              ipVer: 4,
              netType: "IN",
              sessionId: 1e4,
              sessionVersion: 0,
              username: "mediasoup-client"
            },
            name: "-",
            timing: { start: 0, stop: 0 },
            media: []
          };
          if (iceParameters && iceParameters.iceLite) {
            this._sdpObject.icelite = "ice-lite";
          }
          if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
              type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
              hash: dtlsParameters.fingerprints[numFingerprints - 1].value
            };
            this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
          }
          if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
          }
        }
        updateIceParameters(iceParameters) {
          logger12.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
          this._iceParameters = iceParameters;
          this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
          }
        }
        updateDtlsRole(role) {
          logger12.debug("updateDtlsRole() [role:%s]", role);
          this._dtlsParameters.role = role;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
          }
        }
        getNextMediaSectionIdx() {
          for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
              return { idx, reuseMid: mediaSection.mid };
            }
          }
          return { idx: this._mediaSections.length };
        }
        send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed
          });
          if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
          } else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
          } else {
            this._replaceMediaSection(mediaSection);
          }
        }
        receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
          const idx = this._midToIndex.get(mid);
          let mediaSection;
          if (idx !== void 0) {
            mediaSection = this._mediaSections[idx];
          }
          if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              plainRtpParameters: this._plainRtpParameters,
              planB: this._planB,
              mid,
              kind,
              offerRtpParameters,
              streamId,
              trackId
            });
            const oldMediaSection = this._mediaSections.find((m) => m.closed);
            if (oldMediaSection) {
              this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            } else {
              this._addMediaSection(mediaSection);
            }
          } else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
          }
        }
        pauseMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.pause();
        }
        resumeSendingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        resumeReceivingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        disableMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.disable();
        }
        /**
         * Closes media section. Returns true if the given MID corresponds to a m
         * section that has been indeed closed. False otherwise.
         *
         * NOTE: Closing the first m section is a pain since it invalidates the bundled
         * transport, so instead closing it we just disable it.
         */
        closeMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          if (mid === this._firstMid) {
            logger12.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
            this.disableMediaSection(mid);
            return false;
          }
          mediaSection.close();
          this._regenerateBundleMids();
          return true;
        }
        muxMediaSectionSimulcast(mid, encodings) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.muxSimulcastStreams(encodings);
          this._replaceMediaSection(mediaSection);
        }
        planBStopReceiving({ mid, offerRtpParameters }) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.planBStopReceiving({ offerRtpParameters });
          this._replaceMediaSection(mediaSection);
        }
        sendSctpAssociation({ offerMediaObject }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject
          });
          this._addMediaSection(mediaSection);
        }
        receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
          const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: "datachannel",
            kind: "application",
            oldDataChannelSpec
          });
          this._addMediaSection(mediaSection);
        }
        getSdp() {
          this._sdpObject.origin.sessionVersion++;
          return sdpTransform.write(this._sdpObject);
        }
        _addMediaSection(newMediaSection) {
          if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
          }
          this._mediaSections.push(newMediaSection);
          this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
          this._sdpObject.media.push(newMediaSection.getObject());
          this._regenerateBundleMids();
        }
        _replaceMediaSection(newMediaSection, reuseMid) {
          if (typeof reuseMid === "string") {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === void 0) {
              throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            this._mediaSections[idx] = newMediaSection;
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            this._sdpObject.media[idx] = newMediaSection.getObject();
            this._regenerateBundleMids();
          } else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === void 0) {
              throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            this._mediaSections[idx] = newMediaSection;
            this._sdpObject.media[idx] = newMediaSection.getObject();
          }
        }
        _findMediaSection(mid) {
          const idx = this._midToIndex.get(mid);
          if (idx === void 0) {
            throw new Error(`no media section found with mid '${mid}'`);
          }
          return this._mediaSections[idx];
        }
        _regenerateBundleMids() {
          if (!this._dtlsParameters) {
            return;
          }
          this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
        }
      };
      exports.RemoteSdp = RemoteSdp;
    }
  });

  // ../../node_modules/mediasoup-client/lib/scalabilityModes.js
  var require_scalabilityModes = __commonJS({
    "../../node_modules/mediasoup-client/lib/scalabilityModes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = void 0;
      var ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
      function parse(scalabilityMode) {
        const match = ScalabilityModeRegex.exec(scalabilityMode || "");
        if (match) {
          return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2])
          };
        } else {
          return {
            spatialLayers: 1,
            temporalLayers: 1
          };
        }
      }
      exports.parse = parse;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome111.js
  var require_Chrome111 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome111.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome111 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome111");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome111 = class _Chrome111 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome111();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome111";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
            let nextRid = 1;
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
              const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
              if (temporalLayers > maxTemporalLayers) {
                maxTemporalLayers = temporalLayers;
              }
            }
            for (const encoding of encodings) {
              encoding.rid = `r${nextRid++}`;
              encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            }
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome111 = Chrome111;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome74.js
  var require_Chrome74 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome74.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome74 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome74");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome74 = class _Chrome74 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome74();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome74";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome74 = Chrome74;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome70.js
  var require_Chrome70 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome70.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome70 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome70");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome70 = class _Chrome70 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome70();
        }
        constructor() {
          super();
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome70";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (encodings && encodings.length > 1) {
            logger12.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          if (encodings) {
            logger12.debug("send() | applying given encodings");
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {
              const encoding = parameters.encodings[idx];
              const desiredEncoding = encodings[idx];
              if (!desiredEncoding) {
                break;
              }
              parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
          }
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome70 = Chrome70;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js
  var require_planBUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
      function getRtpEncodings({ offerMediaObject, track }) {
        let firstSsrc;
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          if (line.attribute !== "msid") {
            continue;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc) {
              firstSsrc = ssrc;
            }
          }
        }
        if (ssrcs.size === 0) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      exports.getRtpEncodings = getRtpEncodings;
      function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        let firstSsrc;
        let firstRtxSsrc;
        let streamId;
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
          if (line.attribute !== "msid") {
            return false;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(" ")[0];
            return true;
          } else {
            return false;
          }
        });
        if (!ssrcMsidLine) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname" && line.id === firstSsrc);
        if (!ssrcCnameLine) {
          throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
        offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
      exports.addLegacySimulcast = addLegacySimulcast;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome67.js
  var require_Chrome67 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome67.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome67 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Chrome67");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome67 = class _Chrome67 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome67();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome67";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          this._pc.removeTrack(rtpSender);
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome67 = Chrome67;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome55.js
  var require_Chrome55 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome55.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome55 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Chrome55");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome55 = class _Chrome55 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome55();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome55";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError(" not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not supported");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId || rtpParameters.rtcp.cname;
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome55 = Chrome55;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Firefox60.js
  var require_Firefox60 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Firefox60.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Firefox60 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Firefox60");
      var SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
      var Firefox60 = class _Firefox60 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Firefox60();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Firefox60";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          const canvas = document.createElement("canvas");
          canvas.getContext("2d");
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
            pc.addTransceiver("audio", { direction: "sendrecv" });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
              direction: "sendrecv"
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
              { rid: "r0", maxBitrate: 1e5 },
              { rid: "r1", maxBitrate: 5e5 }
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
              canvas.remove();
            } catch (error) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error) {
            }
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              canvas.remove();
            } catch (error2) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error2) {
            }
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings) {
            encodings = utils.clone(encodings);
            if (encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
              });
              encodings.reverse();
            }
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings.reverse();
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.disableMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          spatialLayer = parameters.encodings.length - 1 - spatialLayer;
          parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
            answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Firefox60 = Firefox60;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari12.js
  var require_Safari12 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari12.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari12 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Safari12");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari12 = class _Safari12 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari12();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Safari12";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length > 1) {
            logger12.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari12 = Safari12;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari11.js
  var require_Safari11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari11.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari11 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Safari11");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari11 = class _Safari11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari11();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Safari11";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari11 = Safari11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js
  var require_edgeUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mangleRtpParameters = exports.getCapabilities = void 0;
      var utils = __importStar(require_utils());
      function getCapabilities() {
        const nativeCaps = RTCRtpReceiver.getCapabilities();
        const caps = utils.clone(nativeCaps);
        for (const codec of caps.codecs ?? []) {
          codec.channels = codec.numChannels;
          delete codec.numChannels;
          codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
          if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) {
              parameters.apt = Number(parameters.apt);
            }
            if (parameters["packetization-mode"]) {
              parameters["packetization-mode"] = Number(parameters["packetization-mode"]);
            }
          }
          for (const feedback of codec.rtcpFeedback || []) {
            if (!feedback.parameter) {
              feedback.parameter = "";
            }
          }
        }
        return caps;
      }
      exports.getCapabilities = getCapabilities;
      function mangleRtpParameters(rtpParameters) {
        const params = utils.clone(rtpParameters);
        if (params.mid) {
          params.muxId = params.mid;
          delete params.mid;
        }
        for (const codec of params.codecs) {
          if (codec.channels) {
            codec.numChannels = codec.channels;
            delete codec.channels;
          }
          if (codec.mimeType && !codec.name) {
            codec.name = codec.mimeType.split("/")[1];
          }
          delete codec.mimeType;
        }
        return params;
      }
      exports.mangleRtpParameters = mangleRtpParameters;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Edge11.js
  var require_Edge11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Edge11.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Edge11 = void 0;
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var edgeUtils = __importStar(require_edgeUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var logger12 = new Logger_1.Logger("Edge11");
      var Edge11 = class _Edge11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Edge11();
        }
        constructor() {
          super();
          this._rtpSenders = /* @__PURE__ */ new Map();
          this._rtpReceivers = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Edge11";
        }
        close() {
          logger12.debug("close()");
          try {
            this._iceGatherer.close();
          } catch (error) {
          }
          try {
            this._iceTransport.stop();
          } catch (error) {
          }
          try {
            this._dtlsTransport.stop();
          } catch (error) {
          }
          for (const rtpSender of this._rtpSenders.values()) {
            try {
              rtpSender.stop();
            } catch (error) {
            }
          }
          for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
              rtpReceiver.stop();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          return edgeUtils.getCapabilities();
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: { OS: 0, MIS: 0 }
          };
        }
        run({
          direction,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          proprietaryConstraints,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          extendedRtpCapabilities
        }) {
          logger12.debug("run()");
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._remoteIceParameters = iceParameters;
          this._remoteIceCandidates = iceCandidates;
          this._remoteDtlsParameters = dtlsParameters;
          this._cname = `CNAME-${utils.generateRandomNumber()}`;
          this.setIceGatherer({ iceServers, iceTransportPolicy });
          this.setIceTransport();
          this.setDtlsTransport();
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteIceParameters = iceParameters;
          if (!this._transportReady) {
            return;
          }
          logger12.debug("restartIce() | calling iceTransport.start()");
          this._iceTransport.start(this._iceGatherer, iceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
        }
        async getTransportStats() {
          return this._iceTransport.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          logger12.debug("send() | calling new RTCRtpSender()");
          const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
          const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
          const useRtx = rtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
          if (!encodings) {
            encodings = [{}];
          }
          for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
              encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
          }
          rtpParameters.encodings = encodings;
          rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true
          };
          const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
          logger12.debug("send() | calling rtpSender.send() [params:%o]", edgeRtpParameters);
          await rtpSender.send(edgeRtpParameters);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._rtpSenders.set(localId, rtpSender);
          return { localId, rtpParameters, rtpSender };
        }
        async stopSending(localId) {
          logger12.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          this._rtpSenders.delete(localId);
          try {
            logger12.debug("stopSending() | calling rtpSender.stop()");
            rtpSender.stop();
          } catch (error) {
            logger12.warn("stopSending() | rtpSender.stop() failed:%o", error);
            throw error;
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          rtpSender.setTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receive(optionsList) {
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger12.debug("receive() | calling new RTCRtpReceiver()");
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener("error", (event) => {
              logger12.error('rtpReceiver "error" event [event:%o]', event);
            });
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger12.debug("receive() | calling rtpReceiver.receive() [params:%o]", edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
              throw new Error("RTCRtpReceiver not found");
            }
            this._rtpReceivers.delete(localId);
            try {
              logger12.debug("stopReceiving() | calling rtpReceiver.stop()");
              rtpReceiver.stop();
            } catch (error) {
              logger12.warn("stopReceiving() | rtpReceiver.stop() failed:%o", error);
            }
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          const rtpReceiver = this._rtpReceivers.get(localId);
          if (!rtpReceiver) {
            throw new Error("RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        setIceGatherer({ iceServers, iceTransportPolicy }) {
          const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers || [],
            gatherPolicy: iceTransportPolicy || "all"
          });
          iceGatherer.addEventListener("error", (event) => {
            logger12.error('iceGatherer "error" event [event:%o]', event);
          });
          try {
            iceGatherer.gather();
          } catch (error) {
            logger12.debug("setIceGatherer() | iceGatherer.gather() failed: %s", error.toString());
          }
          this._iceGatherer = iceGatherer;
        }
        setIceTransport() {
          const iceTransport = new RTCIceTransport(this._iceGatherer);
          iceTransport.addEventListener("statechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("icestatechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("candidatepairchange", (event) => {
            logger12.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
          });
          this._iceTransport = iceTransport;
        }
        setDtlsTransport() {
          const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
          dtlsTransport.addEventListener("statechange", () => {
            logger12.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
          });
          dtlsTransport.addEventListener("dtlsstatechange", () => {
            logger12.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === "closed") {
              this.emit("@connectionstatechange", "closed");
            }
          });
          dtlsTransport.addEventListener("error", (event) => {
            logger12.error('dtlsTransport "error" event [event:%o]', event);
          });
          this._dtlsTransport = dtlsTransport;
        }
        async setupTransport({ localDtlsRole }) {
          logger12.debug("setupTransport()");
          const dtlsParameters = this._dtlsTransport.getLocalParameters();
          dtlsParameters.role = localDtlsRole;
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
          this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
            return fingerprint.algorithm === "sha-256" || fingerprint.algorithm === "sha-384" || fingerprint.algorithm === "sha-512";
          });
          this._dtlsTransport.start(this._remoteDtlsParameters);
          this._transportReady = true;
        }
      };
      exports.Edge11 = Edge11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js
  var require_ReactNativeUnifiedPlan = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNativeUnifiedPlan = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("ReactNativeUnifiedPlan");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNativeUnifiedPlan = class _ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNativeUnifiedPlan();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "ReactNativeUnifiedPlan";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          let localId = transceiver.mid ?? void 0;
          if (!localId) {
            logger12.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
          }
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
          }
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNative.js
  var require_ReactNative = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNative.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNative = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("ReactNative");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNative = class _ReactNative extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNative();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "ReactNative";
        }
        close() {
          logger12.debug("close()");
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapStreamId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            let streamId = options.streamId || rtpParameters.rtcp.cname;
            logger12.debug("receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc");
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNative = ReactNative;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Device.js
  var require_Device = __commonJS({
    "../../node_modules/mediasoup-client/lib/Device.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Device = exports.detectDevice = void 0;
      var ua_parser_js_1 = require_ua_parser();
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Transport_1 = require_Transport();
      var Chrome111_1 = require_Chrome111();
      var Chrome74_1 = require_Chrome74();
      var Chrome70_1 = require_Chrome70();
      var Chrome67_1 = require_Chrome67();
      var Chrome55_1 = require_Chrome55();
      var Firefox60_1 = require_Firefox60();
      var Safari12_1 = require_Safari12();
      var Safari11_1 = require_Safari11();
      var Edge11_1 = require_Edge11();
      var ReactNativeUnifiedPlan_1 = require_ReactNativeUnifiedPlan();
      var ReactNative_1 = require_ReactNative();
      var logger12 = new Logger_1.Logger("Device");
      function detectDevice2() {
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          logger12.debug("detectDevice() | React-Native detected");
          if (typeof RTCPeerConnection === "undefined") {
            logger12.warn("detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?");
            return void 0;
          }
          if (typeof RTCRtpTransceiver !== "undefined") {
            logger12.debug("detectDevice() | ReactNative UnifiedPlan handler chosen");
            return "ReactNativeUnifiedPlan";
          } else {
            logger12.debug("detectDevice() | ReactNative PlanB handler chosen");
            return "ReactNative";
          }
        } else if (typeof navigator === "object" && typeof navigator.userAgent === "string") {
          const ua = navigator.userAgent;
          const uaParser = new ua_parser_js_1.UAParser(ua);
          logger12.debug("detectDevice() | browser detected [ua:%s, parsed:%o]", ua, uaParser.getResult());
          const browser = uaParser.getBrowser();
          const browserName = browser.name?.toLowerCase();
          const browserVersion = parseInt(browser.major ?? "0");
          const engine = uaParser.getEngine();
          const engineName = engine.name?.toLowerCase();
          const os = uaParser.getOS();
          const osName = os.name?.toLowerCase();
          const osVersion = parseFloat(os.version ?? "0");
          const device = uaParser.getDevice();
          const deviceModel = device.model?.toLowerCase();
          const isIOS = osName === "ios" || deviceModel === "ipad";
          const isChrome = browserName && [
            "chrome",
            "chromium",
            "mobile chrome",
            "chrome webview",
            "chrome headless"
          ].includes(browserName);
          const isFirefox = browserName && ["firefox", "mobile firefox", "mobile focus"].includes(browserName);
          const isSafari = browserName && ["safari", "mobile safari"].includes(browserName);
          const isEdge = browserName && ["edge"].includes(browserName);
          if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return "Chrome111";
          } else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) {
            return "Chrome74";
          } else if (isChrome && !isIOS && browserVersion >= 70) {
            return "Chrome70";
          } else if (isChrome && !isIOS && browserVersion >= 67) {
            return "Chrome67";
          } else if (isChrome && !isIOS && browserVersion >= 55) {
            return "Chrome55";
          } else if (isFirefox && !isIOS && browserVersion >= 60) {
            return "Firefox60";
          } else if (isFirefox && isIOS && osVersion >= 14.3) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 11) {
            return "Safari11";
          } else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
            return "Edge11";
          } else if (engineName === "webkit" && isIOS && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (engineName === "blink") {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
              const version = Number(match[1]);
              if (version >= 111) {
                return "Chrome111";
              } else if (version >= 74) {
                return "Chrome74";
              } else if (version >= 70) {
                return "Chrome70";
              } else if (version >= 67) {
                return "Chrome67";
              } else {
                return "Chrome55";
              }
            } else {
              return "Chrome111";
            }
          } else {
            logger12.warn("detectDevice() | browser not supported [name:%s, version:%s]", browserName, browserVersion);
            return void 0;
          }
        } else {
          logger12.warn("detectDevice() | unknown device");
          return void 0;
        }
      }
      exports.detectDevice = detectDevice2;
      var Device2 = class {
        /**
         * Create a new Device to connect to mediasoup server.
         *
         * @throws {UnsupportedError} if device is not supported.
         */
        constructor({ handlerName, handlerFactory, Handler } = {}) {
          this._loaded = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          if (Handler) {
            logger12.warn("constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead");
            if (typeof Handler === "string") {
              handlerName = Handler;
            } else {
              throw new TypeError("non string Handler option no longer supported, use handlerFactory instead");
            }
          }
          if (handlerName && handlerFactory) {
            throw new TypeError("just one of handlerName or handlerInterface can be given");
          }
          if (handlerFactory) {
            this._handlerFactory = handlerFactory;
          } else {
            if (handlerName) {
              logger12.debug("constructor() | handler given: %s", handlerName);
            } else {
              handlerName = detectDevice2();
              if (handlerName) {
                logger12.debug("constructor() | detected handler: %s", handlerName);
              } else {
                throw new errors_1.UnsupportedError("device not supported");
              }
            }
            switch (handlerName) {
              case "Chrome111": {
                this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                break;
              }
              case "Chrome74": {
                this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                break;
              }
              case "Chrome70": {
                this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                break;
              }
              case "Chrome67": {
                this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                break;
              }
              case "Chrome55": {
                this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                break;
              }
              case "Firefox60": {
                this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                break;
              }
              case "Safari12": {
                this._handlerFactory = Safari12_1.Safari12.createFactory();
                break;
              }
              case "Safari11": {
                this._handlerFactory = Safari11_1.Safari11.createFactory();
                break;
              }
              case "Edge11": {
                this._handlerFactory = Edge11_1.Edge11.createFactory();
                break;
              }
              case "ReactNativeUnifiedPlan": {
                this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                break;
              }
              case "ReactNative": {
                this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                break;
              }
              default: {
                throw new TypeError(`unknown handlerName "${handlerName}"`);
              }
            }
          }
          const handler = this._handlerFactory();
          this._handlerName = handler.name;
          handler.close();
          this._extendedRtpCapabilities = void 0;
          this._recvRtpCapabilities = void 0;
          this._canProduceByKind = {
            audio: false,
            video: false
          };
          this._sctpCapabilities = void 0;
        }
        /**
         * The RTC handler name.
         */
        get handlerName() {
          return this._handlerName;
        }
        /**
         * Whether the Device is loaded.
         */
        get loaded() {
          return this._loaded;
        }
        /**
         * RTP capabilities of the Device for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get rtpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._recvRtpCapabilities;
        }
        /**
         * SCTP capabilities of the Device.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get sctpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._sctpCapabilities;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Initialize the Device.
         */
        async load({ routerRtpCapabilities }) {
          logger12.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
          routerRtpCapabilities = utils.clone(routerRtpCapabilities);
          let handler;
          try {
            if (this._loaded) {
              throw new errors_1.InvalidStateError("already loaded");
            }
            ortc.validateRtpCapabilities(routerRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger12.debug("load() | got native RTP capabilities:%o", nativeRtpCapabilities);
            ortc.validateRtpCapabilities(nativeRtpCapabilities);
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
            logger12.debug("load() | got extended RTP capabilities:%o", this._extendedRtpCapabilities);
            this._canProduceByKind.audio = ortc.canSend("audio", this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend("video", this._extendedRtpCapabilities);
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger12.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger12.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger12.debug("load() succeeded");
            this._loaded = true;
            handler.close();
          } catch (error) {
            if (handler) {
              handler.close();
            }
            throw error;
          }
        }
        /**
         * Whether we can produce audio/video.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        canProduce(kind) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind "${kind}"`);
          }
          return this._canProduceByKind[kind];
        }
        /**
         * Creates a Transport for sending media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger12.debug("createSendTransport()");
          return this.createTransport({
            direction: "send",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        /**
         * Creates a Transport for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger12.debug("createRecvTransport()");
          return this.createTransport({
            direction: "recv",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof iceParameters !== "object") {
            throw new TypeError("missing iceParameters");
          } else if (!Array.isArray(iceCandidates)) {
            throw new TypeError("missing iceCandidates");
          } else if (typeof dtlsParameters !== "object") {
            throw new TypeError("missing dtlsParameters");
          } else if (sctpParameters && typeof sctpParameters !== "object") {
            throw new TypeError("wrong sctpParameters");
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind
          });
          this._observer.safeEmit("newtransport", transport);
          return transport;
        }
      };
      exports.Device = Device2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/RtpParameters.js
  var require_RtpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/RtpParameters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/SctpParameters.js
  var require_SctpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/SctpParameters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/types.js
  var require_types = __commonJS({
    "../../node_modules/mediasoup-client/lib/types.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_Device(), exports);
      __exportStar(require_Transport(), exports);
      __exportStar(require_Producer(), exports);
      __exportStar(require_Consumer(), exports);
      __exportStar(require_DataProducer(), exports);
      __exportStar(require_DataConsumer(), exports);
      __exportStar(require_RtpParameters(), exports);
      __exportStar(require_SctpParameters(), exports);
      __exportStar(require_HandlerInterface(), exports);
      __exportStar(require_errors(), exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/mediasoup-client/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
      var debug_1 = __importDefault(require_browser());
      exports.debug = debug_1.default;
      var Device_1 = require_Device();
      Object.defineProperty(exports, "Device", { enumerable: true, get: function() {
        return Device_1.Device;
      } });
      Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function() {
        return Device_1.detectDevice;
      } });
      var types = __importStar(require_types());
      exports.types = types;
      exports.version = "3.7.2";
      var scalabilityModes_1 = require_scalabilityModes();
      Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function() {
        return scalabilityModes_1.parse;
      } });
    }
  });

  // ../types/dist/socket.types.js
  var require_socket_types = __commonJS({
    "../types/dist/socket.types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocketCloseReason = exports.ESocketCloseCode = void 0;
      var ESocketCloseCode3;
      (function(ESocketCloseCode4) {
        ESocketCloseCode4[ESocketCloseCode4["ABNORMAL_CLOSURE"] = 1006] = "ABNORMAL_CLOSURE";
        ESocketCloseCode4[ESocketCloseCode4["NORMAL_CLOSURE"] = 1e3] = "NORMAL_CLOSURE";
        ESocketCloseCode4[ESocketCloseCode4["BROWSER_TAB_CLOSE"] = 1001] = "BROWSER_TAB_CLOSE";
        ESocketCloseCode4[ESocketCloseCode4["GOING_AWAY"] = 4001] = "GOING_AWAY";
        ESocketCloseCode4[ESocketCloseCode4["CONNECTION_EXPIRED"] = 4002] = "CONNECTION_EXPIRED";
        ESocketCloseCode4[ESocketCloseCode4["CONNECTION_ERROR"] = 4006] = "CONNECTION_ERROR";
        ESocketCloseCode4[ESocketCloseCode4["ROOM_CLOSED"] = 4007] = "ROOM_CLOSED";
        ESocketCloseCode4[ESocketCloseCode4["ROOM_ENTRY_DENIED"] = 4008] = "ROOM_ENTRY_DENIED";
        ESocketCloseCode4[ESocketCloseCode4["KICKED"] = 4009] = "KICKED";
      })(ESocketCloseCode3 || (exports.ESocketCloseCode = ESocketCloseCode3 = {}));
      exports.SocketCloseReason = {
        [ESocketCloseCode3.ROOM_CLOSED]: "ROOM_CLOSED",
        [ESocketCloseCode3.ABNORMAL_CLOSURE]: "ABNORMAL_CLOSURE",
        [ESocketCloseCode3.NORMAL_CLOSURE]: "NORMAL_CLOSURE",
        [ESocketCloseCode3.BROWSER_TAB_CLOSE]: "BROWSER_TAB_CLOSE",
        [ESocketCloseCode3.GOING_AWAY]: "GOING_AWAY",
        [ESocketCloseCode3.CONNECTION_ERROR]: "CONNECTION_ERROR",
        [ESocketCloseCode3.CONNECTION_EXPIRED]: "CONNECTION_EXPIRED",
        [ESocketCloseCode3.ROOM_ENTRY_DENIED]: "ROOM_ENTRY_DENIED",
        [ESocketCloseCode3.KICKED]: "KICKED"
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  var FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN;
  var init_assert = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/assert.js"() {
      "use strict";
      FLOAT32_MAX = 34028234663852886e22;
      FLOAT32_MIN = -34028234663852886e22;
      UINT32_MAX = 4294967295;
      INT32_MAX = 2147483647;
      INT32_MIN = -2147483648;
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
      no: v.no,
      name: v.name,
      localName: enumObject[v.no]
    })), opt);
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values, opt);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }
  var enumTypeSymbol;
  var init_enum = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/enum.js"() {
      "use strict";
      init_assert();
      enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/message.js
  var Message;
  var init_message = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/message.js"() {
      "use strict";
      Message = class {
        /**
         * Compare with a message of the same type.
         */
        equals(other) {
          return this.getType().runtime.util.equals(this.getType(), this, other);
        }
        /**
         * Create a deep copy.
         */
        clone() {
          return this.getType().runtime.util.clone(this);
        }
        /**
         * Parse from binary data, merging fields.
         *
         * Repeated fields are appended. Map entries are added, overwriting
         * existing keys.
         *
         * If a message field is already present, it will be merged with the
         * new data.
         */
        fromBinary(bytes, options) {
          const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
          format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
          return this;
        }
        /**
         * Parse a message from a JSON value.
         */
        fromJson(jsonValue, options) {
          const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
          format.readMessage(type, jsonValue, opt, this);
          return this;
        }
        /**
         * Parse a message from a JSON string.
         */
        fromJsonString(jsonString, options) {
          let json;
          try {
            json = JSON.parse(jsonString);
          } catch (e) {
            throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
          }
          return this.fromJson(json, options);
        }
        /**
         * Serialize the message to binary data.
         */
        toBinary(options) {
          const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
          bin.writeMessage(this, writer, opt);
          return writer.finish();
        }
        /**
         * Serialize the message to a JSON value, a JavaScript value that can be
         * passed to JSON.stringify().
         */
        toJson(options) {
          const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
          return json.writeMessage(this, opt);
        }
        /**
         * Serialize the message to a JSON string.
         */
        toJsonString(options) {
          var _a;
          const value = this.toJson(options);
          return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
        }
        /**
         * Override for serialization behavior. This will be invoked when calling
         * JSON.stringify on this message (i.e. JSON.stringify(msg)).
         *
         * Note that this will not serialize google.protobuf.Any with a packed
         * message because the protobuf JSON format specifies that it needs to be
         * unpacked, and this is only possible with a type registry to look up the
         * message type.  As a result, attempting to serialize a message with this
         * type will throw an Error.
         *
         * This method is protected because you should not need to invoke it
         * directly -- instead use JSON.stringify or toJsonString for
         * stringified JSON.  Alternatively, if actual JSON is desired, you should
         * use toJson.
         */
        toJSON() {
          return this.toJson({
            emitDefaultValues: true
          });
        }
        /**
         * Retrieve the MessageType of this message - a singleton that represents
         * the protobuf message declaration and provides metadata for reflection-
         * based operations.
         */
        getType() {
          return Object.getPrototypeOf(this).constructor;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName2 = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName2]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName2];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b) {
        return runtime.util.equals(type, a, b);
      }
    });
    return type;
  }
  var init_message_type = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js"() {
      "use strict";
      init_message();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
  function makeProtoRuntime(syntax, json, bin, util2) {
    return {
      syntax,
      json,
      bin,
      util: util2,
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType
    };
  }
  var init_proto_runtime = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js"() {
      "use strict";
      init_enum();
      init_message_type();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/field.js
  var ScalarType;
  var init_field = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/field.js"() {
      "use strict";
      (function(ScalarType2) {
        ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
        ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
        ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
        ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
        ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
        ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
        ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
        ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
        ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
        ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
        ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
        ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
        ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
        ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
        ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
      })(ScalarType || (ScalarType = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
  }
  function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  var TWO_PWR_32_DBL, decimalFrom1e7WithLeadingZeros;
  var init_varint = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/varint.js"() {
      "use strict";
      TWO_PWR_32_DBL = 4294967296;
      decimalFrom1e7WithLeadingZeros = (digit1e7) => {
        const partial = String(digit1e7);
        return "0000000".slice(partial.length) + partial;
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  var protoInt64;
  var init_proto_int64 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js"() {
      "use strict";
      init_assert();
      init_varint();
      protoInt64 = makeInt64Support();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
  var WireType, BinaryWriter, BinaryReader;
  var init_binary_encoding = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js"() {
      "use strict";
      init_varint();
      init_assert();
      init_proto_int64();
      (function(WireType2) {
        WireType2[WireType2["Varint"] = 0] = "Varint";
        WireType2[WireType2["Bit64"] = 1] = "Bit64";
        WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
        WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
        WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
        WireType2[WireType2["Bit32"] = 5] = "Bit32";
      })(WireType || (WireType = {}));
      BinaryWriter = class {
        constructor(textEncoder) {
          this.stack = [];
          this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
          this.chunks = [];
          this.buf = [];
        }
        /**
         * Return all bytes written and reset this writer.
         */
        finish() {
          this.chunks.push(new Uint8Array(this.buf));
          let len = 0;
          for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
          let bytes = new Uint8Array(len);
          let offset = 0;
          for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
          }
          this.chunks = [];
          return bytes;
        }
        /**
         * Start a new fork for length-delimited data like a message
         * or a packed repeated field.
         *
         * Must be joined later with `join()`.
         */
        fork() {
          this.stack.push({ chunks: this.chunks, buf: this.buf });
          this.chunks = [];
          this.buf = [];
          return this;
        }
        /**
         * Join the last fork. Write its length and bytes, then
         * return to the previous state.
         */
        join() {
          let chunk = this.finish();
          let prev = this.stack.pop();
          if (!prev)
            throw new Error("invalid state, fork stack empty");
          this.chunks = prev.chunks;
          this.buf = prev.buf;
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
        }
        /**
         * Writes a tag (field number and wire type).
         *
         * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
         *
         * Generated code should compute the tag ahead of time and call `uint32()`.
         */
        tag(fieldNo, type) {
          return this.uint32((fieldNo << 3 | type) >>> 0);
        }
        /**
         * Write a chunk of raw bytes.
         */
        raw(chunk) {
          if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
          }
          this.chunks.push(chunk);
          return this;
        }
        /**
         * Write a `uint32` value, an unsigned 32 bit varint.
         */
        uint32(value) {
          assertUInt32(value);
          while (value > 127) {
            this.buf.push(value & 127 | 128);
            value = value >>> 7;
          }
          this.buf.push(value);
          return this;
        }
        /**
         * Write a `int32` value, a signed 32 bit varint.
         */
        int32(value) {
          assertInt32(value);
          varint32write(value, this.buf);
          return this;
        }
        /**
         * Write a `bool` value, a variant.
         */
        bool(value) {
          this.buf.push(value ? 1 : 0);
          return this;
        }
        /**
         * Write a `bytes` value, length-delimited arbitrary data.
         */
        bytes(value) {
          this.uint32(value.byteLength);
          return this.raw(value);
        }
        /**
         * Write a `string` value, length-delimited data converted to UTF-8 text.
         */
        string(value) {
          let chunk = this.textEncoder.encode(value);
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
        }
        /**
         * Write a `float` value, 32-bit floating point number.
         */
        float(value) {
          assertFloat32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setFloat32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `double` value, a 64-bit floating point number.
         */
        double(value) {
          let chunk = new Uint8Array(8);
          new DataView(chunk.buffer).setFloat64(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
         */
        fixed32(value) {
          assertUInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setUint32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
         */
        sfixed32(value) {
          assertInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setInt32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
         */
        sint32(value) {
          assertInt32(value);
          value = (value << 1 ^ value >> 31) >>> 0;
          varint32write(value, this.buf);
          return this;
        }
        /**
         * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
         */
        sfixed64(value) {
          let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
          view.setInt32(0, tc.lo, true);
          view.setInt32(4, tc.hi, true);
          return this.raw(chunk);
        }
        /**
         * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
         */
        fixed64(value) {
          let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
          view.setInt32(0, tc.lo, true);
          view.setInt32(4, tc.hi, true);
          return this.raw(chunk);
        }
        /**
         * Write a `int64` value, a signed 64-bit varint.
         */
        int64(value) {
          let tc = protoInt64.enc(value);
          varint64write(tc.lo, tc.hi, this.buf);
          return this;
        }
        /**
         * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
         */
        sint64(value) {
          let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
          varint64write(lo, hi, this.buf);
          return this;
        }
        /**
         * Write a `uint64` value, an unsigned 64-bit varint.
         */
        uint64(value) {
          let tc = protoInt64.uEnc(value);
          varint64write(tc.lo, tc.hi, this.buf);
          return this;
        }
      };
      BinaryReader = class {
        constructor(buf, textDecoder) {
          this.varint64 = varint64read;
          this.uint32 = varint32read;
          this.buf = buf;
          this.len = buf.length;
          this.pos = 0;
          this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
          this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
        }
        /**
         * Reads a tag - field number and wire type.
         */
        tag() {
          let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
          if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
          return [fieldNo, wireType];
        }
        /**
         * Skip one element on the wire and return the skipped data.
         * Supports WireType.StartGroup since v2.0.0-alpha.23.
         */
        skip(wireType) {
          let start = this.pos;
          switch (wireType) {
            case WireType.Varint:
              while (this.buf[this.pos++] & 128) {
              }
              break;
            case WireType.Bit64:
              this.pos += 4;
            case WireType.Bit32:
              this.pos += 4;
              break;
            case WireType.LengthDelimited:
              let len = this.uint32();
              this.pos += len;
              break;
            case WireType.StartGroup:
              let t;
              while ((t = this.tag()[1]) !== WireType.EndGroup) {
                this.skip(t);
              }
              break;
            default:
              throw new Error("cant skip wire type " + wireType);
          }
          this.assertBounds();
          return this.buf.subarray(start, this.pos);
        }
        /**
         * Throws error if position in byte array is out of range.
         */
        assertBounds() {
          if (this.pos > this.len)
            throw new RangeError("premature EOF");
        }
        /**
         * Read a `int32` field, a signed 32 bit varint.
         */
        int32() {
          return this.uint32() | 0;
        }
        /**
         * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
         */
        sint32() {
          let zze = this.uint32();
          return zze >>> 1 ^ -(zze & 1);
        }
        /**
         * Read a `int64` field, a signed 64-bit varint.
         */
        int64() {
          return protoInt64.dec(...this.varint64());
        }
        /**
         * Read a `uint64` field, an unsigned 64-bit varint.
         */
        uint64() {
          return protoInt64.uDec(...this.varint64());
        }
        /**
         * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
         */
        sint64() {
          let [lo, hi] = this.varint64();
          let s = -(lo & 1);
          lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
          hi = hi >>> 1 ^ s;
          return protoInt64.dec(lo, hi);
        }
        /**
         * Read a `bool` field, a variant.
         */
        bool() {
          let [lo, hi] = this.varint64();
          return lo !== 0 || hi !== 0;
        }
        /**
         * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
         */
        fixed32() {
          return this.view.getUint32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
         */
        sfixed32() {
          return this.view.getInt32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
         */
        fixed64() {
          return protoInt64.uDec(this.sfixed32(), this.sfixed32());
        }
        /**
         * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
         */
        sfixed64() {
          return protoInt64.dec(this.sfixed32(), this.sfixed32());
        }
        /**
         * Read a `float` field, 32-bit floating point number.
         */
        float() {
          return this.view.getFloat32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `double` field, a 64-bit floating point number.
         */
        double() {
          return this.view.getFloat64((this.pos += 8) - 8, true);
        }
        /**
         * Read a `bytes` field, length-delimited arbitrary data.
         */
        bytes() {
          let len = this.uint32(), start = this.pos;
          this.pos += len;
          this.assertBounds();
          return this.buf.subarray(start, start + len);
        }
        /**
         * Read a `string` field, length-delimited data converted to UTF-8 text.
         */
        string() {
          return this.textDecoder.decode(this.bytes());
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
  function wrapField(type, value) {
    if (value instanceof Message || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  function getUnwrappedFieldType(field) {
    if (field.fieldKind !== "message") {
      return void 0;
    }
    if (field.repeated) {
      return void 0;
    }
    if (field.oneof != void 0) {
      return void 0;
    }
    return wktWrapperToScalarType[field.message.typeName];
  }
  var wktWrapperToScalarType;
  var init_field_wrapper = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js"() {
      "use strict";
      init_message();
      init_field();
      wktWrapperToScalarType = {
        "google.protobuf.DoubleValue": ScalarType.DOUBLE,
        "google.protobuf.FloatValue": ScalarType.FLOAT,
        "google.protobuf.Int64Value": ScalarType.INT64,
        "google.protobuf.UInt64Value": ScalarType.UINT64,
        "google.protobuf.Int32Value": ScalarType.INT32,
        "google.protobuf.UInt32Value": ScalarType.UINT32,
        "google.protobuf.BoolValue": ScalarType.BOOL,
        "google.protobuf.StringValue": ScalarType.STRING,
        "google.protobuf.BytesValue": ScalarType.BYTES
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
  function scalarEquals(type, a, b) {
    if (a === b) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a == b;
    }
    return false;
  }
  function scalarDefaultValue(type) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return protoInt64.zero;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function scalarTypeInfo(type, value) {
    const isUndefined = value === void 0;
    let wireType = WireType.Varint;
    let isIntrinsicDefault = value === 0;
    switch (type) {
      case ScalarType.STRING:
        isIntrinsicDefault = isUndefined || !value.length;
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.BOOL:
        isIntrinsicDefault = value === false;
        break;
      case ScalarType.DOUBLE:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
      case ScalarType.INT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
      case ScalarType.UINT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
      case ScalarType.FIXED64:
        isIntrinsicDefault = isUndefined || value == 0;
        wireType = WireType.Bit64;
        break;
      case ScalarType.BYTES:
        isIntrinsicDefault = isUndefined || !value.byteLength;
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.FIXED32:
        wireType = WireType.Bit32;
        break;
      case ScalarType.SFIXED32:
        wireType = WireType.Bit32;
        break;
      case ScalarType.SFIXED64:
        isIntrinsicDefault = isUndefined || value == 0;
        wireType = WireType.Bit64;
        break;
      case ScalarType.SINT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method, isUndefined || isIntrinsicDefault];
  }
  var init_scalars = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js"() {
      "use strict";
      init_field();
      init_binary_encoding();
      init_proto_int64();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormatCommon() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m = message;
        const c = m[unknownFieldsSymbol];
        if (c) {
          for (const f of c) {
            writer.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m = message;
        if (!Array.isArray(m[unknownFieldsSymbol])) {
          m[unknownFieldsSymbol] = [];
        }
        m[unknownFieldsSymbol].push({ no, wireType, data });
      },
      readMessage(message, reader, length, options) {
        const type = message.getType();
        const end = length === void 0 ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          let target = message, repeated = field.repeated, localName2 = field.localName;
          if (field.oneof) {
            target = target[field.oneof.localName];
            if (target.case != localName2) {
              delete target.value;
            }
            target.case = localName2;
            localName2 = "value";
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                let arr = target[localName2];
                if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {
                  let e = reader.uint32() + reader.pos;
                  while (reader.pos < e) {
                    arr.push(readScalar(reader, scalarType));
                  }
                } else {
                  arr.push(readScalar(reader, scalarType));
                }
              } else {
                target[localName2] = readScalar(reader, scalarType);
              }
              break;
            case "message":
              const messageType = field.T;
              if (repeated) {
                target[localName2].push(readMessageField(reader, new messageType(), options));
              } else {
                if (target[localName2] instanceof Message) {
                  readMessageField(reader, target[localName2], options);
                } else {
                  target[localName2] = readMessageField(reader, new messageType(), options);
                  if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
                    target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
                  }
                }
              }
              break;
            case "map":
              let [mapKey, mapVal] = readMapEntry(field, reader, options);
              target[localName2][mapKey] = mapVal;
              break;
          }
        }
      }
    };
  }
  function readMessageField(reader, message, options) {
    const format = message.getType().runtime.bin;
    format.readMessage(message, reader, reader.uint32(), options);
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      let [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      let keyRaw = scalarDefaultValue(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarDefaultValue(field.V.T);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        writeScalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        writeMessageField(writer, options, field.V.T, 2, value);
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, type, fieldNo, value) {
    if (value !== void 0) {
      const message = wrapField(type, value);
      writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));
    }
  }
  function writeScalar(writer, type, fieldNo, value, emitIntrinsicDefault) {
    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);
    if (!isIntrinsicDefault || emitIntrinsicDefault) {
      writer.tag(fieldNo, wireType)[method](value);
    }
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
      writer[method](value[i]);
    }
    writer.join();
  }
  var unknownFieldsSymbol, readDefaults, writeDefaults;
  var init_binary_format_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js"() {
      "use strict";
      init_binary_encoding();
      init_message();
      init_field();
      init_field_wrapper();
      init_scalars();
      init_assert();
      unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
      readDefaults = {
        readUnknownFields: true,
        readerFactory: (bytes) => new BinaryReader(bytes)
      };
      writeDefaults = {
        writeUnknownFields: true,
        writerFactory: () => new BinaryWriter()
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto3.js
  function makeBinaryFormatProto3() {
    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), { writeMessage(message, writer, options) {
      const type = message.getType();
      for (const field of type.fields.byNumber()) {
        let value, repeated = field.repeated, localName2 = field.localName;
        if (field.oneof) {
          const oneof = message[field.oneof.localName];
          if (oneof.case !== localName2) {
            continue;
          }
          value = oneof.value;
        } else {
          value = message[localName2];
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
            if (repeated) {
              if (field.packed) {
                writePacked(writer, scalarType, field.no, value);
              } else {
                for (const item of value) {
                  writeScalar(writer, scalarType, field.no, item, true);
                }
              }
            } else {
              if (value !== void 0) {
                writeScalar(writer, scalarType, field.no, value, !!field.oneof || field.opt);
              }
            }
            break;
          case "message":
            if (repeated) {
              for (const item of value) {
                writeMessageField(writer, options, field.T, field.no, item);
              }
            } else {
              writeMessageField(writer, options, field.T, field.no, value);
            }
            break;
          case "map":
            for (const [key, val] of Object.entries(value)) {
              writeMapEntry(writer, options, field, key, val);
            }
            break;
        }
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    } });
  }
  var init_binary_format_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto3.js"() {
      "use strict";
      init_field();
      init_binary_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
  var encTable, decTable, protoBase64;
  var init_proto_base64 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js"() {
      "use strict";
      encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      decTable = [];
      for (let i = 0; i < encTable.length; i++)
        decTable[encTable[i].charCodeAt(0)] = i;
      decTable["-".charCodeAt(0)] = encTable.indexOf("+");
      decTable["_".charCodeAt(0)] = encTable.indexOf("/");
      protoBase64 = {
        /**
         * Decodes a base64 string to a byte array.
         *
         * - ignores white-space, including line breaks and tabs
         * - allows inner padding (can decode concatenated base64 strings)
         * - does not require padding
         * - understands base64url encoding:
         *   "-" instead of "+",
         *   "_" instead of "/",
         *   no padding
         */
        dec(base64Str) {
          let es = base64Str.length * 3 / 4;
          if (base64Str[base64Str.length - 2] == "=")
            es -= 2;
          else if (base64Str[base64Str.length - 1] == "=")
            es -= 1;
          let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
          for (let i = 0; i < base64Str.length; i++) {
            b = decTable[base64Str.charCodeAt(i)];
            if (b === void 0) {
              switch (base64Str[i]) {
                case "=":
                  groupPos = 0;
                case "\n":
                case "\r":
                case "	":
                case " ":
                  continue;
                default:
                  throw Error("invalid base64 string.");
              }
            }
            switch (groupPos) {
              case 0:
                p = b;
                groupPos = 1;
                break;
              case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
              case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
              case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
            }
          }
          if (groupPos == 1)
            throw Error("invalid base64 string.");
          return bytes.subarray(0, bytePos);
        },
        /**
         * Encode a byte array to a base64 string.
         */
        enc(bytes) {
          let base64 = "", groupPos = 0, b, p = 0;
          for (let i = 0; i < bytes.length; i++) {
            b = bytes[i];
            switch (groupPos) {
              case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
              case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
              case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
            }
          }
          if (groupPos) {
            base64 += encTable[p];
            base64 += "=";
            if (groupPos == 1)
              base64 += "=";
          }
          return base64;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js
  function makeReadOptions2(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions2(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  function makeJsonFormatCommon(makeWriteField) {
    const writeField = makeWriteField(writeEnum, writeScalar2);
    return {
      makeReadOptions: makeReadOptions2,
      makeWriteOptions: makeWriteOptions2,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type.typeName} from JSON: ${this.debug(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = {};
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (!field) {
            if (!options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
            continue;
          }
          let localName2 = field.localName;
          let target = message;
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen[field.oneof.localName];
            if (seen) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen[field.oneof.localName] = jsonKey;
            target = target[field.oneof.localName] = { case: localName2 };
            localName2 = "value";
          }
          if (field.repeated) {
            if (jsonValue === null) {
              continue;
            }
            if (!Array.isArray(jsonValue)) {
              throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);
            }
            const targetArray = target[localName2];
            for (const jsonItem of jsonValue) {
              if (jsonItem === null) {
                throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`);
              }
              let val;
              switch (field.kind) {
                case "message":
                  val = field.T.fromJson(jsonItem, options);
                  break;
                case "enum":
                  val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);
                  if (val === void 0)
                    continue;
                  break;
                case "scalar":
                  try {
                    val = readScalar2(field.T, jsonItem);
                  } catch (e) {
                    let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`;
                    if (e instanceof Error && e.message.length > 0) {
                      m += `: ${e.message}`;
                    }
                    throw new Error(m);
                  }
                  break;
              }
              targetArray.push(val);
            }
          } else if (field.kind == "map") {
            if (jsonValue === null) {
              continue;
            }
            if (Array.isArray(jsonValue) || typeof jsonValue != "object") {
              throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);
            }
            const targetMap = target[localName2];
            for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
              if (jsonMapValue === null) {
                throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: map value null`);
              }
              let val;
              switch (field.V.kind) {
                case "message":
                  val = field.V.T.fromJson(jsonMapValue, options);
                  break;
                case "enum":
                  val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);
                  if (val === void 0)
                    continue;
                  break;
                case "scalar":
                  try {
                    val = readScalar2(field.V.T, jsonMapValue);
                  } catch (e) {
                    let m = `cannot decode map value for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                    if (e instanceof Error && e.message.length > 0) {
                      m += `: ${e.message}`;
                    }
                    throw new Error(m);
                  }
                  break;
              }
              try {
                targetMap[readScalar2(field.K, field.K == ScalarType.BOOL ? jsonMapKey == "true" ? true : jsonMapKey == "false" ? false : jsonMapKey : jsonMapKey).toString()] = val;
              } catch (e) {
                let m = `cannot decode map key for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                if (e instanceof Error && e.message.length > 0) {
                  m += `: ${e.message}`;
                }
                throw new Error(m);
              }
            }
          } else {
            switch (field.kind) {
              case "message":
                const messageType = field.T;
                if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
                  if (field.oneof) {
                    throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: null is invalid for oneof field "${jsonKey}"`);
                  }
                  continue;
                }
                if (target[localName2] instanceof Message) {
                  target[localName2].fromJson(jsonValue, options);
                } else {
                  target[localName2] = messageType.fromJson(jsonValue, options);
                  if (messageType.fieldWrapper && !field.oneof) {
                    target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
                  }
                }
                break;
              case "enum":
                const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);
                if (enumValue !== void 0) {
                  target[localName2] = enumValue;
                }
                break;
              case "scalar":
                try {
                  target[localName2] = readScalar2(field.T, jsonValue);
                } catch (e) {
                  let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                  if (e instanceof Error && e.message.length > 0) {
                    m += `: ${e.message}`;
                  }
                  throw new Error(m);
                }
                break;
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (const member of type.fields.byMember()) {
            let jsonValue;
            if (member.kind == "oneof") {
              const oneof = message[member.localName];
              if (oneof.value === void 0) {
                continue;
              }
              field = member.findField(oneof.case);
              if (!field) {
                throw "oneof case not found: " + oneof.case;
              }
              jsonValue = writeField(field, oneof.value, options);
            } else {
              field = member;
              jsonValue = writeField(field, message[field.localName], options);
            }
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
        } catch (e) {
          const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
          const r = e instanceof Error ? e.message : String(e);
          throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
        }
        return json;
      },
      readScalar: readScalar2,
      writeScalar: writeScalar2,
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readScalar2(type, json) {
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === null)
          return 0;
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        if (json === null)
          return 0;
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (json === null)
          return protoInt64.zero;
        if (typeof json != "number" && typeof json != "string")
          break;
        return protoInt64.parse(json);
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (json === null)
          return protoInt64.zero;
        if (typeof json != "number" && typeof json != "string")
          break;
        return protoInt64.uParse(json);
      case ScalarType.BOOL:
        if (json === null)
          return false;
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (json === null)
          return "";
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === null || json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields) {
    if (json === null) {
      return 0;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value || ignoreUnknownFields) {
          return value === null || value === void 0 ? void 0 : value.no;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {
    var _a;
    if (value === void 0) {
      return value;
    }
    if (value === 0 && !emitIntrinsicDefault) {
      return void 0;
    }
    if (enumAsInteger) {
      return value;
    }
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar2(type, value, emitIntrinsicDefault) {
    if (value === void 0) {
      return void 0;
    }
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value != 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value !== 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value.length > 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value || emitIntrinsicDefault ? value : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return emitIntrinsicDefault || value != 0 ? value.toString(10) : void 0;
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : void 0;
    }
  }
  var jsonReadDefaults, jsonWriteDefaults;
  var init_json_format_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js"() {
      "use strict";
      init_message();
      init_field();
      init_assert();
      init_proto_int64();
      init_proto_base64();
      jsonReadDefaults = {
        ignoreUnknownFields: false
      };
      jsonWriteDefaults = {
        emitDefaultValues: false,
        enumAsInteger: false,
        useProtoFieldName: false,
        prettySpaces: 0
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto3.js
  function makeJsonFormatProto3() {
    return makeJsonFormatCommon((writeEnum2, writeScalar3) => {
      return function writeField(field, value, options) {
        if (field.kind == "map") {
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = writeScalar3(field.V.T, entryValue, true);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                jsonObj[entryKey.toString()] = entryValue.toJson(options);
              }
              break;
            case "enum":
              const enumType2 = field.V.T;
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert(entryValue === void 0 || typeof entryValue == "number");
                const val = writeEnum2(enumType2, entryValue, true, options.enumAsInteger);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : void 0;
        } else if (field.repeated) {
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeScalar3(field.T, value[i], true));
              }
              break;
            case "enum":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeEnum2(field.T, value[i], true, options.enumAsInteger));
              }
              break;
            case "message":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(wrapField(field.T, value[i]).toJson(options));
              }
              break;
          }
          return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
        } else {
          switch (field.kind) {
            case "scalar":
              return writeScalar3(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);
            case "enum":
              return writeEnum2(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);
            case "message":
              return value !== void 0 ? wrapField(field.T, value).toJson(options) : void 0;
          }
        }
      };
    });
  }
  var init_json_format_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto3.js"() {
      "use strict";
      init_field_wrapper();
      init_assert();
      init_json_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName2 = member.localName, t = target, s = source;
          if (s[localName2] === void 0) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s[localName2].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s[localName2].value;
              if (sourceField && sourceField.kind == "message" && !(val instanceof sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName2] = { case: sk, value: val };
              break;
            case "scalar":
            case "enum":
              let copy = s[localName2];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName2] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v] of Object.entries(s[localName2])) {
                      t[localName2][k] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName2], s[localName2]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s[localName2])) {
                    let val2 = s[localName2][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName2][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName2] = s[localName2].map((val2) => val2 instanceof mt ? val2 : new mt(val2));
              } else if (s[localName2] !== void 0) {
                const val2 = s[localName2];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName2] = toU8Arr(val2);
                  } else {
                    t[localName2] = val2;
                  }
                } else {
                  t[localName2] = val2 instanceof mt ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      equals(type, a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return type.fields.byMember().every((m) => {
          const va = a[m.localName];
          const vb = b[m.localName];
          if (m.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m.kind) {
              case "message":
                return va.every((a2, i) => m.T.equals(a2, vb[i]));
              case "scalar":
                return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
              case "enum":
                return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
            }
            throw new Error(`repeated cannot contain ${m.kind}`);
          }
          switch (m.kind) {
            case "message":
              return m.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s = m.findField(va.case);
              if (s === void 0) {
                return true;
              }
              switch (s.kind) {
                case "message":
                  return s.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s.T, va.value, vb.value);
              }
              throw new Error(`oneof cannot contain ${s.kind}`);
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m.V.kind) {
                case "message":
                  const messageType = m.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v] of Object.entries(source)) {
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == "oneof") {
            const f = member.findField(source.case);
            copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (value instanceof Message) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  var init_util_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js"() {
      "use strict";
      init_enum();
      init_message();
      init_field();
      init_scalars();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
  var InternalFieldList;
  var init_field_list = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js"() {
      "use strict";
      InternalFieldList = class {
        constructor(fields, normalizer) {
          this._fields = fields;
          this._normalizer = normalizer;
        }
        findJsonName(jsonName) {
          if (!this.jsonNames) {
            const t = {};
            for (const f of this.list()) {
              t[f.jsonName] = t[f.name] = f;
            }
            this.jsonNames = t;
          }
          return this.jsonNames[jsonName];
        }
        find(fieldNo) {
          if (!this.numbers) {
            const t = {};
            for (const f of this.list()) {
              t[f.no] = f;
            }
            this.numbers = t;
          }
          return this.numbers[fieldNo];
        }
        list() {
          if (!this.all) {
            this.all = this._normalizer(this._fields);
          }
          return this.all;
        }
        byNumber() {
          if (!this.numbersAsc) {
            this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
          }
          return this.numbersAsc;
        }
        byMember() {
          if (!this.members) {
            this.members = [];
            const a = this.members;
            let o;
            for (const f of this.list()) {
              if (f.oneof) {
                if (f.oneof !== o) {
                  o = f.oneof;
                  a.push(o);
                }
              } else {
                a.push(f);
              }
            }
          }
          return this.members;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/names.js
  function localName(desc) {
    switch (desc.kind) {
      case "field":
        return localFieldName(desc.name, desc.oneof !== void 0);
      case "oneof":
        return localOneofName(desc.name);
      case "enum":
      case "message":
      case "service": {
        const pkg = desc.file.proto.package;
        const offset = pkg === void 0 ? 0 : pkg.length + 1;
        const name = desc.typeName.substring(offset).replace(/\./g, "_");
        return safeObjectProperty(safeIdentifier(name));
      }
      case "enum_value": {
        const sharedPrefix = desc.parent.sharedPrefix;
        if (sharedPrefix === void 0) {
          return desc.name;
        }
        const name = desc.name.substring(sharedPrefix.length);
        return safeObjectProperty(name);
      }
      case "rpc": {
        let name = desc.name;
        if (name.length == 0) {
          return name;
        }
        name = name[0].toLowerCase() + name.substring(1);
        return safeObjectProperty(name);
      }
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  function findEnumSharedPrefix(enumName, valueNames) {
    const prefix = camelToSnakeCase(enumName) + "_";
    for (const name of valueNames) {
      if (!name.toLowerCase().startsWith(prefix)) {
        return void 0;
      }
      const shortName = name.substring(prefix.length);
      if (shortName.length == 0) {
        return void 0;
      }
      if (/^\d/.test(shortName)) {
        return void 0;
      }
    }
    return prefix;
  }
  function camelToSnakeCase(camel) {
    return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => "_" + c)).toLowerCase();
  }
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join("");
  }
  var fieldJsonName, reservedIdentifiers, reservedObjectProperties, reservedMessageProperties, fallback, safeMessageProperty, safeObjectProperty, safeIdentifier;
  var init_names = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/names.js"() {
      "use strict";
      fieldJsonName = protoCamelCase;
      reservedIdentifiers = /* @__PURE__ */ new Set([
        // ECMAScript 2015 keywords
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "null",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield",
        // ECMAScript 2015 future reserved keywords
        "enum",
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        // Class name cannot be 'Object' when targeting ES5 with module CommonJS
        "Object",
        // TypeScript keywords that cannot be used for types (as opposed to variables)
        "bigint",
        "number",
        "boolean",
        "string",
        "object",
        // Identifiers reserved for the runtime, so we can generate legible code
        "globalThis",
        "Uint8Array",
        "Partial"
      ]);
      reservedObjectProperties = /* @__PURE__ */ new Set([
        // names reserved by JavaScript
        "constructor",
        "toString",
        "toJSON",
        "valueOf"
      ]);
      reservedMessageProperties = /* @__PURE__ */ new Set([
        // names reserved by the runtime
        "getType",
        "clone",
        "equals",
        "fromBinary",
        "fromJson",
        "fromJsonString",
        "toBinary",
        "toJson",
        "toJsonString",
        // names reserved by the runtime for the future
        "toObject"
      ]);
      fallback = (name) => `${name}$`;
      safeMessageProperty = (name) => {
        if (reservedMessageProperties.has(name)) {
          return fallback(name);
        }
        return name;
      };
      safeObjectProperty = (name) => {
        if (reservedObjectProperties.has(name)) {
          return fallback(name);
        }
        return name;
      };
      safeIdentifier = (name) => {
        if (reservedIdentifiers.has(name)) {
          return fallback(name);
        }
        return name;
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field.js
  var InternalOneofInfo;
  var init_field2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field.js"() {
      "use strict";
      init_names();
      init_assert();
      InternalOneofInfo = class {
        constructor(name) {
          this.kind = "oneof";
          this.repeated = false;
          this.packed = false;
          this.opt = false;
          this.default = void 0;
          this.fields = [];
          this.name = name;
          this.localName = localOneofName(name);
        }
        addField(field) {
          assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
          this.fields.push(field);
        }
        findField(localName2) {
          if (!this._lookup) {
            this._lookup = /* @__PURE__ */ Object.create(null);
            for (let i = 0; i < this.fields.length; i++) {
              this._lookup[this.fields[i].localName] = this.fields[i];
            }
          }
          return this._lookup[localName2];
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto3.js
  function normalizeFieldInfosProto3(fieldInfos) {
    var _a, _b, _c;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      f.packed = (_c = field.packed) !== null && _c !== void 0 ? _c : field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }
  var proto3;
  var init_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto3.js"() {
      "use strict";
      init_proto_runtime();
      init_binary_format_proto3();
      init_json_format_proto3();
      init_util_common();
      init_field_list();
      init_scalars();
      init_field();
      init_field2();
      init_names();
      proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList(fields) {
          return new InternalFieldList(fields, normalizeFieldInfosProto3);
        },
        initFields(target) {
          for (const member of target.getType().fields.byMember()) {
            if (member.opt) {
              continue;
            }
            const name = member.localName, t = target;
            if (member.repeated) {
              t[name] = [];
              continue;
            }
            switch (member.kind) {
              case "oneof":
                t[name] = { case: void 0 };
                break;
              case "enum":
                t[name] = 0;
                break;
              case "map":
                t[name] = {};
                break;
              case "scalar":
                t[name] = scalarDefaultValue(member.T);
                break;
              case "message":
                break;
            }
          }
        }
      }));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto2.js
  function makeBinaryFormatProto2() {
    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), { writeMessage(message, writer, options) {
      const type = message.getType();
      let field;
      try {
        for (field of type.fields.byNumber()) {
          let value, repeated = field.repeated, localName2 = field.localName;
          if (field.oneof) {
            const oneof = message[field.oneof.localName];
            if (oneof.case !== localName2) {
              continue;
            }
            value = oneof.value;
          } else {
            value = message[localName2];
            if (value === void 0 && !field.oneof && !field.opt) {
              throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
            }
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                if (field.packed) {
                  writePacked(writer, scalarType, field.no, value);
                } else {
                  for (const item of value) {
                    writeScalar(writer, scalarType, field.no, item, true);
                  }
                }
              } else {
                if (value !== void 0) {
                  writeScalar(writer, scalarType, field.no, value, true);
                }
              }
              break;
            case "message":
              if (repeated) {
                for (const item of value) {
                  writeMessageField(writer, options, field.T, field.no, item);
                }
              } else {
                writeMessageField(writer, options, field.T, field.no, value);
              }
              break;
            case "map":
              for (const [key, val] of Object.entries(value)) {
                writeMapEntry(writer, options, field, key, val);
              }
              break;
          }
        }
      } catch (e) {
        let m = field ? `cannot encode field ${type.typeName}.${field === null || field === void 0 ? void 0 : field.name} to binary` : `cannot encode message ${type.typeName} to binary`;
        let r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    } });
  }
  var init_binary_format_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto2.js"() {
      "use strict";
      init_field();
      init_binary_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto2.js
  function makeJsonFormatProto2() {
    return makeJsonFormatCommon((writeEnum2, writeScalar3) => {
      return function writeField(field, value, options) {
        if (field.kind == "map") {
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = writeScalar3(field.V.T, entryValue, true);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                jsonObj[entryKey.toString()] = entryValue.toJson(options);
              }
              break;
            case "enum":
              const enumType2 = field.V.T;
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert(entryValue === void 0 || typeof entryValue == "number");
                const val = writeEnum2(enumType2, entryValue, true, options.enumAsInteger);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : void 0;
        } else if (field.repeated) {
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeScalar3(field.T, value[i], true));
              }
              break;
            case "enum":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeEnum2(field.T, value[i], true, options.enumAsInteger));
              }
              break;
            case "message":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(value[i].toJson(options));
              }
              break;
          }
          return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
        } else {
          if (value === void 0) {
            if (!field.oneof && !field.opt) {
              throw `required field not set`;
            }
            return void 0;
          }
          switch (field.kind) {
            case "scalar":
              return writeScalar3(field.T, value, true);
            case "enum":
              return writeEnum2(field.T, value, true, options.enumAsInteger);
            case "message":
              return wrapField(field.T, value).toJson(options);
          }
        }
      };
    });
  }
  var init_json_format_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto2.js"() {
      "use strict";
      init_field_wrapper();
      init_assert();
      init_json_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto2.js
  function normalizeFieldInfosProto2(fieldInfos) {
    var _a, _b, _c;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      f.packed = (_c = field.packed) !== null && _c !== void 0 ? _c : false;
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }
  var proto2;
  var init_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto2.js"() {
      "use strict";
      init_proto_runtime();
      init_binary_format_proto2();
      init_util_common();
      init_field_list();
      init_field2();
      init_names();
      init_json_format_proto2();
      proto2 = makeProtoRuntime("proto2", makeJsonFormatProto2(), makeBinaryFormatProto2(), Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList(fields) {
          return new InternalFieldList(fields, normalizeFieldInfosProto2);
        },
        initFields(target) {
          for (const member of target.getType().fields.byMember()) {
            const name = member.localName, t = target;
            if (member.repeated) {
              t[name] = [];
              continue;
            }
            switch (member.kind) {
              case "oneof":
                t[name] = { case: void 0 };
                break;
              case "map":
                t[name] = {};
                break;
              case "scalar":
              case "enum":
              case "message":
                break;
            }
          }
        }
      }));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-double.js
  var protoDouble;
  var init_proto_double = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-double.js"() {
      "use strict";
      protoDouble = {
        NaN: Number.NaN,
        POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
        NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-delimited.js
  var __asyncValues, __await, __asyncGenerator, protoDelimited;
  var init_proto_delimited = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-delimited.js"() {
      "use strict";
      init_binary_format_common();
      init_binary_encoding();
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      protoDelimited = {
        /**
         * Serialize a message, prefixing it with its size.
         */
        enc(message, options) {
          const opt = makeBinaryFormatCommon().makeWriteOptions(options);
          return opt.writerFactory().bytes(message.toBinary(opt)).finish();
        },
        /**
         * Parse a size-delimited message, ignoring extra bytes.
         */
        dec(type, bytes, options) {
          const opt = makeBinaryFormatCommon().makeReadOptions(options);
          return type.fromBinary(opt.readerFactory(bytes).bytes(), opt);
        },
        /**
         * Parse a stream of size-delimited messages.
         */
        decStream(type, iterable) {
          return __asyncGenerator(this, arguments, function* decStream_1() {
            var _a, e_1, _b, _c;
            function append(buffer2, chunk) {
              const n = new Uint8Array(buffer2.byteLength + chunk.byteLength);
              n.set(buffer2);
              n.set(chunk, buffer2.length);
              return n;
            }
            let buffer = new Uint8Array(0);
            try {
              for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
                _c = iterable_1_1.value;
                _d = false;
                const chunk = _c;
                buffer = append(buffer, chunk);
                for (; ; ) {
                  const size = protoDelimited.peekSize(buffer);
                  if (size.eof) {
                    break;
                  }
                  if (size.offset + size.size > buffer.byteLength) {
                    break;
                  }
                  yield yield __await(protoDelimited.dec(type, buffer));
                  buffer = buffer.subarray(size.offset + size.size);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = iterable_1.return))
                  yield __await(_b.call(iterable_1));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            if (buffer.byteLength > 0) {
              throw new Error("incomplete data");
            }
          });
        },
        /**
         * Decodes the size from the given size-delimited message, which may be
         * incomplete.
         *
         * Returns an object with the following properties:
         * - size: The size of the delimited message in bytes
         * - offset: The offset in the given byte array where the message starts
         * - eof: true
         *
         * If the size-delimited data does not include all bytes of the varint size,
         * the following object is returned:
         * - size: null
         * - offset: null
         * - eof: false
         *
         * This function can be used to implement parsing of size-delimited messages
         * from a stream.
         */
        peekSize(data) {
          const sizeEof = { eof: true, size: null, offset: null };
          for (let i = 0; i < 10; i++) {
            if (i > data.byteLength) {
              return sizeEof;
            }
            if ((data[i] & 128) == 0) {
              const reader = new BinaryReader(data);
              let size;
              try {
                size = reader.uint32();
              } catch (e) {
                if (e instanceof RangeError) {
                  return sizeEof;
                }
                throw e;
              }
              return {
                eof: false,
                size,
                offset: reader.pos
              };
            }
          }
          throw new Error("invalid varint");
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/reify-wkt.js
  function reifyWkt(message) {
    switch (message.typeName) {
      case "google.protobuf.Any": {
        const typeUrl = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING);
        const value = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.BYTES);
        if (typeUrl && value) {
          return {
            typeName: message.typeName,
            typeUrl,
            value
          };
        }
        break;
      }
      case "google.protobuf.Timestamp": {
        const seconds = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT64);
        const nanos = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT32);
        if (seconds && nanos) {
          return {
            typeName: message.typeName,
            seconds,
            nanos
          };
        }
        break;
      }
      case "google.protobuf.Duration": {
        const seconds = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT64);
        const nanos = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT32);
        if (seconds && nanos) {
          return {
            typeName: message.typeName,
            seconds,
            nanos
          };
        }
        break;
      }
      case "google.protobuf.Struct": {
        const fields = message.fields.find((f) => f.number == 1 && !f.repeated);
        if ((fields === null || fields === void 0 ? void 0 : fields.fieldKind) !== "map" || fields.mapValue.kind !== "message" || fields.mapValue.message.typeName !== "google.protobuf.Value") {
          break;
        }
        return { typeName: message.typeName, fields };
      }
      case "google.protobuf.Value": {
        const kind = message.oneofs.find((o) => o.name === "kind");
        const nullValue = message.fields.find((f) => f.number == 1 && f.oneof === kind);
        if ((nullValue === null || nullValue === void 0 ? void 0 : nullValue.fieldKind) !== "enum" || nullValue.enum.typeName !== "google.protobuf.NullValue") {
          return void 0;
        }
        const numberValue = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.DOUBLE && f.oneof === kind);
        const stringValue = message.fields.find((f) => f.number == 3 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING && f.oneof === kind);
        const boolValue = message.fields.find((f) => f.number == 4 && f.fieldKind == "scalar" && f.scalar === ScalarType.BOOL && f.oneof === kind);
        const structValue = message.fields.find((f) => f.number == 5 && f.oneof === kind);
        if ((structValue === null || structValue === void 0 ? void 0 : structValue.fieldKind) !== "message" || structValue.message.typeName !== "google.protobuf.Struct") {
          return void 0;
        }
        const listValue = message.fields.find((f) => f.number == 6 && f.oneof === kind);
        if ((listValue === null || listValue === void 0 ? void 0 : listValue.fieldKind) !== "message" || listValue.message.typeName !== "google.protobuf.ListValue") {
          return void 0;
        }
        if (kind && numberValue && stringValue && boolValue) {
          return {
            typeName: message.typeName,
            kind,
            nullValue,
            numberValue,
            stringValue,
            boolValue,
            structValue,
            listValue
          };
        }
        break;
      }
      case "google.protobuf.ListValue": {
        const values = message.fields.find((f) => f.number == 1 && f.repeated);
        if ((values === null || values === void 0 ? void 0 : values.fieldKind) != "message" || values.message.typeName !== "google.protobuf.Value") {
          break;
        }
        return { typeName: message.typeName, values };
      }
      case "google.protobuf.FieldMask": {
        const paths = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING && f.repeated);
        if (paths) {
          return { typeName: message.typeName, paths };
        }
        break;
      }
      case "google.protobuf.DoubleValue":
      case "google.protobuf.FloatValue":
      case "google.protobuf.Int64Value":
      case "google.protobuf.UInt64Value":
      case "google.protobuf.Int32Value":
      case "google.protobuf.UInt32Value":
      case "google.protobuf.BoolValue":
      case "google.protobuf.StringValue":
      case "google.protobuf.BytesValue": {
        const value = message.fields.find((f) => f.number == 1 && f.name == "value");
        if (!value) {
          break;
        }
        if (value.fieldKind !== "scalar") {
          break;
        }
        return { typeName: message.typeName, value };
      }
    }
    return void 0;
  }
  var init_reify_wkt = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/reify-wkt.js"() {
      "use strict";
      init_field();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/codegen-info.js
  var packageName, codegenInfo;
  var init_codegen_info = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/codegen-info.js"() {
      "use strict";
      init_names();
      init_field_wrapper();
      init_scalars();
      init_reify_wkt();
      packageName = "@bufbuild/protobuf";
      codegenInfo = {
        packageName,
        localName,
        reifyWkt,
        getUnwrappedFieldType,
        scalarDefaultValue,
        safeIdentifier,
        safeObjectProperty,
        // prettier-ignore
        symbols: {
          proto2: { typeOnly: false, privateImportPath: "./proto2.js", publicImportPath: packageName },
          proto3: { typeOnly: false, privateImportPath: "./proto3.js", publicImportPath: packageName },
          Message: { typeOnly: false, privateImportPath: "./message.js", publicImportPath: packageName },
          PartialMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
          PlainMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
          FieldList: { typeOnly: true, privateImportPath: "./field-list.js", publicImportPath: packageName },
          MessageType: { typeOnly: true, privateImportPath: "./message-type.js", publicImportPath: packageName },
          BinaryReadOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
          BinaryWriteOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
          JsonReadOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonWriteOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonValue: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonObject: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          protoDouble: { typeOnly: false, privateImportPath: "./proto-double.js", publicImportPath: packageName },
          protoInt64: { typeOnly: false, privateImportPath: "./proto-int64.js", publicImportPath: packageName },
          ScalarType: { typeOnly: false, privateImportPath: "./field.js", publicImportPath: packageName },
          MethodKind: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
          MethodIdempotency: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
          IMessageTypeRegistry: { typeOnly: true, privateImportPath: "./type-registry.js", publicImportPath: packageName }
        },
        wktSourceFiles: [
          "google/protobuf/compiler/plugin.proto",
          "google/protobuf/any.proto",
          "google/protobuf/api.proto",
          "google/protobuf/descriptor.proto",
          "google/protobuf/duration.proto",
          "google/protobuf/empty.proto",
          "google/protobuf/field_mask.proto",
          "google/protobuf/source_context.proto",
          "google/protobuf/struct.proto",
          "google/protobuf/timestamp.proto",
          "google/protobuf/type.proto",
          "google/protobuf/wrappers.proto"
        ]
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/service-type.js
  var MethodKind, MethodIdempotency;
  var init_service_type = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/service-type.js"() {
      "use strict";
      (function(MethodKind2) {
        MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
        MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
        MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
        MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
      })(MethodKind || (MethodKind = {}));
      (function(MethodIdempotency2) {
        MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
        MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
      })(MethodIdempotency || (MethodIdempotency = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js
  var FileDescriptorSet, FileDescriptorProto, DescriptorProto, DescriptorProto_ExtensionRange, DescriptorProto_ReservedRange, ExtensionRangeOptions, ExtensionRangeOptions_VerificationState, ExtensionRangeOptions_Declaration, FieldDescriptorProto, FieldDescriptorProto_Type, FieldDescriptorProto_Label, OneofDescriptorProto, EnumDescriptorProto, EnumDescriptorProto_EnumReservedRange, EnumValueDescriptorProto, ServiceDescriptorProto, MethodDescriptorProto, FileOptions, FileOptions_OptimizeMode, MessageOptions, FieldOptions, FieldOptions_CType, FieldOptions_JSType, FieldOptions_OptionRetention, FieldOptions_OptionTargetType, OneofOptions, EnumOptions, EnumValueOptions, ServiceOptions, MethodOptions, MethodOptions_IdempotencyLevel, UninterpretedOption, UninterpretedOption_NamePart, SourceCodeInfo, SourceCodeInfo_Location, GeneratedCodeInfo, GeneratedCodeInfo_Annotation, GeneratedCodeInfo_Annotation_Semantic;
  var init_descriptor_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js"() {
      "use strict";
      init_message();
      init_proto2();
      FileDescriptorSet = class _FileDescriptorSet extends Message {
        constructor(data) {
          super();
          this.file = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileDescriptorSet().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileDescriptorSet().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileDescriptorSet().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileDescriptorSet, a, b);
        }
      };
      FileDescriptorSet.runtime = proto2;
      FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
      FileDescriptorSet.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
      ]);
      FileDescriptorProto = class _FileDescriptorProto extends Message {
        constructor(data) {
          super();
          this.dependency = [];
          this.publicDependency = [];
          this.weakDependency = [];
          this.messageType = [];
          this.enumType = [];
          this.service = [];
          this.extension = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileDescriptorProto, a, b);
        }
      };
      FileDescriptorProto.runtime = proto2;
      FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
      FileDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
        { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
        { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
        { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
        { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
        { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
        { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
        { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
        { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
        { no: 13, name: "edition", kind: "scalar", T: 9, opt: true }
      ]);
      DescriptorProto = class _DescriptorProto extends Message {
        constructor(data) {
          super();
          this.field = [];
          this.extension = [];
          this.nestedType = [];
          this.enumType = [];
          this.extensionRange = [];
          this.oneofDecl = [];
          this.reservedRange = [];
          this.reservedName = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto, a, b);
        }
      };
      DescriptorProto.runtime = proto2;
      DescriptorProto.typeName = "google.protobuf.DescriptorProto";
      DescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
        { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
        { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
        { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
        { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
        { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
        { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
      ]);
      DescriptorProto_ExtensionRange = class _DescriptorProto_ExtensionRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto_ExtensionRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto_ExtensionRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto_ExtensionRange, a, b);
        }
      };
      DescriptorProto_ExtensionRange.runtime = proto2;
      DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
      DescriptorProto_ExtensionRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
      ]);
      DescriptorProto_ReservedRange = class _DescriptorProto_ReservedRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto_ReservedRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto_ReservedRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto_ReservedRange, a, b);
        }
      };
      DescriptorProto_ReservedRange.runtime = proto2;
      DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
      DescriptorProto_ReservedRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
      ]);
      ExtensionRangeOptions = class _ExtensionRangeOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          this.declaration = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ExtensionRangeOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ExtensionRangeOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ExtensionRangeOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ExtensionRangeOptions, a, b);
        }
      };
      ExtensionRangeOptions.runtime = proto2;
      ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
      ExtensionRangeOptions.fields = proto2.util.newFieldList(() => [
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
        { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
        { no: 3, name: "verification", kind: "enum", T: proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
      ]);
      (function(ExtensionRangeOptions_VerificationState2) {
        ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
        ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
      })(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
      proto2.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
        { no: 0, name: "DECLARATION" },
        { no: 1, name: "UNVERIFIED" }
      ]);
      ExtensionRangeOptions_Declaration = class _ExtensionRangeOptions_Declaration extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ExtensionRangeOptions_Declaration().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ExtensionRangeOptions_Declaration, a, b);
        }
      };
      ExtensionRangeOptions_Declaration.runtime = proto2;
      ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
      ExtensionRangeOptions_Declaration.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "is_repeated", kind: "scalar", T: 8, opt: true },
        { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
        { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
      ]);
      FieldDescriptorProto = class _FieldDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FieldDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FieldDescriptorProto, a, b);
        }
      };
      FieldDescriptorProto.runtime = proto2;
      FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
      FieldDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "label", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Label), opt: true },
        { no: 5, name: "type", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Type), opt: true },
        { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
        { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
        { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
        { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
        { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
        { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
      ]);
      (function(FieldDescriptorProto_Type2) {
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
      })(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
      proto2.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
        { no: 1, name: "TYPE_DOUBLE" },
        { no: 2, name: "TYPE_FLOAT" },
        { no: 3, name: "TYPE_INT64" },
        { no: 4, name: "TYPE_UINT64" },
        { no: 5, name: "TYPE_INT32" },
        { no: 6, name: "TYPE_FIXED64" },
        { no: 7, name: "TYPE_FIXED32" },
        { no: 8, name: "TYPE_BOOL" },
        { no: 9, name: "TYPE_STRING" },
        { no: 10, name: "TYPE_GROUP" },
        { no: 11, name: "TYPE_MESSAGE" },
        { no: 12, name: "TYPE_BYTES" },
        { no: 13, name: "TYPE_UINT32" },
        { no: 14, name: "TYPE_ENUM" },
        { no: 15, name: "TYPE_SFIXED32" },
        { no: 16, name: "TYPE_SFIXED64" },
        { no: 17, name: "TYPE_SINT32" },
        { no: 18, name: "TYPE_SINT64" }
      ]);
      (function(FieldDescriptorProto_Label2) {
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
      })(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
      proto2.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
        { no: 1, name: "LABEL_OPTIONAL" },
        { no: 2, name: "LABEL_REQUIRED" },
        { no: 3, name: "LABEL_REPEATED" }
      ]);
      OneofDescriptorProto = class _OneofDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _OneofDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _OneofDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _OneofDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_OneofDescriptorProto, a, b);
        }
      };
      OneofDescriptorProto.runtime = proto2;
      OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
      OneofDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
      ]);
      EnumDescriptorProto = class _EnumDescriptorProto extends Message {
        constructor(data) {
          super();
          this.value = [];
          this.reservedRange = [];
          this.reservedName = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumDescriptorProto, a, b);
        }
      };
      EnumDescriptorProto.runtime = proto2;
      EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
      EnumDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
        { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
        { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
        { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
      ]);
      EnumDescriptorProto_EnumReservedRange = class _EnumDescriptorProto_EnumReservedRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumDescriptorProto_EnumReservedRange, a, b);
        }
      };
      EnumDescriptorProto_EnumReservedRange.runtime = proto2;
      EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
      EnumDescriptorProto_EnumReservedRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
      ]);
      EnumValueDescriptorProto = class _EnumValueDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValueDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValueDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValueDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumValueDescriptorProto, a, b);
        }
      };
      EnumValueDescriptorProto.runtime = proto2;
      EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
      EnumValueDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
      ]);
      ServiceDescriptorProto = class _ServiceDescriptorProto extends Message {
        constructor(data) {
          super();
          this.method = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ServiceDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ServiceDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ServiceDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ServiceDescriptorProto, a, b);
        }
      };
      ServiceDescriptorProto.runtime = proto2;
      ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
      ServiceDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
        { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
      ]);
      MethodDescriptorProto = class _MethodDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MethodDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MethodDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MethodDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MethodDescriptorProto, a, b);
        }
      };
      MethodDescriptorProto.runtime = proto2;
      MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
      MethodDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
        { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
        { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
      ]);
      FileOptions = class _FileOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileOptions, a, b);
        }
      };
      FileOptions.runtime = proto2;
      FileOptions.typeName = "google.protobuf.FileOptions";
      FileOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
        { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
        { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
        { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
        { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
        { no: 9, name: "optimize_for", kind: "enum", T: proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
        { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
        { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 42, name: "php_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
        { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
        { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
        { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
        { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
        { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
        { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
        { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(FileOptions_OptimizeMode2) {
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
      })(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
      proto2.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
        { no: 1, name: "SPEED" },
        { no: 2, name: "CODE_SIZE" },
        { no: 3, name: "LITE_RUNTIME" }
      ]);
      MessageOptions = class _MessageOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MessageOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MessageOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MessageOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MessageOptions, a, b);
        }
      };
      MessageOptions.runtime = proto2;
      MessageOptions.typeName = "google.protobuf.MessageOptions";
      MessageOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
        { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
        { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      FieldOptions = class _FieldOptions extends Message {
        constructor(data) {
          super();
          this.targets = [];
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FieldOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FieldOptions, a, b);
        }
      };
      FieldOptions.runtime = proto2;
      FieldOptions.typeName = "google.protobuf.FieldOptions";
      FieldOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "ctype", kind: "enum", T: proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
        { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
        { no: 6, name: "jstype", kind: "enum", T: proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
        { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
        { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
        { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
        { no: 17, name: "retention", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionRetention), opt: true },
        { no: 18, name: "target", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), opt: true },
        { no: 19, name: "targets", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(FieldOptions_CType2) {
        FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
        FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
        FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
      })(FieldOptions_CType || (FieldOptions_CType = {}));
      proto2.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
        { no: 0, name: "STRING" },
        { no: 1, name: "CORD" },
        { no: 2, name: "STRING_PIECE" }
      ]);
      (function(FieldOptions_JSType2) {
        FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
        FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
        FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
      })(FieldOptions_JSType || (FieldOptions_JSType = {}));
      proto2.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
        { no: 0, name: "JS_NORMAL" },
        { no: 1, name: "JS_STRING" },
        { no: 2, name: "JS_NUMBER" }
      ]);
      (function(FieldOptions_OptionRetention2) {
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
      })(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
      proto2.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
        { no: 0, name: "RETENTION_UNKNOWN" },
        { no: 1, name: "RETENTION_RUNTIME" },
        { no: 2, name: "RETENTION_SOURCE" }
      ]);
      (function(FieldOptions_OptionTargetType2) {
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
      })(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
      proto2.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
        { no: 0, name: "TARGET_TYPE_UNKNOWN" },
        { no: 1, name: "TARGET_TYPE_FILE" },
        { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
        { no: 3, name: "TARGET_TYPE_MESSAGE" },
        { no: 4, name: "TARGET_TYPE_FIELD" },
        { no: 5, name: "TARGET_TYPE_ONEOF" },
        { no: 6, name: "TARGET_TYPE_ENUM" },
        { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
        { no: 8, name: "TARGET_TYPE_SERVICE" },
        { no: 9, name: "TARGET_TYPE_METHOD" }
      ]);
      OneofOptions = class _OneofOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _OneofOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _OneofOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _OneofOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_OneofOptions, a, b);
        }
      };
      OneofOptions.runtime = proto2;
      OneofOptions.typeName = "google.protobuf.OneofOptions";
      OneofOptions.fields = proto2.util.newFieldList(() => [
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      EnumOptions = class _EnumOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumOptions, a, b);
        }
      };
      EnumOptions.runtime = proto2;
      EnumOptions.typeName = "google.protobuf.EnumOptions";
      EnumOptions.fields = proto2.util.newFieldList(() => [
        { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      EnumValueOptions = class _EnumValueOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValueOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValueOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValueOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumValueOptions, a, b);
        }
      };
      EnumValueOptions.runtime = proto2;
      EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
      EnumValueOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      ServiceOptions = class _ServiceOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ServiceOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ServiceOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ServiceOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ServiceOptions, a, b);
        }
      };
      ServiceOptions.runtime = proto2;
      ServiceOptions.typeName = "google.protobuf.ServiceOptions";
      ServiceOptions.fields = proto2.util.newFieldList(() => [
        { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      MethodOptions = class _MethodOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MethodOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MethodOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MethodOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MethodOptions, a, b);
        }
      };
      MethodOptions.runtime = proto2;
      MethodOptions.typeName = "google.protobuf.MethodOptions";
      MethodOptions.fields = proto2.util.newFieldList(() => [
        { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 34, name: "idempotency_level", kind: "enum", T: proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(MethodOptions_IdempotencyLevel2) {
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
      })(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
      proto2.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
        { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
        { no: 1, name: "NO_SIDE_EFFECTS" },
        { no: 2, name: "IDEMPOTENT" }
      ]);
      UninterpretedOption = class _UninterpretedOption extends Message {
        constructor(data) {
          super();
          this.name = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UninterpretedOption().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UninterpretedOption().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UninterpretedOption().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_UninterpretedOption, a, b);
        }
      };
      UninterpretedOption.runtime = proto2;
      UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
      UninterpretedOption.fields = proto2.util.newFieldList(() => [
        { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
        { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
        { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
        { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
        { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
        { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
      ]);
      UninterpretedOption_NamePart = class _UninterpretedOption_NamePart extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UninterpretedOption_NamePart().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UninterpretedOption_NamePart().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UninterpretedOption_NamePart().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_UninterpretedOption_NamePart, a, b);
        }
      };
      UninterpretedOption_NamePart.runtime = proto2;
      UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
      UninterpretedOption_NamePart.fields = proto2.util.newFieldList(() => [
        {
          no: 1,
          name: "name_part",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "is_extension",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
      SourceCodeInfo = class _SourceCodeInfo extends Message {
        constructor(data) {
          super();
          this.location = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceCodeInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceCodeInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceCodeInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_SourceCodeInfo, a, b);
        }
      };
      SourceCodeInfo.runtime = proto2;
      SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
      SourceCodeInfo.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
      ]);
      SourceCodeInfo_Location = class _SourceCodeInfo_Location extends Message {
        constructor(data) {
          super();
          this.path = [];
          this.span = [];
          this.leadingDetachedComments = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceCodeInfo_Location().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceCodeInfo_Location().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceCodeInfo_Location().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_SourceCodeInfo_Location, a, b);
        }
      };
      SourceCodeInfo_Location.runtime = proto2;
      SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
      SourceCodeInfo_Location.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
      ]);
      GeneratedCodeInfo = class _GeneratedCodeInfo extends Message {
        constructor(data) {
          super();
          this.annotation = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _GeneratedCodeInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _GeneratedCodeInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _GeneratedCodeInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_GeneratedCodeInfo, a, b);
        }
      };
      GeneratedCodeInfo.runtime = proto2;
      GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
      GeneratedCodeInfo.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
      ]);
      GeneratedCodeInfo_Annotation = class _GeneratedCodeInfo_Annotation extends Message {
        constructor(data) {
          super();
          this.path = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _GeneratedCodeInfo_Annotation().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_GeneratedCodeInfo_Annotation, a, b);
        }
      };
      GeneratedCodeInfo_Annotation.runtime = proto2;
      GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
      GeneratedCodeInfo_Annotation.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
        { no: 5, name: "semantic", kind: "enum", T: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
      ]);
      (function(GeneratedCodeInfo_Annotation_Semantic2) {
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
      })(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
      proto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
        { no: 0, name: "NONE" },
        { no: 1, name: "SET" },
        { no: 2, name: "ALIAS" }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js
  function createDescriptorSet(input) {
    const cart = {
      enums: /* @__PURE__ */ new Map(),
      messages: /* @__PURE__ */ new Map(),
      services: /* @__PURE__ */ new Map(),
      extensions: /* @__PURE__ */ new Map(),
      mapEntries: /* @__PURE__ */ new Map()
    };
    const fileDescriptors = input instanceof FileDescriptorSet ? input.file : input instanceof Uint8Array ? FileDescriptorSet.fromBinary(input).file : input;
    const files = fileDescriptors.map((proto) => newFile(proto, cart));
    return Object.assign({ files }, cart);
  }
  function newFile(proto, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid FileDescriptorProto: missing name`);
    assert(proto.syntax === void 0 || proto.syntax === "proto3", `invalid FileDescriptorProto: unsupported syntax: ${(_a = proto.syntax) !== null && _a !== void 0 ? _a : "undefined"}`);
    const file = {
      kind: "file",
      proto,
      deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,
      syntax: proto.syntax === "proto3" ? "proto3" : "proto2",
      name: proto.name.replace(/\.proto/, ""),
      enums: [],
      messages: [],
      extensions: [],
      services: [],
      toString() {
        return `file ${this.proto.name}`;
      },
      getSyntaxComments() {
        return findComments(this.proto.sourceCodeInfo, [
          FieldNumber.FileDescriptorProto_Syntax
        ]);
      },
      getPackageComments() {
        return findComments(this.proto.sourceCodeInfo, [
          FieldNumber.FileDescriptorProto_Package
        ]);
      }
    };
    cart.mapEntries.clear();
    for (const enumProto of proto.enumType) {
      addEnum(enumProto, file, void 0, cart);
    }
    for (const messageProto of proto.messageType) {
      addMessage(messageProto, file, void 0, cart);
    }
    for (const serviceProto of proto.service) {
      addService(serviceProto, file, cart);
    }
    addExtensions(file, cart);
    for (const mapEntry of cart.mapEntries.values()) {
      addFields(mapEntry, cart);
    }
    for (const message of file.messages) {
      addFields(message, cart);
      addExtensions(message, cart);
    }
    cart.mapEntries.clear();
    return file;
  }
  function addExtensions(desc, cart) {
    switch (desc.kind) {
      case "file":
        for (const proto of desc.proto.extension) {
          const ext = newExtension(proto, desc, void 0, cart);
          desc.extensions.push(ext);
          cart.extensions.set(ext.typeName, ext);
        }
        break;
      case "message":
        for (const proto of desc.proto.extension) {
          const ext = newExtension(proto, desc.file, desc, cart);
          desc.nestedExtensions.push(ext);
          cart.extensions.set(ext.typeName, ext);
        }
        for (const message of desc.nestedMessages) {
          addExtensions(message, cart);
        }
        break;
    }
  }
  function addFields(message, cart) {
    const allOneofs = message.proto.oneofDecl.map((proto) => newOneof(proto, message));
    const oneofsSeen = /* @__PURE__ */ new Set();
    for (const proto of message.proto.field) {
      const oneof = findOneof(proto, allOneofs);
      const field = newField(proto, message.file, message, oneof, cart);
      message.fields.push(field);
      if (oneof === void 0) {
        message.members.push(field);
      } else {
        oneof.fields.push(field);
        if (!oneofsSeen.has(oneof)) {
          oneofsSeen.add(oneof);
          message.members.push(oneof);
        }
      }
    }
    for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {
      message.oneofs.push(oneof);
    }
    for (const child of message.nestedMessages) {
      addFields(child, cart);
    }
  }
  function addEnum(proto, file, parent, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid EnumDescriptorProto: missing name`);
    const desc = {
      kind: "enum",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      parent,
      name: proto.name,
      typeName: makeTypeName(proto, parent, file),
      values: [],
      sharedPrefix: findEnumSharedPrefix(proto.name, proto.value.map((v) => {
        var _a2;
        return (_a2 = v.name) !== null && _a2 !== void 0 ? _a2 : "";
      })),
      toString() {
        return `enum ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_EnumType,
          this.parent.proto.enumType.indexOf(this.proto)
        ] : [
          FieldNumber.FileDescriptorProto_EnumType,
          this.file.proto.enumType.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    cart.enums.set(desc.typeName, desc);
    proto.value.forEach((proto4) => {
      var _a2, _b2;
      assert(proto4.name, `invalid EnumValueDescriptorProto: missing name`);
      assert(proto4.number !== void 0, `invalid EnumValueDescriptorProto: missing number`);
      desc.values.push({
        kind: "enum_value",
        proto: proto4,
        deprecated: (_b2 = (_a2 = proto4.options) === null || _a2 === void 0 ? void 0 : _a2.deprecated) !== null && _b2 !== void 0 ? _b2 : false,
        parent: desc,
        name: proto4.name,
        number: proto4.number,
        toString() {
          return `enum value ${desc.typeName}.${this.name}`;
        },
        declarationString() {
          var _a3;
          let str = `${this.name} = ${this.number}`;
          if (((_a3 = this.proto.options) === null || _a3 === void 0 ? void 0 : _a3.deprecated) === true) {
            str += " [deprecated = true]";
          }
          return str;
        },
        getComments() {
          const path = [
            ...this.parent.getComments().sourcePath,
            FieldNumber.EnumDescriptorProto_Value,
            this.parent.proto.value.indexOf(this.proto)
          ];
          return findComments(file.proto.sourceCodeInfo, path);
        }
      });
    });
    ((_c = parent === null || parent === void 0 ? void 0 : parent.nestedEnums) !== null && _c !== void 0 ? _c : file.enums).push(desc);
  }
  function addMessage(proto, file, parent, cart) {
    var _a, _b, _c, _d;
    assert(proto.name, `invalid DescriptorProto: missing name`);
    const desc = {
      kind: "message",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      parent,
      name: proto.name,
      typeName: makeTypeName(proto, parent, file),
      fields: [],
      oneofs: [],
      members: [],
      nestedEnums: [],
      nestedMessages: [],
      nestedExtensions: [],
      toString() {
        return `message ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_NestedType,
          this.parent.proto.nestedType.indexOf(this.proto)
        ] : [
          FieldNumber.FileDescriptorProto_MessageType,
          this.file.proto.messageType.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    if (((_c = proto.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) {
      cart.mapEntries.set(desc.typeName, desc);
    } else {
      ((_d = parent === null || parent === void 0 ? void 0 : parent.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);
      cart.messages.set(desc.typeName, desc);
    }
    for (const enumProto of proto.enumType) {
      addEnum(enumProto, file, desc, cart);
    }
    for (const messageProto of proto.nestedType) {
      addMessage(messageProto, file, desc, cart);
    }
  }
  function addService(proto, file, cart) {
    var _a, _b;
    assert(proto.name, `invalid ServiceDescriptorProto: missing name`);
    const desc = {
      kind: "service",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      name: proto.name,
      typeName: makeTypeName(proto, void 0, file),
      methods: [],
      toString() {
        return `service ${this.typeName}`;
      },
      getComments() {
        const path = [
          FieldNumber.FileDescriptorProto_Service,
          this.file.proto.service.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    file.services.push(desc);
    cart.services.set(desc.typeName, desc);
    for (const methodProto of proto.method) {
      desc.methods.push(newMethod(methodProto, desc, cart));
    }
  }
  function newMethod(proto, parent, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid MethodDescriptorProto: missing name`);
    assert(proto.inputType, `invalid MethodDescriptorProto: missing input_type`);
    assert(proto.outputType, `invalid MethodDescriptorProto: missing output_type`);
    let methodKind;
    if (proto.clientStreaming === true && proto.serverStreaming === true) {
      methodKind = MethodKind.BiDiStreaming;
    } else if (proto.clientStreaming === true) {
      methodKind = MethodKind.ClientStreaming;
    } else if (proto.serverStreaming === true) {
      methodKind = MethodKind.ServerStreaming;
    } else {
      methodKind = MethodKind.Unary;
    }
    let idempotency;
    switch ((_a = proto.options) === null || _a === void 0 ? void 0 : _a.idempotencyLevel) {
      case MethodOptions_IdempotencyLevel.IDEMPOTENT:
        idempotency = MethodIdempotency.Idempotent;
        break;
      case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
        idempotency = MethodIdempotency.NoSideEffects;
        break;
      case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
      case void 0:
        idempotency = void 0;
        break;
    }
    const input = cart.messages.get(trimLeadingDot(proto.inputType));
    const output = cart.messages.get(trimLeadingDot(proto.outputType));
    assert(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);
    assert(output, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);
    const name = proto.name;
    return {
      kind: "rpc",
      proto,
      deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,
      parent,
      name,
      methodKind,
      input,
      output,
      idempotency,
      toString() {
        return `rpc ${parent.typeName}.${name}`;
      },
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.ServiceDescriptorProto_Method,
          this.parent.proto.method.indexOf(this.proto)
        ];
        return findComments(parent.file.proto.sourceCodeInfo, path);
      }
    };
  }
  function newOneof(proto, parent) {
    assert(proto.name, `invalid OneofDescriptorProto: missing name`);
    return {
      kind: "oneof",
      proto,
      deprecated: false,
      parent,
      fields: [],
      name: proto.name,
      toString() {
        return `oneof ${parent.typeName}.${this.name}`;
      },
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_OneofDecl,
          this.parent.proto.oneofDecl.indexOf(this.proto)
        ];
        return findComments(parent.file.proto.sourceCodeInfo, path);
      }
    };
  }
  function newField(proto, file, parent, oneof, cart) {
    var _a, _b, _c, _d;
    assert(proto.name, `invalid FieldDescriptorProto: missing name`);
    assert(proto.number, `invalid FieldDescriptorProto: missing number`);
    assert(proto.type, `invalid FieldDescriptorProto: missing type`);
    const packedByDefault = isPackedFieldByDefault(proto, file.syntax);
    const common = {
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      name: proto.name,
      number: proto.number,
      parent,
      oneof,
      optional: isOptionalField(proto, file.syntax),
      packed: (_d = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.packed) !== null && _d !== void 0 ? _d : packedByDefault,
      packedByDefault,
      jsonName: proto.jsonName === fieldJsonName(proto.name) ? void 0 : proto.jsonName,
      scalar: void 0,
      message: void 0,
      enum: void 0,
      mapKey: void 0,
      mapValue: void 0,
      toString() {
        return `field ${this.parent.typeName}.${this.name}`;
      },
      declarationString,
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_Field,
          this.parent.proto.field.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    const repeated = proto.label === FieldDescriptorProto_Label.REPEATED;
    switch (proto.type) {
      case FieldDescriptorProto_Type.MESSAGE:
      case FieldDescriptorProto_Type.GROUP: {
        assert(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
        const mapEntry = cart.mapEntries.get(trimLeadingDot(proto.typeName));
        if (mapEntry !== void 0) {
          assert(repeated, `invalid FieldDescriptorProto: expected map entry to be repeated`);
          return Object.assign(Object.assign(Object.assign({}, common), { kind: "field", fieldKind: "map", repeated: false }), getMapFieldTypes(mapEntry));
        }
        const message = cart.messages.get(trimLeadingDot(proto.typeName));
        assert(message !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "message",
          repeated,
          message
        });
      }
      case FieldDescriptorProto_Type.ENUM: {
        assert(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
        const e = cart.enums.get(trimLeadingDot(proto.typeName));
        assert(e !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "enum",
          getDefaultValue,
          repeated,
          enum: e
        });
      }
      default: {
        const scalar = fieldTypeToScalarType[proto.type];
        assert(scalar, `invalid FieldDescriptorProto: unknown type ${proto.type}`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "scalar",
          getDefaultValue,
          repeated,
          scalar
        });
      }
    }
  }
  function newExtension(proto, file, parent, cart) {
    assert(proto.extendee, `invalid FieldDescriptorProto: missing extendee`);
    const field = newField(
      proto,
      file,
      null,
      // to safe us many lines of duplicated code, we trick the type system
      void 0,
      cart
    );
    const extendee = cart.messages.get(trimLeadingDot(proto.extendee));
    assert(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);
    return Object.assign(Object.assign({}, field), {
      kind: "extension",
      typeName: makeTypeName(proto, parent, file),
      parent,
      file,
      extendee,
      toString() {
        return `extension ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_Extension,
          this.parent.proto.extension.indexOf(proto)
        ] : [
          FieldNumber.FileDescriptorProto_Extension,
          this.file.proto.extension.indexOf(proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    });
  }
  function makeTypeName(proto, parent, file) {
    assert(proto.name, `invalid ${proto.getType().typeName}: missing name`);
    let typeName;
    if (parent) {
      typeName = `${parent.typeName}.${proto.name}`;
    } else if (file.proto.package !== void 0) {
      typeName = `${file.proto.package}.${proto.name}`;
    } else {
      typeName = `${proto.name}`;
    }
    return typeName;
  }
  function trimLeadingDot(typeName) {
    return typeName.startsWith(".") ? typeName.substring(1) : typeName;
  }
  function getMapFieldTypes(mapEntry) {
    var _a, _b;
    assert((_a = mapEntry.proto.options) === null || _a === void 0 ? void 0 : _a.mapEntry, `invalid DescriptorProto: expected ${mapEntry.toString()} to be a map entry`);
    assert(mapEntry.fields.length === 2, `invalid DescriptorProto: map entry ${mapEntry.toString()} has ${mapEntry.fields.length} fields`);
    const keyField = mapEntry.fields.find((f) => f.proto.number === 1);
    assert(keyField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing key field`);
    const mapKey = keyField.scalar;
    assert(mapKey !== void 0 && mapKey !== ScalarType.BYTES && mapKey !== ScalarType.FLOAT && mapKey !== ScalarType.DOUBLE, `invalid DescriptorProto: map entry ${mapEntry.toString()} has unexpected key type ${(_b = keyField.proto.type) !== null && _b !== void 0 ? _b : -1}`);
    const valueField = mapEntry.fields.find((f) => f.proto.number === 2);
    assert(valueField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing value field`);
    switch (valueField.fieldKind) {
      case "scalar":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "scalar" })
        };
      case "message":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "message" })
        };
      case "enum":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "enum" })
        };
      default:
        throw new Error("invalid DescriptorProto: unsupported map entry value field");
    }
  }
  function findOneof(proto, allOneofs) {
    var _a;
    const oneofIndex = proto.oneofIndex;
    if (oneofIndex === void 0) {
      return void 0;
    }
    let oneof;
    if (proto.proto3Optional !== true) {
      oneof = allOneofs[oneofIndex];
      assert(oneof, `invalid FieldDescriptorProto: oneof #${oneofIndex} for field #${(_a = proto.number) !== null && _a !== void 0 ? _a : -1} not found`);
    }
    return oneof;
  }
  function isOptionalField(proto, syntax) {
    switch (syntax) {
      case "proto2":
        return proto.oneofIndex === void 0 && proto.label === FieldDescriptorProto_Label.OPTIONAL;
      case "proto3":
        return proto.proto3Optional === true;
    }
  }
  function isPackedFieldByDefault(proto, syntax) {
    assert(proto.type, `invalid FieldDescriptorProto: missing type`);
    if (syntax === "proto3") {
      switch (proto.type) {
        case FieldDescriptorProto_Type.DOUBLE:
        case FieldDescriptorProto_Type.FLOAT:
        case FieldDescriptorProto_Type.INT64:
        case FieldDescriptorProto_Type.UINT64:
        case FieldDescriptorProto_Type.INT32:
        case FieldDescriptorProto_Type.FIXED64:
        case FieldDescriptorProto_Type.FIXED32:
        case FieldDescriptorProto_Type.UINT32:
        case FieldDescriptorProto_Type.SFIXED32:
        case FieldDescriptorProto_Type.SFIXED64:
        case FieldDescriptorProto_Type.SINT32:
        case FieldDescriptorProto_Type.SINT64:
        case FieldDescriptorProto_Type.BOOL:
        case FieldDescriptorProto_Type.ENUM:
          return true;
        default:
          return false;
      }
    }
    return false;
  }
  function findComments(sourceCodeInfo, sourcePath) {
    if (!sourceCodeInfo) {
      return {
        leadingDetached: [],
        sourcePath
      };
    }
    for (const location of sourceCodeInfo.location) {
      if (location.path.length !== sourcePath.length) {
        continue;
      }
      if (location.path.some((value, index) => sourcePath[index] !== value)) {
        continue;
      }
      return {
        leadingDetached: location.leadingDetachedComments,
        leading: location.leadingComments,
        trailing: location.trailingComments,
        sourcePath
      };
    }
    return {
      leadingDetached: [],
      sourcePath
    };
  }
  function declarationString() {
    var _a, _b;
    const parts = [];
    if (this.repeated) {
      parts.push("repeated");
    }
    if (this.optional) {
      parts.push("optional");
    }
    const file = this.kind === "extension" ? this.file : this.parent.file;
    if (file.syntax == "proto2" && this.proto.label === FieldDescriptorProto_Label.REQUIRED) {
      parts.push("required");
    }
    let type;
    switch (this.fieldKind) {
      case "scalar":
        type = ScalarType[this.scalar].toLowerCase();
        break;
      case "enum":
        type = this.enum.typeName;
        break;
      case "message":
        type = this.message.typeName;
        break;
      case "map": {
        const k = ScalarType[this.mapKey].toLowerCase();
        let v;
        switch (this.mapValue.kind) {
          case "scalar":
            v = ScalarType[this.mapValue.scalar].toLowerCase();
            break;
          case "enum":
            v = this.mapValue.enum.typeName;
            break;
          case "message":
            v = this.mapValue.message.typeName;
            break;
        }
        type = `map<${k}, ${v}>`;
        break;
      }
    }
    parts.push(`${type} ${this.name} = ${this.number}`);
    const options = [];
    if (((_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== void 0) {
      options.push(`packed = ${this.proto.options.packed.toString()}`);
    }
    let defaultValue = this.proto.defaultValue;
    if (defaultValue !== void 0) {
      if (this.proto.type == FieldDescriptorProto_Type.BYTES || this.proto.type == FieldDescriptorProto_Type.STRING) {
        defaultValue = '"' + defaultValue.replace('"', '\\"') + '"';
      }
      options.push(`default = ${defaultValue}`);
    }
    if (this.jsonName !== void 0) {
      options.push(`json_name = "${this.jsonName}"`);
    }
    if (((_b = this.proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) === true) {
      options.push(`deprecated = true`);
    }
    if (options.length > 0) {
      parts.push("[" + options.join(", ") + "]");
    }
    return parts.join(" ");
  }
  function getDefaultValue() {
    const d = this.proto.defaultValue;
    if (d === void 0) {
      return void 0;
    }
    switch (this.fieldKind) {
      case "enum": {
        const enumValue = this.enum.values.find((v) => v.name === d);
        assert(enumValue, `cannot parse ${this.toString()} default value: ${d}`);
        return enumValue.number;
      }
      case "scalar":
        switch (this.scalar) {
          case ScalarType.STRING:
            return d;
          case ScalarType.BYTES: {
            const u = unescapeBytesDefaultValue(d);
            if (u === false) {
              throw new Error(`cannot parse ${this.toString()} default value: ${d}`);
            }
            return u;
          }
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            return protoInt64.parse(d);
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
            return protoInt64.uParse(d);
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
            switch (d) {
              case "inf":
                return Number.POSITIVE_INFINITY;
              case "-inf":
                return Number.NEGATIVE_INFINITY;
              case "nan":
                return Number.NaN;
              default:
                return parseFloat(d);
            }
          case ScalarType.BOOL:
            return d === "true";
          case ScalarType.INT32:
          case ScalarType.UINT32:
          case ScalarType.SINT32:
          case ScalarType.FIXED32:
          case ScalarType.SFIXED32:
            return parseInt(d, 10);
        }
        break;
      default:
        return void 0;
    }
  }
  function unescapeBytesDefaultValue(str) {
    const b = [];
    const input = {
      tail: str,
      c: "",
      next() {
        if (this.tail.length == 0) {
          return false;
        }
        this.c = this.tail[0];
        this.tail = this.tail.substring(1);
        return true;
      },
      take(n) {
        if (this.tail.length >= n) {
          const r = this.tail.substring(0, n);
          this.tail = this.tail.substring(n);
          return r;
        }
        return false;
      }
    };
    while (input.next()) {
      switch (input.c) {
        case "\\":
          if (input.next()) {
            switch (input.c) {
              case "\\":
                b.push(input.c.charCodeAt(0));
                break;
              case "b":
                b.push(8);
                break;
              case "f":
                b.push(12);
                break;
              case "n":
                b.push(10);
                break;
              case "r":
                b.push(13);
                break;
              case "t":
                b.push(9);
                break;
              case "v":
                b.push(11);
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7": {
                const s = input.c;
                const t = input.take(2);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 8);
                if (isNaN(n)) {
                  return false;
                }
                b.push(n);
                break;
              }
              case "x": {
                const s = input.c;
                const t = input.take(2);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 16);
                if (isNaN(n)) {
                  return false;
                }
                b.push(n);
                break;
              }
              case "u": {
                const s = input.c;
                const t = input.take(4);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 16);
                if (isNaN(n)) {
                  return false;
                }
                const chunk = new Uint8Array(4);
                const view = new DataView(chunk.buffer);
                view.setInt32(0, n, true);
                b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
                break;
              }
              case "U": {
                const s = input.c;
                const t = input.take(8);
                if (t === false) {
                  return false;
                }
                const tc = protoInt64.uEnc(s + t);
                const chunk = new Uint8Array(8);
                const view = new DataView(chunk.buffer);
                view.setInt32(0, tc.lo, true);
                view.setInt32(4, tc.hi, true);
                b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
                break;
              }
            }
          }
          break;
        default:
          b.push(input.c.charCodeAt(0));
      }
    }
    return new Uint8Array(b);
  }
  var fieldTypeToScalarType, FieldNumber;
  var init_create_descriptor_set = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js"() {
      "use strict";
      init_descriptor_pb();
      init_assert();
      init_field();
      init_service_type();
      init_names();
      init_proto_int64();
      fieldTypeToScalarType = {
        [FieldDescriptorProto_Type.DOUBLE]: ScalarType.DOUBLE,
        [FieldDescriptorProto_Type.FLOAT]: ScalarType.FLOAT,
        [FieldDescriptorProto_Type.INT64]: ScalarType.INT64,
        [FieldDescriptorProto_Type.UINT64]: ScalarType.UINT64,
        [FieldDescriptorProto_Type.INT32]: ScalarType.INT32,
        [FieldDescriptorProto_Type.FIXED64]: ScalarType.FIXED64,
        [FieldDescriptorProto_Type.FIXED32]: ScalarType.FIXED32,
        [FieldDescriptorProto_Type.BOOL]: ScalarType.BOOL,
        [FieldDescriptorProto_Type.STRING]: ScalarType.STRING,
        [FieldDescriptorProto_Type.GROUP]: void 0,
        [FieldDescriptorProto_Type.MESSAGE]: void 0,
        [FieldDescriptorProto_Type.BYTES]: ScalarType.BYTES,
        [FieldDescriptorProto_Type.UINT32]: ScalarType.UINT32,
        [FieldDescriptorProto_Type.ENUM]: void 0,
        [FieldDescriptorProto_Type.SFIXED32]: ScalarType.SFIXED32,
        [FieldDescriptorProto_Type.SFIXED64]: ScalarType.SFIXED64,
        [FieldDescriptorProto_Type.SINT32]: ScalarType.SINT32,
        [FieldDescriptorProto_Type.SINT64]: ScalarType.SINT64
      };
      (function(FieldNumber2) {
        FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
        FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
        FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
        FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
        FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
        FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
        FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
        FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
        FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
        FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
      })(FieldNumber || (FieldNumber = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-registry.js
  function createRegistry(...types) {
    const messages = {};
    const enums = {};
    const services = {};
    const registry = {
      /**
       * Add a type to the registry. For messages, the types used in message
       * fields are added recursively. For services, the message types used
       * for requests and responses are added recursively.
       */
      add(type) {
        if ("fields" in type) {
          if (!this.findMessage(type.typeName)) {
            messages[type.typeName] = type;
            for (const field of type.fields.list()) {
              if (field.kind == "message") {
                this.add(field.T);
              } else if (field.kind == "map" && field.V.kind == "message") {
                this.add(field.V.T);
              } else if (field.kind == "enum") {
                this.add(field.T);
              }
            }
          }
        } else if ("methods" in type) {
          if (!this.findService(type.typeName)) {
            services[type.typeName] = type;
            for (const method of Object.values(type.methods)) {
              this.add(method.I);
              this.add(method.O);
            }
          }
        } else {
          enums[type.typeName] = type;
        }
      },
      findMessage(typeName) {
        return messages[typeName];
      },
      findEnum(typeName) {
        return enums[typeName];
      },
      findService(typeName) {
        return services[typeName];
      }
    };
    for (const type of types) {
      registry.add(type);
    }
    return registry;
  }
  var init_create_registry = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-registry.js"() {
      "use strict";
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js
  var Timestamp;
  var init_timestamp_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js"() {
      "use strict";
      init_message();
      init_proto_int64();
      init_proto3();
      Timestamp = class _Timestamp extends Message {
        constructor(data) {
          super();
          this.seconds = protoInt64.zero;
          this.nanos = 0;
          proto3.util.initPartial(data, this);
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
          }
          const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
          if (!matches) {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
          }
          const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
          if (Number.isNaN(ms)) {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
          }
          if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
            throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
          }
          this.seconds = protoInt64.parse(ms / 1e3);
          this.nanos = 0;
          if (matches[7]) {
            this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
          }
          return this;
        }
        toJson(options) {
          const ms = Number(this.seconds) * 1e3;
          if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
          }
          if (this.nanos < 0) {
            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
          }
          let z2 = "Z";
          if (this.nanos > 0) {
            const nanosStr = (this.nanos + 1e9).toString().substring(1);
            if (nanosStr.substring(3) === "000000") {
              z2 = "." + nanosStr.substring(0, 3) + "Z";
            } else if (nanosStr.substring(6) === "000") {
              z2 = "." + nanosStr.substring(0, 6) + "Z";
            } else {
              z2 = "." + nanosStr + "Z";
            }
          }
          return new Date(ms).toISOString().replace(".000Z", z2);
        }
        toDate() {
          return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
        }
        static now() {
          return _Timestamp.fromDate(/* @__PURE__ */ new Date());
        }
        static fromDate(date) {
          const ms = date.getTime();
          return new _Timestamp({
            seconds: protoInt64.parse(Math.floor(ms / 1e3)),
            nanos: ms % 1e3 * 1e6
          });
        }
        static fromBinary(bytes, options) {
          return new _Timestamp().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Timestamp().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Timestamp().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Timestamp, a, b);
        }
      };
      Timestamp.runtime = proto3;
      Timestamp.typeName = "google.protobuf.Timestamp";
      Timestamp.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js
  var Duration;
  var init_duration_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js"() {
      "use strict";
      init_message();
      init_proto_int64();
      init_proto3();
      Duration = class _Duration extends Message {
        constructor(data) {
          super();
          this.seconds = protoInt64.zero;
          this.nanos = 0;
          proto3.util.initPartial(data, this);
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
          if (match === null) {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          const longSeconds = Number(match[1]);
          if (longSeconds > 315576e6 || longSeconds < -315576e6) {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          this.seconds = protoInt64.parse(longSeconds);
          if (typeof match[2] == "string") {
            const nanosStr = match[2] + "0".repeat(9 - match[2].length);
            this.nanos = parseInt(nanosStr);
            if (longSeconds < 0 || Object.is(longSeconds, -0)) {
              this.nanos = -this.nanos;
            }
          }
          return this;
        }
        toJson(options) {
          if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
            throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
          }
          let text = this.seconds.toString();
          if (this.nanos !== 0) {
            let nanosStr = Math.abs(this.nanos).toString();
            nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
            if (nanosStr.substring(3) === "000000") {
              nanosStr = nanosStr.substring(0, 3);
            } else if (nanosStr.substring(6) === "000") {
              nanosStr = nanosStr.substring(0, 6);
            }
            text += "." + nanosStr;
            if (this.nanos < 0 && this.seconds === protoInt64.zero) {
              text = "-" + text;
            }
          }
          return text + "s";
        }
        static fromBinary(bytes, options) {
          return new _Duration().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Duration().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Duration().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Duration, a, b);
        }
      };
      Duration.runtime = proto3;
      Duration.typeName = "google.protobuf.Duration";
      Duration.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js
  var Any;
  var init_any_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      Any = class _Any extends Message {
        constructor(data) {
          super();
          this.typeUrl = "";
          this.value = new Uint8Array(0);
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          var _a;
          if (this.typeUrl === "") {
            return {};
          }
          const typeName = this.typeUrlToName(this.typeUrl);
          const messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
          if (!messageType) {
            throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
          }
          const message = messageType.fromBinary(this.value);
          let json = message.toJson(options);
          if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
            json = { value: json };
          }
          json["@type"] = this.typeUrl;
          return json;
        }
        fromJson(json, options) {
          var _a;
          if (json === null || Array.isArray(json) || typeof json != "object") {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
          }
          if (Object.keys(json).length == 0) {
            return this;
          }
          const typeUrl = json["@type"];
          if (typeof typeUrl != "string" || typeUrl == "") {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
          }
          const typeName = this.typeUrlToName(typeUrl), messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
          if (!messageType) {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
          }
          let message;
          if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
            message = messageType.fromJson(json["value"], options);
          } else {
            const copy = Object.assign({}, json);
            delete copy["@type"];
            message = messageType.fromJson(copy, options);
          }
          this.packFrom(message);
          return this;
        }
        packFrom(message) {
          this.value = message.toBinary();
          this.typeUrl = this.typeNameToUrl(message.getType().typeName);
        }
        unpackTo(target) {
          if (!this.is(target.getType())) {
            return false;
          }
          target.fromBinary(this.value);
          return true;
        }
        unpack(registry) {
          if (this.typeUrl === "") {
            return void 0;
          }
          const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
          if (!messageType) {
            return void 0;
          }
          return messageType.fromBinary(this.value);
        }
        is(type) {
          if (this.typeUrl === "") {
            return false;
          }
          const name = this.typeUrlToName(this.typeUrl);
          let typeName = "";
          if (typeof type === "string") {
            typeName = type;
          } else {
            typeName = type.typeName;
          }
          return name === typeName;
        }
        typeNameToUrl(name) {
          return `type.googleapis.com/${name}`;
        }
        typeUrlToName(url) {
          if (!url.length) {
            throw new Error(`invalid type url: ${url}`);
          }
          const slash = url.lastIndexOf("/");
          const name = slash > 0 ? url.substring(slash + 1) : url;
          if (!name.length) {
            throw new Error(`invalid type url: ${url}`);
          }
          return name;
        }
        static pack(message) {
          const any = new _Any();
          any.packFrom(message);
          return any;
        }
        static fromBinary(bytes, options) {
          return new _Any().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Any().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Any().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Any, a, b);
        }
      };
      Any.runtime = proto3;
      Any.typeName = "google.protobuf.Any";
      Any.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "value",
          kind: "scalar",
          T: 12
          /* ScalarType.BYTES */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js
  var Empty;
  var init_empty_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      Empty = class _Empty extends Message {
        constructor(data) {
          super();
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Empty().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Empty().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Empty().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Empty, a, b);
        }
      };
      Empty.runtime = proto3;
      Empty.typeName = "google.protobuf.Empty";
      Empty.fields = proto3.util.newFieldList(() => []);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js
  var FieldMask;
  var init_field_mask_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      FieldMask = class _FieldMask extends Message {
        constructor(data) {
          super();
          this.paths = [];
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          function protoCamelCase2(snakeCase) {
            let capNext = false;
            const b = [];
            for (let i = 0; i < snakeCase.length; i++) {
              let c = snakeCase.charAt(i);
              switch (c) {
                case "_":
                  capNext = true;
                  break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                  b.push(c);
                  capNext = false;
                  break;
                default:
                  if (capNext) {
                    capNext = false;
                    c = c.toUpperCase();
                  }
                  b.push(c);
                  break;
              }
            }
            return b.join("");
          }
          return this.paths.map((p) => {
            if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
              throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
            }
            return protoCamelCase2(p);
          }).join(",");
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto3.json.debug(json));
          }
          if (json === "") {
            return this;
          }
          function camelToSnake(str) {
            if (str.includes("_")) {
              throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
            }
            const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
            return sc[0] === "_" ? sc.substring(1) : sc;
          }
          this.paths = json.split(",").map(camelToSnake);
          return this;
        }
        static fromBinary(bytes, options) {
          return new _FieldMask().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldMask().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldMask().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_FieldMask, a, b);
        }
      };
      FieldMask.runtime = proto3;
      FieldMask.typeName = "google.protobuf.FieldMask";
      FieldMask.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js
  var NullValue, Struct, Value, ListValue;
  var init_struct_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js"() {
      "use strict";
      init_proto3();
      init_message();
      (function(NullValue2) {
        NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
      })(NullValue || (NullValue = {}));
      proto3.util.setEnumType(NullValue, "google.protobuf.NullValue", [
        { no: 0, name: "NULL_VALUE" }
      ]);
      Struct = class _Struct extends Message {
        constructor(data) {
          super();
          this.fields = {};
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          const json = {};
          for (const [k, v] of Object.entries(this.fields)) {
            json[k] = v.toJson(options);
          }
          return json;
        }
        fromJson(json, options) {
          if (typeof json != "object" || json == null || Array.isArray(json)) {
            throw new Error("cannot decode google.protobuf.Struct from JSON " + proto3.json.debug(json));
          }
          for (const [k, v] of Object.entries(json)) {
            this.fields[k] = Value.fromJson(v);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Struct().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Struct().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Struct().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Struct, a, b);
        }
      };
      Struct.runtime = proto3;
      Struct.typeName = "google.protobuf.Struct";
      Struct.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value } }
      ]);
      Value = class _Value extends Message {
        constructor(data) {
          super();
          this.kind = { case: void 0 };
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          switch (this.kind.case) {
            case "nullValue":
              return null;
            case "numberValue":
              if (!Number.isFinite(this.kind.value)) {
                throw new Error("google.protobuf.Value cannot be NaN or Infinity");
              }
              return this.kind.value;
            case "boolValue":
              return this.kind.value;
            case "stringValue":
              return this.kind.value;
            case "structValue":
            case "listValue":
              return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
          }
          throw new Error("google.protobuf.Value must have a value");
        }
        fromJson(json, options) {
          switch (typeof json) {
            case "number":
              this.kind = { case: "numberValue", value: json };
              break;
            case "string":
              this.kind = { case: "stringValue", value: json };
              break;
            case "boolean":
              this.kind = { case: "boolValue", value: json };
              break;
            case "object":
              if (json === null) {
                this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
              } else if (Array.isArray(json)) {
                this.kind = { case: "listValue", value: ListValue.fromJson(json) };
              } else {
                this.kind = { case: "structValue", value: Struct.fromJson(json) };
              }
              break;
            default:
              throw new Error("cannot decode google.protobuf.Value from JSON " + proto3.json.debug(json));
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Value, a, b);
        }
      };
      Value.runtime = proto3;
      Value.typeName = "google.protobuf.Value";
      Value.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "kind" },
        { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
        { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
        { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
        { no: 5, name: "struct_value", kind: "message", T: Struct, oneof: "kind" },
        { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
      ]);
      ListValue = class _ListValue extends Message {
        constructor(data) {
          super();
          this.values = [];
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return this.values.map((v) => v.toJson());
        }
        fromJson(json, options) {
          if (!Array.isArray(json)) {
            throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto3.json.debug(json));
          }
          for (let e of json) {
            this.values.push(Value.fromJson(e));
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _ListValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ListValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ListValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_ListValue, a, b);
        }
      };
      ListValue.runtime = proto3;
      ListValue.typeName = "google.protobuf.ListValue";
      ListValue.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "values", kind: "message", T: Value, repeated: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js
  var DoubleValue, FloatValue, Int64Value, UInt64Value, Int32Value, UInt32Value, BoolValue, StringValue, BytesValue;
  var init_wrappers_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      init_field();
      init_proto_int64();
      DoubleValue = class _DoubleValue extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _DoubleValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DoubleValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DoubleValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_DoubleValue, a, b);
        }
      };
      DoubleValue.runtime = proto3;
      DoubleValue.typeName = "google.protobuf.DoubleValue";
      DoubleValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 1
          /* ScalarType.DOUBLE */
        }
      ]);
      DoubleValue.fieldWrapper = {
        wrapField(value) {
          return new DoubleValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      FloatValue = class _FloatValue extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _FloatValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FloatValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FloatValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_FloatValue, a, b);
        }
      };
      FloatValue.runtime = proto3;
      FloatValue.typeName = "google.protobuf.FloatValue";
      FloatValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        }
      ]);
      FloatValue.fieldWrapper = {
        wrapField(value) {
          return new FloatValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      Int64Value = class _Int64Value extends Message {
        constructor(data) {
          super();
          this.value = protoInt64.zero;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.INT64, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Int64Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Int64Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Int64Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Int64Value, a, b);
        }
      };
      Int64Value.runtime = proto3;
      Int64Value.typeName = "google.protobuf.Int64Value";
      Int64Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
      Int64Value.fieldWrapper = {
        wrapField(value) {
          return new Int64Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      UInt64Value = class _UInt64Value extends Message {
        constructor(data) {
          super();
          this.value = protoInt64.zero;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.UINT64, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _UInt64Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UInt64Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UInt64Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_UInt64Value, a, b);
        }
      };
      UInt64Value.runtime = proto3;
      UInt64Value.typeName = "google.protobuf.UInt64Value";
      UInt64Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 4
          /* ScalarType.UINT64 */
        }
      ]);
      UInt64Value.fieldWrapper = {
        wrapField(value) {
          return new UInt64Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      Int32Value = class _Int32Value extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.INT32, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Int32Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Int32Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Int32Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Int32Value, a, b);
        }
      };
      Int32Value.runtime = proto3;
      Int32Value.typeName = "google.protobuf.Int32Value";
      Int32Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
      Int32Value.fieldWrapper = {
        wrapField(value) {
          return new Int32Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      UInt32Value = class _UInt32Value extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.UINT32, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _UInt32Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UInt32Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UInt32Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_UInt32Value, a, b);
        }
      };
      UInt32Value.runtime = proto3;
      UInt32Value.typeName = "google.protobuf.UInt32Value";
      UInt32Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
      UInt32Value.fieldWrapper = {
        wrapField(value) {
          return new UInt32Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      BoolValue = class _BoolValue extends Message {
        constructor(data) {
          super();
          this.value = false;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.BOOL, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _BoolValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _BoolValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _BoolValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_BoolValue, a, b);
        }
      };
      BoolValue.runtime = proto3;
      BoolValue.typeName = "google.protobuf.BoolValue";
      BoolValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
      BoolValue.fieldWrapper = {
        wrapField(value) {
          return new BoolValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      StringValue = class _StringValue extends Message {
        constructor(data) {
          super();
          this.value = "";
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.STRING, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.StringValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _StringValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _StringValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _StringValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_StringValue, a, b);
        }
      };
      StringValue.runtime = proto3;
      StringValue.typeName = "google.protobuf.StringValue";
      StringValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      StringValue.fieldWrapper = {
        wrapField(value) {
          return new StringValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      BytesValue = class _BytesValue extends Message {
        constructor(data) {
          super();
          this.value = new Uint8Array(0);
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.BYTES, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _BytesValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _BytesValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _BytesValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_BytesValue, a, b);
        }
      };
      BytesValue.runtime = proto3;
      BytesValue.typeName = "google.protobuf.BytesValue";
      BytesValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 12
          /* ScalarType.BYTES */
        }
      ]);
      BytesValue.fieldWrapper = {
        wrapField(value) {
          return new BytesValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js
  function createRegistryFromDescriptors(input, replaceWkt = true) {
    const set = input instanceof Uint8Array || input instanceof FileDescriptorSet ? createDescriptorSet(input) : input;
    const enums = {};
    const messages = {};
    const services = {};
    if (replaceWkt) {
      for (const mt of wkMessages) {
        messages[mt.typeName] = mt;
      }
      for (const et of wkEnums) {
        enums[et.typeName] = et;
      }
    }
    return {
      /**
       * May raise an error on invalid descriptors.
       */
      findEnum(typeName) {
        const existing = enums[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.enums.get(typeName);
        if (!desc) {
          return void 0;
        }
        const runtime = desc.file.syntax == "proto3" ? proto3 : proto2;
        const type = runtime.makeEnumType(typeName, desc.values.map((u) => ({
          no: u.number,
          name: u.name,
          localName: localName(u)
        })), {});
        enums[typeName] = type;
        return type;
      },
      /**
       * May raise an error on invalid descriptors.
       */
      findMessage(typeName) {
        const existing = messages[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.messages.get(typeName);
        if (!desc) {
          return void 0;
        }
        const runtime = desc.file.syntax == "proto3" ? proto3 : proto2;
        const fields = [];
        const type = runtime.makeMessageType(typeName, () => fields, {
          localName: localName(desc)
        });
        messages[typeName] = type;
        for (const field of desc.fields) {
          const fieldInfo = makeFieldInfo(field, this);
          fields.push(fieldInfo);
        }
        return type;
      },
      /**
       * May raise an error on invalid descriptors.
       */
      findService(typeName) {
        const existing = services[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.services.get(typeName);
        if (!desc) {
          return void 0;
        }
        const methods = {};
        for (const method of desc.methods) {
          const I = this.findMessage(method.input.typeName);
          const O = this.findMessage(method.output.typeName);
          assert(I, `message "${method.input.typeName}" for ${method.toString()} not found`);
          assert(O, `output message "${method.output.typeName}" for ${method.toString()} not found`);
          methods[localName(method)] = {
            name: method.name,
            I,
            O,
            kind: method.methodKind,
            idempotency: method.idempotency
            // We do not surface options at this time
            // options: {},
          };
        }
        return services[typeName] = {
          typeName: desc.typeName,
          methods
        };
      }
    };
  }
  function makeFieldInfo(desc, resolver) {
    switch (desc.fieldKind) {
      case "map":
        return makeMapFieldInfo(desc, resolver);
      case "message":
        return makeMessageFieldInfo(desc, resolver);
      case "enum": {
        const fi = makeEnumFieldInfo(desc, resolver);
        fi.default = desc.getDefaultValue();
        return fi;
      }
      case "scalar": {
        const fi = makeScalarFieldInfo(desc);
        fi.default = desc.getDefaultValue();
        return fi;
      }
    }
  }
  function makeMapFieldInfo(field, resolver) {
    const base = {
      kind: "map",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      K: field.mapKey
    };
    if (field.mapValue.message) {
      const messageType = resolver.findMessage(field.mapValue.message.typeName);
      assert(messageType, `message "${field.mapValue.message.typeName}" for ${field.toString()} not found`);
      return Object.assign(Object.assign({}, base), { V: {
        kind: "message",
        T: messageType
      } });
    }
    if (field.mapValue.enum) {
      const enumType2 = resolver.findEnum(field.mapValue.enum.typeName);
      assert(enumType2, `enum "${field.mapValue.enum.typeName}" for ${field.toString()} not found`);
      return Object.assign(Object.assign({}, base), { V: {
        kind: "enum",
        T: enumType2
      } });
    }
    return Object.assign(Object.assign({}, base), { V: {
      kind: "scalar",
      T: field.mapValue.scalar
    } });
  }
  function makeScalarFieldInfo(field) {
    const base = {
      kind: "scalar",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: field.scalar
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0, T: field.scalar });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  function makeMessageFieldInfo(field, resolver) {
    const messageType = resolver.findMessage(field.message.typeName);
    assert(messageType, `message "${field.message.typeName}" for ${field.toString()} not found`);
    const base = {
      kind: "message",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: messageType
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0 });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  function makeEnumFieldInfo(field, resolver) {
    const enumType2 = resolver.findEnum(field.enum.typeName);
    assert(enumType2, `enum "${field.enum.typeName}" for ${field.toString()} not found`);
    const base = {
      kind: "enum",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: enumType2
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0 });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  var wkMessages, wkEnums;
  var init_create_registry_from_desc = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js"() {
      "use strict";
      init_assert();
      init_proto3();
      init_proto2();
      init_names();
      init_timestamp_pb();
      init_duration_pb();
      init_any_pb();
      init_empty_pb();
      init_field_mask_pb();
      init_struct_pb();
      init_enum();
      init_wrappers_pb();
      init_descriptor_pb();
      init_create_descriptor_set();
      wkMessages = [
        Any,
        Duration,
        Empty,
        FieldMask,
        Struct,
        Value,
        ListValue,
        Timestamp,
        Duration,
        DoubleValue,
        FloatValue,
        Int64Value,
        Int32Value,
        UInt32Value,
        UInt64Value,
        BoolValue,
        StringValue,
        BytesValue
      ];
      wkEnums = [getEnumType(NullValue)];
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/to-plain-message.js
  function toPlainMessage(message) {
    const type = message.getType();
    const target = {};
    for (const member of type.fields.byMember()) {
      const source = message[member.localName];
      let copy;
      if (member.repeated) {
        copy = source.map((e) => toPlainValue(e));
      } else if (member.kind == "map") {
        copy = {};
        for (const [key, v] of Object.entries(source)) {
          copy[key] = toPlainValue(v);
        }
      } else if (member.kind == "oneof") {
        const f = member.findField(source.case);
        copy = f ? { case: source.case, value: toPlainValue(source.value) } : { case: void 0 };
      } else {
        copy = toPlainValue(source);
      }
      target[member.localName] = copy;
    }
    return target;
  }
  function toPlainValue(value) {
    if (value === void 0) {
      return value;
    }
    if (value instanceof Message) {
      return toPlainMessage(value);
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  var init_to_plain_message = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/to-plain-message.js"() {
      "use strict";
      init_message();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js
  var Version, CodeGeneratorRequest, CodeGeneratorResponse, CodeGeneratorResponse_Feature, CodeGeneratorResponse_File;
  var init_plugin_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js"() {
      "use strict";
      init_message();
      init_proto2();
      init_descriptor_pb();
      Version = class _Version extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Version().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Version().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Version().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_Version, a, b);
        }
      };
      Version.runtime = proto2;
      Version.typeName = "google.protobuf.compiler.Version";
      Version.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
      ]);
      CodeGeneratorRequest = class _CodeGeneratorRequest extends Message {
        constructor(data) {
          super();
          this.fileToGenerate = [];
          this.protoFile = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorRequest().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorRequest().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorRequest().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorRequest, a, b);
        }
      };
      CodeGeneratorRequest.runtime = proto2;
      CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
      CodeGeneratorRequest.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
        { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
        { no: 15, name: "proto_file", kind: "message", T: FileDescriptorProto, repeated: true },
        { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
      ]);
      CodeGeneratorResponse = class _CodeGeneratorResponse extends Message {
        constructor(data) {
          super();
          this.file = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorResponse, a, b);
        }
      };
      CodeGeneratorResponse.runtime = proto2;
      CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
      CodeGeneratorResponse.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
        { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
      ]);
      (function(CodeGeneratorResponse_Feature2) {
        CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
        CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
      })(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));
      proto2.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
        { no: 0, name: "FEATURE_NONE" },
        { no: 1, name: "FEATURE_PROTO3_OPTIONAL" }
      ]);
      CodeGeneratorResponse_File = class _CodeGeneratorResponse_File extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorResponse_File().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorResponse_File().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorResponse_File().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorResponse_File, a, b);
        }
      };
      CodeGeneratorResponse_File.runtime = proto2;
      CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
      CodeGeneratorResponse_File.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
        { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
        { no: 16, name: "generated_code_info", kind: "message", T: GeneratedCodeInfo, opt: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js
  var SourceContext;
  var init_source_context_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      SourceContext = class _SourceContext extends Message {
        constructor(data) {
          super();
          this.fileName = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceContext().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceContext().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceContext().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_SourceContext, a, b);
        }
      };
      SourceContext.runtime = proto3;
      SourceContext.typeName = "google.protobuf.SourceContext";
      SourceContext.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "file_name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js
  var Syntax, Type, Field, Field_Kind, Field_Cardinality, Enum, EnumValue, Option;
  var init_type_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js"() {
      "use strict";
      init_proto3();
      init_message();
      init_source_context_pb();
      init_any_pb();
      (function(Syntax2) {
        Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
        Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
        Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
      })(Syntax || (Syntax = {}));
      proto3.util.setEnumType(Syntax, "google.protobuf.Syntax", [
        { no: 0, name: "SYNTAX_PROTO2" },
        { no: 1, name: "SYNTAX_PROTO3" },
        { no: 2, name: "SYNTAX_EDITIONS" }
      ]);
      Type = class _Type extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.fields = [];
          this.oneofs = [];
          this.options = [];
          this.syntax = Syntax.PROTO2;
          this.edition = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Type().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Type().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Type().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Type, a, b);
        }
      };
      Type.runtime = proto3;
      Type.typeName = "google.protobuf.Type";
      Type.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "fields", kind: "message", T: Field, repeated: true },
        { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
        { no: 4, name: "options", kind: "message", T: Option, repeated: true },
        { no: 5, name: "source_context", kind: "message", T: SourceContext },
        { no: 6, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
        {
          no: 7,
          name: "edition",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      Field = class _Field extends Message {
        constructor(data) {
          super();
          this.kind = Field_Kind.TYPE_UNKNOWN;
          this.cardinality = Field_Cardinality.UNKNOWN;
          this.number = 0;
          this.name = "";
          this.typeUrl = "";
          this.oneofIndex = 0;
          this.packed = false;
          this.options = [];
          this.jsonName = "";
          this.defaultValue = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Field().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Field().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Field().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Field, a, b);
        }
      };
      Field.runtime = proto3;
      Field.typeName = "google.protobuf.Field";
      Field.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(Field_Kind) },
        { no: 2, name: "cardinality", kind: "enum", T: proto3.getEnumType(Field_Cardinality) },
        {
          no: 3,
          name: "number",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 4,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 6,
          name: "type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 7,
          name: "oneof_index",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 8,
          name: "packed",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        { no: 9, name: "options", kind: "message", T: Option, repeated: true },
        {
          no: 10,
          name: "json_name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 11,
          name: "default_value",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      (function(Field_Kind2) {
        Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
        Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
        Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
        Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
        Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
        Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
        Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
        Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
        Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
        Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
        Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
        Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
        Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
        Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
        Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
        Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
        Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
        Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
        Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
      })(Field_Kind || (Field_Kind = {}));
      proto3.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
        { no: 0, name: "TYPE_UNKNOWN" },
        { no: 1, name: "TYPE_DOUBLE" },
        { no: 2, name: "TYPE_FLOAT" },
        { no: 3, name: "TYPE_INT64" },
        { no: 4, name: "TYPE_UINT64" },
        { no: 5, name: "TYPE_INT32" },
        { no: 6, name: "TYPE_FIXED64" },
        { no: 7, name: "TYPE_FIXED32" },
        { no: 8, name: "TYPE_BOOL" },
        { no: 9, name: "TYPE_STRING" },
        { no: 10, name: "TYPE_GROUP" },
        { no: 11, name: "TYPE_MESSAGE" },
        { no: 12, name: "TYPE_BYTES" },
        { no: 13, name: "TYPE_UINT32" },
        { no: 14, name: "TYPE_ENUM" },
        { no: 15, name: "TYPE_SFIXED32" },
        { no: 16, name: "TYPE_SFIXED64" },
        { no: 17, name: "TYPE_SINT32" },
        { no: 18, name: "TYPE_SINT64" }
      ]);
      (function(Field_Cardinality2) {
        Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
        Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
        Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
        Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
      })(Field_Cardinality || (Field_Cardinality = {}));
      proto3.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
        { no: 0, name: "CARDINALITY_UNKNOWN" },
        { no: 1, name: "CARDINALITY_OPTIONAL" },
        { no: 2, name: "CARDINALITY_REQUIRED" },
        { no: 3, name: "CARDINALITY_REPEATED" }
      ]);
      Enum = class _Enum extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.enumvalue = [];
          this.options = [];
          this.syntax = Syntax.PROTO2;
          this.edition = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Enum().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Enum().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Enum().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Enum, a, b);
        }
      };
      Enum.runtime = proto3;
      Enum.typeName = "google.protobuf.Enum";
      Enum.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true },
        { no: 4, name: "source_context", kind: "message", T: SourceContext },
        { no: 5, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
        {
          no: 6,
          name: "edition",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      EnumValue = class _EnumValue extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.number = 0;
          this.options = [];
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_EnumValue, a, b);
        }
      };
      EnumValue.runtime = proto3;
      EnumValue.typeName = "google.protobuf.EnumValue";
      EnumValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "number",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true }
      ]);
      Option = class _Option extends Message {
        constructor(data) {
          super();
          this.name = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Option().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Option().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Option().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Option, a, b);
        }
      };
      Option.runtime = proto3;
      Option.typeName = "google.protobuf.Option";
      Option.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "value", kind: "message", T: Any }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js
  var Api, Method, Mixin;
  var init_api_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js"() {
      "use strict";
      init_message();
      init_type_pb();
      init_source_context_pb();
      init_proto3();
      Api = class _Api extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.methods = [];
          this.options = [];
          this.version = "";
          this.mixins = [];
          this.syntax = Syntax.PROTO2;
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Api().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Api().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Api().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Api, a, b);
        }
      };
      Api.runtime = proto3;
      Api.typeName = "google.protobuf.Api";
      Api.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true },
        {
          no: 4,
          name: "version",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 5, name: "source_context", kind: "message", T: SourceContext },
        { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
        { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
      ]);
      Method = class _Method extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.requestTypeUrl = "";
          this.requestStreaming = false;
          this.responseTypeUrl = "";
          this.responseStreaming = false;
          this.options = [];
          this.syntax = Syntax.PROTO2;
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Method().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Method().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Method().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Method, a, b);
        }
      };
      Method.runtime = proto3;
      Method.typeName = "google.protobuf.Method";
      Method.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "request_type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 3,
          name: "request_streaming",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        {
          no: 4,
          name: "response_type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 5,
          name: "response_streaming",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        { no: 6, name: "options", kind: "message", T: Option, repeated: true },
        { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
      ]);
      Mixin = class _Mixin extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.root = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Mixin().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Mixin().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Mixin().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Mixin, a, b);
        }
      };
      Mixin.runtime = proto3;
      Mixin.typeName = "google.protobuf.Mixin";
      Mixin.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "root",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Any: () => Any,
    Api: () => Api,
    BinaryReader: () => BinaryReader,
    BinaryWriter: () => BinaryWriter,
    BoolValue: () => BoolValue,
    BytesValue: () => BytesValue,
    CodeGeneratorRequest: () => CodeGeneratorRequest,
    CodeGeneratorResponse: () => CodeGeneratorResponse,
    CodeGeneratorResponse_Feature: () => CodeGeneratorResponse_Feature,
    CodeGeneratorResponse_File: () => CodeGeneratorResponse_File,
    DescriptorProto: () => DescriptorProto,
    DescriptorProto_ExtensionRange: () => DescriptorProto_ExtensionRange,
    DescriptorProto_ReservedRange: () => DescriptorProto_ReservedRange,
    DoubleValue: () => DoubleValue,
    Duration: () => Duration,
    Empty: () => Empty,
    Enum: () => Enum,
    EnumDescriptorProto: () => EnumDescriptorProto,
    EnumDescriptorProto_EnumReservedRange: () => EnumDescriptorProto_EnumReservedRange,
    EnumOptions: () => EnumOptions,
    EnumValue: () => EnumValue,
    EnumValueDescriptorProto: () => EnumValueDescriptorProto,
    EnumValueOptions: () => EnumValueOptions,
    ExtensionRangeOptions: () => ExtensionRangeOptions,
    ExtensionRangeOptions_Declaration: () => ExtensionRangeOptions_Declaration,
    ExtensionRangeOptions_VerificationState: () => ExtensionRangeOptions_VerificationState,
    Field: () => Field,
    FieldDescriptorProto: () => FieldDescriptorProto,
    FieldDescriptorProto_Label: () => FieldDescriptorProto_Label,
    FieldDescriptorProto_Type: () => FieldDescriptorProto_Type,
    FieldMask: () => FieldMask,
    FieldOptions: () => FieldOptions,
    FieldOptions_CType: () => FieldOptions_CType,
    FieldOptions_JSType: () => FieldOptions_JSType,
    FieldOptions_OptionRetention: () => FieldOptions_OptionRetention,
    FieldOptions_OptionTargetType: () => FieldOptions_OptionTargetType,
    Field_Cardinality: () => Field_Cardinality,
    Field_Kind: () => Field_Kind,
    FileDescriptorProto: () => FileDescriptorProto,
    FileDescriptorSet: () => FileDescriptorSet,
    FileOptions: () => FileOptions,
    FileOptions_OptimizeMode: () => FileOptions_OptimizeMode,
    FloatValue: () => FloatValue,
    GeneratedCodeInfo: () => GeneratedCodeInfo,
    GeneratedCodeInfo_Annotation: () => GeneratedCodeInfo_Annotation,
    GeneratedCodeInfo_Annotation_Semantic: () => GeneratedCodeInfo_Annotation_Semantic,
    Int32Value: () => Int32Value,
    Int64Value: () => Int64Value,
    ListValue: () => ListValue,
    Message: () => Message,
    MessageOptions: () => MessageOptions,
    Method: () => Method,
    MethodDescriptorProto: () => MethodDescriptorProto,
    MethodIdempotency: () => MethodIdempotency,
    MethodKind: () => MethodKind,
    MethodOptions: () => MethodOptions,
    MethodOptions_IdempotencyLevel: () => MethodOptions_IdempotencyLevel,
    Mixin: () => Mixin,
    NullValue: () => NullValue,
    OneofDescriptorProto: () => OneofDescriptorProto,
    OneofOptions: () => OneofOptions,
    Option: () => Option,
    ScalarType: () => ScalarType,
    ServiceDescriptorProto: () => ServiceDescriptorProto,
    ServiceOptions: () => ServiceOptions,
    SourceCodeInfo: () => SourceCodeInfo,
    SourceCodeInfo_Location: () => SourceCodeInfo_Location,
    SourceContext: () => SourceContext,
    StringValue: () => StringValue,
    Struct: () => Struct,
    Syntax: () => Syntax,
    Timestamp: () => Timestamp,
    Type: () => Type,
    UInt32Value: () => UInt32Value,
    UInt64Value: () => UInt64Value,
    UninterpretedOption: () => UninterpretedOption,
    UninterpretedOption_NamePart: () => UninterpretedOption_NamePart,
    Value: () => Value,
    Version: () => Version,
    WireType: () => WireType,
    codegenInfo: () => codegenInfo,
    createDescriptorSet: () => createDescriptorSet,
    createRegistry: () => createRegistry,
    createRegistryFromDescriptors: () => createRegistryFromDescriptors,
    proto2: () => proto2,
    proto3: () => proto3,
    protoBase64: () => protoBase64,
    protoDelimited: () => protoDelimited,
    protoDouble: () => protoDouble,
    protoInt64: () => protoInt64,
    toPlainMessage: () => toPlainMessage
  });
  var init_esm = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/index.js"() {
      "use strict";
      init_proto3();
      init_proto2();
      init_proto_double();
      init_proto_int64();
      init_proto_base64();
      init_proto_delimited();
      init_codegen_info();
      init_message();
      init_field();
      init_service_type();
      init_binary_encoding();
      init_create_descriptor_set();
      init_create_registry();
      init_create_registry_from_desc();
      init_to_plain_message();
      init_plugin_pb();
      init_api_pb();
      init_any_pb();
      init_descriptor_pb();
      init_duration_pb();
      init_empty_pb();
      init_field_mask_pb();
      init_source_context_pb();
      init_struct_pb();
      init_timestamp_pb();
      init_type_pb();
      init_wrappers_pb();
    }
  });

  // ../protoc/dist/rtc/sctp_capabilities_pb.js
  var require_sctp_capabilities_pb = __commonJS({
    "../protoc/dist/rtc/sctp_capabilities_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoSctpCapabilities = exports.ProtoNumSctpStreams = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoNumSctpStreams = class _ProtoNumSctpStreams extends protobuf_1.Message {
        constructor(data) {
          super();
          this.OS = 0;
          this.MIS = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoNumSctpStreams().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoNumSctpStreams().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoNumSctpStreams().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoNumSctpStreams, a, b);
        }
      };
      exports.ProtoNumSctpStreams = ProtoNumSctpStreams;
      ProtoNumSctpStreams.runtime = protobuf_1.proto3;
      ProtoNumSctpStreams.typeName = "ProtoNumSctpStreams";
      ProtoNumSctpStreams.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "OS", kind: "scalar", T: 5 },
        { no: 2, name: "MIS", kind: "scalar", T: 5 }
      ]);
      var ProtoSctpCapabilities = class _ProtoSctpCapabilities extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpCapabilities().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpCapabilities().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpCapabilities().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpCapabilities, a, b);
        }
      };
      exports.ProtoSctpCapabilities = ProtoSctpCapabilities;
      ProtoSctpCapabilities.runtime = protobuf_1.proto3;
      ProtoSctpCapabilities.typeName = "ProtoSctpCapabilities";
      ProtoSctpCapabilities.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "numStreams", kind: "message", T: ProtoNumSctpStreams }
      ]);
    }
  });

  // ../protoc/dist/rtc/sdp_info_pb.js
  var require_sdp_info_pb = __commonJS({
    "../protoc/dist/rtc/sdp_info_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoTransportSDPInfo = exports.ProtoSctpParameters = exports.ProtoDtlsParameters = exports.ProtoIceCandidates = exports.ProtoIceParameters = exports.ProtoDtlsFingerPrints = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoDtlsFingerPrints = class _ProtoDtlsFingerPrints extends protobuf_1.Message {
        constructor(data) {
          super();
          this.algorithm = "";
          this.value = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoDtlsFingerPrints().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoDtlsFingerPrints().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoDtlsFingerPrints().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoDtlsFingerPrints, a, b);
        }
      };
      exports.ProtoDtlsFingerPrints = ProtoDtlsFingerPrints;
      ProtoDtlsFingerPrints.runtime = protobuf_1.proto3;
      ProtoDtlsFingerPrints.typeName = "ProtoDtlsFingerPrints";
      ProtoDtlsFingerPrints.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "algorithm", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 }
      ]);
      var ProtoIceParameters = class _ProtoIceParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.usernameFragment = "";
          this.password = "";
          this.iceLite = false;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoIceParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoIceParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoIceParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoIceParameters, a, b);
        }
      };
      exports.ProtoIceParameters = ProtoIceParameters;
      ProtoIceParameters.runtime = protobuf_1.proto3;
      ProtoIceParameters.typeName = "ProtoIceParameters";
      ProtoIceParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "usernameFragment", kind: "scalar", T: 9 },
        { no: 2, name: "password", kind: "scalar", T: 9 },
        { no: 3, name: "iceLite", kind: "scalar", T: 8 }
      ]);
      var ProtoIceCandidates = class _ProtoIceCandidates extends protobuf_1.Message {
        constructor(data) {
          super();
          this.foundation = "";
          this.priority = 0;
          this.ip = "";
          this.port = 0;
          this.type = "";
          this.protocol = "";
          this.tcpType = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoIceCandidates().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoIceCandidates().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoIceCandidates().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoIceCandidates, a, b);
        }
      };
      exports.ProtoIceCandidates = ProtoIceCandidates;
      ProtoIceCandidates.runtime = protobuf_1.proto3;
      ProtoIceCandidates.typeName = "ProtoIceCandidates";
      ProtoIceCandidates.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "foundation", kind: "scalar", T: 9 },
        { no: 2, name: "priority", kind: "scalar", T: 5 },
        { no: 3, name: "ip", kind: "scalar", T: 9 },
        { no: 4, name: "port", kind: "scalar", T: 5 },
        { no: 5, name: "type", kind: "scalar", T: 9 },
        { no: 6, name: "protocol", kind: "scalar", T: 9 },
        { no: 7, name: "tcpType", kind: "scalar", T: 9 }
      ]);
      var ProtoDtlsParameters = class _ProtoDtlsParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.role = "";
          this.fingerprints = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoDtlsParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoDtlsParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoDtlsParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoDtlsParameters, a, b);
        }
      };
      exports.ProtoDtlsParameters = ProtoDtlsParameters;
      ProtoDtlsParameters.runtime = protobuf_1.proto3;
      ProtoDtlsParameters.typeName = "ProtoDtlsParameters";
      ProtoDtlsParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "role", kind: "scalar", T: 9 },
        { no: 2, name: "fingerprints", kind: "message", T: ProtoDtlsFingerPrints, repeated: true }
      ]);
      var ProtoSctpParameters = class _ProtoSctpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.port = 0;
          this.OS = 0;
          this.MIS = 0;
          this.maxMessageSize = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpParameters, a, b);
        }
      };
      exports.ProtoSctpParameters = ProtoSctpParameters;
      ProtoSctpParameters.runtime = protobuf_1.proto3;
      ProtoSctpParameters.typeName = "ProtoSctpParameters";
      ProtoSctpParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "port", kind: "scalar", T: 5 },
        { no: 2, name: "OS", kind: "scalar", T: 5 },
        { no: 3, name: "MIS", kind: "scalar", T: 5 },
        { no: 4, name: "maxMessageSize", kind: "scalar", T: 5 }
      ]);
      var ProtoTransportSDPInfo = class _ProtoTransportSDPInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.id = "";
          this.iceCandidates = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoTransportSDPInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoTransportSDPInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoTransportSDPInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoTransportSDPInfo, a, b);
        }
      };
      exports.ProtoTransportSDPInfo = ProtoTransportSDPInfo;
      ProtoTransportSDPInfo.runtime = protobuf_1.proto3;
      ProtoTransportSDPInfo.typeName = "ProtoTransportSDPInfo";
      ProtoTransportSDPInfo.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "iceCandidates", kind: "message", T: ProtoIceCandidates, repeated: true },
        { no: 3, name: "iceParameters", kind: "message", T: ProtoIceParameters },
        { no: 4, name: "dtlsParameters", kind: "message", T: ProtoDtlsParameters },
        { no: 5, name: "sctpParameters", kind: "message", T: ProtoSctpParameters }
      ]);
    }
  });

  // ../protoc/dist/rtc/rtp_parameters_pb.js
  var require_rtp_parameters_pb = __commonJS({
    "../protoc/dist/rtc/rtp_parameters_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoRtpParameters = exports.RtcpParameters = exports.ProtoEncodings_ProtoRTX = exports.ProtoEncodings = exports.ProtoHeaderExtensionParameters = exports.ProtoCodecParameters = exports.ProtoRtcpFeedback = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoRtcpFeedback = class _ProtoRtcpFeedback extends protobuf_1.Message {
        constructor(data) {
          super();
          this.type = "";
          this.parameter = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtcpFeedback().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtcpFeedback().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtcpFeedback().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtcpFeedback, a, b);
        }
      };
      exports.ProtoRtcpFeedback = ProtoRtcpFeedback;
      ProtoRtcpFeedback.runtime = protobuf_1.proto3;
      ProtoRtcpFeedback.typeName = "ProtoRtcpFeedback";
      ProtoRtcpFeedback.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "parameter", kind: "scalar", T: 9 }
      ]);
      var ProtoCodecParameters = class _ProtoCodecParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.mimeType = "";
          this.payloadType = 0;
          this.clockRate = 0;
          this.channels = 0;
          this.parameters = {};
          this.rtcpFeedback = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoCodecParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoCodecParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoCodecParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoCodecParameters, a, b);
        }
      };
      exports.ProtoCodecParameters = ProtoCodecParameters;
      ProtoCodecParameters.runtime = protobuf_1.proto3;
      ProtoCodecParameters.typeName = "ProtoCodecParameters";
      ProtoCodecParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "mimeType", kind: "scalar", T: 9 },
        { no: 2, name: "payloadType", kind: "scalar", T: 5 },
        { no: 3, name: "clockRate", kind: "scalar", T: 5 },
        { no: 4, name: "channels", kind: "scalar", T: 5 },
        { no: 6, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
        { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtcpFeedback, repeated: true }
      ]);
      var ProtoHeaderExtensionParameters = class _ProtoHeaderExtensionParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.uri = "";
          this.id = 0;
          this.encrypt = false;
          this.parameters = {};
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoHeaderExtensionParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoHeaderExtensionParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoHeaderExtensionParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoHeaderExtensionParameters, a, b);
        }
      };
      exports.ProtoHeaderExtensionParameters = ProtoHeaderExtensionParameters;
      ProtoHeaderExtensionParameters.runtime = protobuf_1.proto3;
      ProtoHeaderExtensionParameters.typeName = "ProtoHeaderExtensionParameters";
      ProtoHeaderExtensionParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "encrypt", kind: "scalar", T: 8 },
        { no: 4, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } }
      ]);
      var ProtoEncodings2 = class _ProtoEncodings extends protobuf_1.Message {
        constructor(data) {
          super();
          this.ssrc = protobuf_1.protoInt64.zero;
          this.rid = "";
          this.codecPayloadType = 0;
          this.dtx = false;
          this.scalabilityMode = "";
          this.scaleResolutionDownBy = 0;
          this.maxBitrate = 0;
          this.active = false;
          this.maxFramerate = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoEncodings().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoEncodings().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoEncodings().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoEncodings, a, b);
        }
      };
      exports.ProtoEncodings = ProtoEncodings2;
      ProtoEncodings2.runtime = protobuf_1.proto3;
      ProtoEncodings2.typeName = "ProtoEncodings";
      ProtoEncodings2.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "ssrc", kind: "scalar", T: 3 },
        { no: 2, name: "rid", kind: "scalar", T: 9 },
        { no: 3, name: "codecPayloadType", kind: "scalar", T: 5 },
        { no: 4, name: "rtx", kind: "message", T: ProtoEncodings_ProtoRTX },
        { no: 5, name: "dtx", kind: "scalar", T: 8 },
        { no: 6, name: "scalabilityMode", kind: "scalar", T: 9 },
        { no: 7, name: "scaleResolutionDownBy", kind: "scalar", T: 5 },
        { no: 8, name: "maxBitrate", kind: "scalar", T: 5 },
        { no: 9, name: "active", kind: "scalar", T: 8 },
        { no: 10, name: "maxFramerate", kind: "scalar", T: 5 }
      ]);
      var ProtoEncodings_ProtoRTX = class _ProtoEncodings_ProtoRTX extends protobuf_1.Message {
        constructor(data) {
          super();
          this.ssrc = protobuf_1.protoInt64.zero;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoEncodings_ProtoRTX().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoEncodings_ProtoRTX().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoEncodings_ProtoRTX().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoEncodings_ProtoRTX, a, b);
        }
      };
      exports.ProtoEncodings_ProtoRTX = ProtoEncodings_ProtoRTX;
      ProtoEncodings_ProtoRTX.runtime = protobuf_1.proto3;
      ProtoEncodings_ProtoRTX.typeName = "ProtoEncodings.ProtoRTX";
      ProtoEncodings_ProtoRTX.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "ssrc", kind: "scalar", T: 3 }
      ]);
      var RtcpParameters = class _RtcpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.cname = "";
          this.reducedSize = false;
          this.mux = false;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RtcpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RtcpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RtcpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_RtcpParameters, a, b);
        }
      };
      exports.RtcpParameters = RtcpParameters;
      RtcpParameters.runtime = protobuf_1.proto3;
      RtcpParameters.typeName = "RtcpParameters";
      RtcpParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "cname", kind: "scalar", T: 9 },
        { no: 2, name: "reducedSize", kind: "scalar", T: 8 },
        { no: 3, name: "mux", kind: "scalar", T: 8 }
      ]);
      var ProtoRtpParameters2 = class _ProtoRtpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.mid = "";
          this.codecs = [];
          this.headerExtensions = [];
          this.encodings = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpParameters, a, b);
        }
      };
      exports.ProtoRtpParameters = ProtoRtpParameters2;
      ProtoRtpParameters2.runtime = protobuf_1.proto3;
      ProtoRtpParameters2.typeName = "ProtoRtpParameters";
      ProtoRtpParameters2.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "mid", kind: "scalar", T: 9 },
        { no: 2, name: "codecs", kind: "message", T: ProtoCodecParameters, repeated: true },
        { no: 3, name: "headerExtensions", kind: "message", T: ProtoHeaderExtensionParameters, repeated: true },
        { no: 4, name: "encodings", kind: "message", T: ProtoEncodings2, repeated: true },
        { no: 5, name: "rtcp", kind: "message", T: RtcpParameters }
      ]);
    }
  });

  // ../protoc/dist/client/app_data_pb.js
  var require_app_data_pb = __commonJS({
    "../protoc/dist/client/app_data_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AppData = exports.Value = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var Value2 = class _Value extends protobuf_1.Message {
        constructor(data) {
          super();
          this.valueType = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Value, a, b);
        }
      };
      exports.Value = Value2;
      Value2.runtime = protobuf_1.proto2;
      Value2.typeName = "Value";
      Value2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "string_value", kind: "scalar", T: 9, oneof: "value_type" },
        { no: 2, name: "int_value", kind: "scalar", T: 5, oneof: "value_type" },
        { no: 3, name: "float_value", kind: "scalar", T: 2, oneof: "value_type" }
      ]);
      var AppData = class _AppData extends protobuf_1.Message {
        constructor(data) {
          super();
          this.appData = {};
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _AppData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _AppData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _AppData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_AppData, a, b);
        }
      };
      exports.AppData = AppData;
      AppData.runtime = protobuf_1.proto2;
      AppData.typeName = "AppData";
      AppData.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "appData", kind: "map", K: 9, V: { kind: "message", T: Value2 } }
      ]);
    }
  });

  // ../protoc/dist/rtc/sctp_stream_parameters_pb.js
  var require_sctp_stream_parameters_pb = __commonJS({
    "../protoc/dist/rtc/sctp_stream_parameters_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoSctpStreamParameters = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoSctpStreamParameters = class _ProtoSctpStreamParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.streamId = 0;
          this.ordered = false;
          this.maxPacketLifeTime = 0;
          this.maxRetransmits = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpStreamParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpStreamParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpStreamParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpStreamParameters, a, b);
        }
      };
      exports.ProtoSctpStreamParameters = ProtoSctpStreamParameters;
      ProtoSctpStreamParameters.runtime = protobuf_1.proto3;
      ProtoSctpStreamParameters.typeName = "ProtoSctpStreamParameters";
      ProtoSctpStreamParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "streamId", kind: "scalar", T: 5 },
        { no: 2, name: "ordered", kind: "scalar", T: 8 },
        { no: 3, name: "maxPacketLifeTime", kind: "scalar", T: 5 },
        { no: 4, name: "maxRetransmits", kind: "scalar", T: 5 }
      ]);
    }
  });

  // ../protoc/dist/client/room_control_pb.js
  var require_room_control_pb = __commonJS({
    "../protoc/dist/client/room_control_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProduceSourcesControl = exports.RoomControlType = exports.ProduceSources = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProduceSources = class _ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceSources, a, b);
        }
      };
      exports.ProduceSources = ProduceSources;
      ProduceSources.runtime = protobuf_1.proto2;
      ProduceSources.typeName = "ProduceSources";
      ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "mic", kind: "scalar", T: 8 },
        { no: 2, name: "cam", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
      var RoomControlType = class _RoomControlType extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControlType().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControlType().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControlType().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControlType, a, b);
        }
      };
      exports.RoomControlType = RoomControlType;
      RoomControlType.runtime = protobuf_1.proto2;
      RoomControlType.typeName = "RoomControlType";
      RoomControlType.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 5, name: "value", kind: "scalar", T: 8 }
      ]);
      var ProduceSourcesControl = class _ProduceSourcesControl extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceSourcesControl().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceSourcesControl().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceSourcesControl().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceSourcesControl, a, b);
        }
      };
      exports.ProduceSourcesControl = ProduceSourcesControl;
      ProduceSourcesControl.runtime = protobuf_1.proto2;
      ProduceSourcesControl.typeName = "ProduceSourcesControl";
      ProduceSourcesControl.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "message", T: ProduceSources }
      ]);
    }
  });

  // ../protoc/dist/client/permissions_pb.js
  var require_permissions_pb = __commonJS({
    "../protoc/dist/client/permissions_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Permissions_ProduceSources = exports.Permissions = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var Permissions2 = class _Permissions extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Permissions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Permissions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Permissions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Permissions, a, b);
        }
      };
      exports.Permissions = Permissions2;
      Permissions2.runtime = protobuf_1.proto2;
      Permissions2.typeName = "Permissions";
      Permissions2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "admin", kind: "scalar", T: 8 },
        { no: 2, name: "canConsume", kind: "scalar", T: 8 },
        { no: 3, name: "canProduce", kind: "scalar", T: 8 },
        { no: 4, name: "canProduceSources", kind: "message", T: Permissions_ProduceSources },
        { no: 5, name: "canSendData", kind: "scalar", T: 8 },
        { no: 6, name: "canRecvData", kind: "scalar", T: 8 },
        { no: 7, name: "canUpdateMetadata", kind: "scalar", T: 8 }
      ]);
      var Permissions_ProduceSources = class _Permissions_ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Permissions_ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Permissions_ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Permissions_ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Permissions_ProduceSources, a, b);
        }
      };
      exports.Permissions_ProduceSources = Permissions_ProduceSources;
      Permissions_ProduceSources.runtime = protobuf_1.proto2;
      Permissions_ProduceSources.typeName = "Permissions.ProduceSources";
      Permissions_ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "cam", kind: "scalar", T: 8 },
        { no: 2, name: "mic", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
    }
  });

  // ../protoc/dist/client/request_pb.js
  var require_request_pb = __commonJS({
    "../protoc/dist/client/request_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Request = exports.CloseRoom = exports.KickPeer = exports.DenyLobbyPeer = exports.AcceptLobbyPeer = exports.CloseStreamOfLabel = exports.UpdateRoomMetadata = exports.UpdatePeerMetadata = exports.UpdatePeerRole = exports.ActivateSpeakerNotification = exports.UpdatePeerPermission = exports.UpdateRoomControls = exports.SendData = exports.RestartTransportIce = exports.SyncMeetingState = exports.ResumeConsumer = exports.CloseConsumer = exports.CloseProducer = exports.Consume = exports.ProduceData = exports.Produce = exports.CreateDataConsumer = exports.ConnectTransport = exports.CreateTransport = exports.ConnectRoom = exports.TestEvent = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var sctp_capabilities_pb_js_1 = require_sctp_capabilities_pb();
      var sdp_info_pb_js_1 = require_sdp_info_pb();
      var rtp_parameters_pb_js_1 = require_rtp_parameters_pb();
      var app_data_pb_js_1 = require_app_data_pb();
      var sctp_stream_parameters_pb_js_1 = require_sctp_stream_parameters_pb();
      var room_control_pb_js_1 = require_room_control_pb();
      var permissions_pb_js_1 = require_permissions_pb();
      var TestEvent = class _TestEvent extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _TestEvent().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _TestEvent().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _TestEvent().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_TestEvent, a, b);
        }
      };
      exports.TestEvent = TestEvent;
      TestEvent.runtime = protobuf_1.proto2;
      TestEvent.typeName = "TestEvent";
      TestEvent.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "payload", kind: "scalar", T: 9 },
        { no: 3, name: "from", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "to", kind: "scalar", T: 9, opt: true }
      ]);
      var ConnectRoom2 = class _ConnectRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoom, a, b);
        }
      };
      exports.ConnectRoom = ConnectRoom2;
      ConnectRoom2.runtime = protobuf_1.proto2;
      ConnectRoom2.typeName = "ConnectRoom";
      ConnectRoom2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomId", kind: "scalar", T: 9 }
      ]);
      var CreateTransport2 = class _CreateTransport extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateTransport().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateTransport().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateTransport().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateTransport, a, b);
        }
      };
      exports.CreateTransport = CreateTransport2;
      CreateTransport2.runtime = protobuf_1.proto2;
      CreateTransport2.typeName = "CreateTransport";
      CreateTransport2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "sctpCapabilities", kind: "message", T: sctp_capabilities_pb_js_1.ProtoSctpCapabilities },
        { no: 2, name: "transportType", kind: "scalar", T: 9 }
      ]);
      var ConnectTransport2 = class _ConnectTransport extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectTransport().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectTransport().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectTransport().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectTransport, a, b);
        }
      };
      exports.ConnectTransport = ConnectTransport2;
      ConnectTransport2.runtime = protobuf_1.proto2;
      ConnectTransport2.typeName = "ConnectTransport";
      ConnectTransport2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "dtlsParameters", kind: "message", T: sdp_info_pb_js_1.ProtoDtlsParameters }
      ]);
      var CreateDataConsumer2 = class _CreateDataConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateDataConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateDataConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateDataConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateDataConsumer, a, b);
        }
      };
      exports.CreateDataConsumer = CreateDataConsumer2;
      CreateDataConsumer2.runtime = protobuf_1.proto2;
      CreateDataConsumer2.typeName = "CreateDataConsumer";
      CreateDataConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 }
      ]);
      var Produce2 = class _Produce extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Produce().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Produce().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Produce().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Produce, a, b);
        }
      };
      exports.Produce = Produce2;
      Produce2.runtime = protobuf_1.proto2;
      Produce2.typeName = "Produce";
      Produce2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "rtpParameters", kind: "message", T: rtp_parameters_pb_js_1.ProtoRtpParameters },
        { no: 4, name: "paused", kind: "scalar", T: 8 },
        { no: 5, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ProduceData2 = class _ProduceData extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceData, a, b);
        }
      };
      exports.ProduceData = ProduceData2;
      ProduceData2.runtime = protobuf_1.proto2;
      ProduceData2.typeName = "ProduceData";
      ProduceData2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportId", kind: "scalar", T: 9 },
        { no: 2, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "protocol", kind: "scalar", T: 9, opt: true },
        { no: 5, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var Consume2 = class _Consume extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Consume().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Consume().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Consume().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Consume, a, b);
        }
      };
      exports.Consume = Consume2;
      Consume2.runtime = protobuf_1.proto2;
      Consume2.typeName = "Consume";
      Consume2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producerPeerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var CloseProducer2 = class _CloseProducer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseProducer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseProducer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseProducer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseProducer, a, b);
        }
      };
      exports.CloseProducer = CloseProducer2;
      CloseProducer2.runtime = protobuf_1.proto2;
      CloseProducer2.typeName = "CloseProducer";
      CloseProducer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producerId", kind: "scalar", T: 9 }
      ]);
      var CloseConsumer2 = class _CloseConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseConsumer, a, b);
        }
      };
      exports.CloseConsumer = CloseConsumer2;
      CloseConsumer2.runtime = protobuf_1.proto2;
      CloseConsumer2.typeName = "CloseConsumer";
      CloseConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var ResumeConsumer2 = class _ResumeConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ResumeConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ResumeConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ResumeConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ResumeConsumer, a, b);
        }
      };
      exports.ResumeConsumer = ResumeConsumer2;
      ResumeConsumer2.runtime = protobuf_1.proto2;
      ResumeConsumer2.typeName = "ResumeConsumer";
      ResumeConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "consumerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerPeerId", kind: "scalar", T: 9 }
      ]);
      var SyncMeetingState2 = class _SyncMeetingState extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SyncMeetingState().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SyncMeetingState().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SyncMeetingState().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SyncMeetingState, a, b);
        }
      };
      exports.SyncMeetingState = SyncMeetingState2;
      SyncMeetingState2.runtime = protobuf_1.proto2;
      SyncMeetingState2.typeName = "SyncMeetingState";
      SyncMeetingState2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var RestartTransportIce2 = class _RestartTransportIce extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RestartTransportIce().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RestartTransportIce().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RestartTransportIce().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RestartTransportIce, a, b);
        }
      };
      exports.RestartTransportIce = RestartTransportIce2;
      RestartTransportIce2.runtime = protobuf_1.proto2;
      RestartTransportIce2.typeName = "RestartTransportIce";
      RestartTransportIce2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportId", kind: "scalar", T: 9 }
      ]);
      var SendData2 = class _SendData extends protobuf_1.Message {
        constructor(data) {
          super();
          this.to = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SendData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SendData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SendData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SendData, a, b);
        }
      };
      exports.SendData = SendData2;
      SendData2.runtime = protobuf_1.proto2;
      SendData2.typeName = "SendData";
      SendData2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "to", kind: "scalar", T: 9, repeated: true },
        { no: 2, name: "label", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "payload", kind: "scalar", T: 9 }
      ]);
      var UpdateRoomControls2 = class _UpdateRoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          this.control = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdateRoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdateRoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdateRoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdateRoomControls, a, b);
        }
      };
      exports.UpdateRoomControls = UpdateRoomControls2;
      UpdateRoomControls2.runtime = protobuf_1.proto2;
      UpdateRoomControls2.typeName = "UpdateRoomControls";
      UpdateRoomControls2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "room_control", kind: "message", T: room_control_pb_js_1.RoomControlType, oneof: "control" },
        { no: 2, name: "produce_sources_control", kind: "message", T: room_control_pb_js_1.ProduceSourcesControl, oneof: "control" }
      ]);
      var UpdatePeerPermission2 = class _UpdatePeerPermission extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerPermission().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerPermission().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerPermission().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerPermission, a, b);
        }
      };
      exports.UpdatePeerPermission = UpdatePeerPermission2;
      UpdatePeerPermission2.runtime = protobuf_1.proto2;
      UpdatePeerPermission2.typeName = "UpdatePeerPermission";
      UpdatePeerPermission2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "permissions", kind: "message", T: permissions_pb_js_1.Permissions, opt: true }
      ]);
      var ActivateSpeakerNotification2 = class _ActivateSpeakerNotification extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ActivateSpeakerNotification().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ActivateSpeakerNotification().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ActivateSpeakerNotification().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ActivateSpeakerNotification, a, b);
        }
      };
      exports.ActivateSpeakerNotification = ActivateSpeakerNotification2;
      ActivateSpeakerNotification2.runtime = protobuf_1.proto2;
      ActivateSpeakerNotification2.typeName = "ActivateSpeakerNotification";
      ActivateSpeakerNotification2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "size", kind: "scalar", T: 5, opt: true }
      ]);
      var UpdatePeerRole2 = class _UpdatePeerRole extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerRole().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerRole().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerRole().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerRole, a, b);
        }
      };
      exports.UpdatePeerRole = UpdatePeerRole2;
      UpdatePeerRole2.runtime = protobuf_1.proto2;
      UpdatePeerRole2.typeName = "UpdatePeerRole";
      UpdatePeerRole2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 }
      ]);
      var UpdatePeerMetadata2 = class _UpdatePeerMetadata extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerMetadata().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerMetadata().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerMetadata().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerMetadata, a, b);
        }
      };
      exports.UpdatePeerMetadata = UpdatePeerMetadata2;
      UpdatePeerMetadata2.runtime = protobuf_1.proto2;
      UpdatePeerMetadata2.typeName = "UpdatePeerMetadata";
      UpdatePeerMetadata2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var UpdateRoomMetadata2 = class _UpdateRoomMetadata extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdateRoomMetadata().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdateRoomMetadata().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdateRoomMetadata().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdateRoomMetadata, a, b);
        }
      };
      exports.UpdateRoomMetadata = UpdateRoomMetadata2;
      UpdateRoomMetadata2.runtime = protobuf_1.proto2;
      UpdateRoomMetadata2.typeName = "UpdateRoomMetadata";
      UpdateRoomMetadata2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var CloseStreamOfLabel2 = class _CloseStreamOfLabel extends protobuf_1.Message {
        constructor(data) {
          super();
          this.peerIds = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseStreamOfLabel().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseStreamOfLabel().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseStreamOfLabel().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseStreamOfLabel, a, b);
        }
      };
      exports.CloseStreamOfLabel = CloseStreamOfLabel2;
      CloseStreamOfLabel2.runtime = protobuf_1.proto2;
      CloseStreamOfLabel2.typeName = "CloseStreamOfLabel";
      CloseStreamOfLabel2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "peerIds", kind: "scalar", T: 9, repeated: true }
      ]);
      var AcceptLobbyPeer2 = class _AcceptLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _AcceptLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _AcceptLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _AcceptLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_AcceptLobbyPeer, a, b);
        }
      };
      exports.AcceptLobbyPeer = AcceptLobbyPeer2;
      AcceptLobbyPeer2.runtime = protobuf_1.proto2;
      AcceptLobbyPeer2.typeName = "AcceptLobbyPeer";
      AcceptLobbyPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var DenyLobbyPeer2 = class _DenyLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DenyLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DenyLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DenyLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_DenyLobbyPeer, a, b);
        }
      };
      exports.DenyLobbyPeer = DenyLobbyPeer2;
      DenyLobbyPeer2.runtime = protobuf_1.proto2;
      DenyLobbyPeer2.typeName = "DenyLobbyPeer";
      DenyLobbyPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var KickPeer2 = class _KickPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _KickPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _KickPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _KickPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_KickPeer, a, b);
        }
      };
      exports.KickPeer = KickPeer2;
      KickPeer2.runtime = protobuf_1.proto2;
      KickPeer2.typeName = "KickPeer";
      KickPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var CloseRoom2 = class _CloseRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseRoom, a, b);
        }
      };
      exports.CloseRoom = CloseRoom2;
      CloseRoom2.runtime = protobuf_1.proto2;
      CloseRoom2.typeName = "CloseRoom";
      CloseRoom2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var Request2 = class _Request extends protobuf_1.Message {
        constructor(data) {
          super();
          this.request = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Request().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Request().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Request().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Request, a, b);
        }
      };
      exports.Request = Request2;
      Request2.runtime = protobuf_1.proto2;
      Request2.typeName = "Request";
      Request2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 2, name: "connect_room", kind: "message", T: ConnectRoom2, oneof: "request" },
        { no: 3, name: "create_transport", kind: "message", T: CreateTransport2, oneof: "request" },
        { no: 4, name: "connect_transport", kind: "message", T: ConnectTransport2, oneof: "request" },
        { no: 25, name: "create_data_consumer", kind: "message", T: CreateDataConsumer2, oneof: "request" },
        { no: 5, name: "produce", kind: "message", T: Produce2, oneof: "request" },
        { no: 6, name: "produce_data", kind: "message", T: ProduceData2, oneof: "request" },
        { no: 7, name: "consume", kind: "message", T: Consume2, oneof: "request" },
        { no: 8, name: "close_producer", kind: "message", T: CloseProducer2, oneof: "request" },
        { no: 9, name: "close_consumer", kind: "message", T: CloseConsumer2, oneof: "request" },
        { no: 10, name: "resume_consumer", kind: "message", T: ResumeConsumer2, oneof: "request" },
        { no: 11, name: "sync_meeting_state", kind: "message", T: SyncMeetingState2, oneof: "request" },
        { no: 12, name: "restart_transport_ice", kind: "message", T: RestartTransportIce2, oneof: "request" },
        { no: 13, name: "send_data", kind: "message", T: SendData2, oneof: "request" },
        { no: 14, name: "update_room_controls", kind: "message", T: UpdateRoomControls2, oneof: "request" },
        { no: 15, name: "update_peer_permission", kind: "message", T: UpdatePeerPermission2, oneof: "request" },
        { no: 16, name: "activate_speaker_notification", kind: "message", T: ActivateSpeakerNotification2, oneof: "request" },
        { no: 17, name: "update_peer_role", kind: "message", T: UpdatePeerRole2, oneof: "request" },
        { no: 18, name: "update_peer_metadata", kind: "message", T: UpdatePeerMetadata2, oneof: "request" },
        { no: 19, name: "update_room_metadata", kind: "message", T: UpdateRoomMetadata2, oneof: "request" },
        { no: 20, name: "close_stream_of_label", kind: "message", T: CloseStreamOfLabel2, oneof: "request" },
        { no: 21, name: "accept_lobby_peer", kind: "message", T: AcceptLobbyPeer2, oneof: "request" },
        { no: 22, name: "deny_lobby_peer", kind: "message", T: DenyLobbyPeer2, oneof: "request" },
        { no: 23, name: "kick_peer", kind: "message", T: KickPeer2, oneof: "request" },
        { no: 24, name: "close_room", kind: "message", T: CloseRoom2, oneof: "request" }
      ]);
    }
  });

  // ../protoc/dist/rtc/rtp_capabilities_pb.js
  var require_rtp_capabilities_pb = __commonJS({
    "../protoc/dist/rtc/rtp_capabilities_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoRtpCapabilities = exports.ProtoRtpHeaderExtension = exports.ProtoRtpCodecCapability_ProtoRtcpFeedback = exports.ProtoRtpCodecCapability = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoRtpCodecCapability = class _ProtoRtpCodecCapability extends protobuf_1.Message {
        constructor(data) {
          super();
          this.kind = "";
          this.mimeType = "";
          this.preferredPayloadType = 0;
          this.clockRate = 0;
          this.channels = 0;
          this.parameters = {};
          this.rtcpFeedback = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCodecCapability().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCodecCapability().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCodecCapability().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCodecCapability, a, b);
        }
      };
      exports.ProtoRtpCodecCapability = ProtoRtpCodecCapability;
      ProtoRtpCodecCapability.runtime = protobuf_1.proto3;
      ProtoRtpCodecCapability.typeName = "ProtoRtpCodecCapability";
      ProtoRtpCodecCapability.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "scalar", T: 9 },
        { no: 2, name: "mimeType", kind: "scalar", T: 9 },
        { no: 3, name: "preferredPayloadType", kind: "scalar", T: 5 },
        { no: 4, name: "clockRate", kind: "scalar", T: 5 },
        { no: 5, name: "channels", kind: "scalar", T: 5 },
        { no: 6, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
        { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtpCodecCapability_ProtoRtcpFeedback, repeated: true }
      ]);
      var ProtoRtpCodecCapability_ProtoRtcpFeedback = class _ProtoRtpCodecCapability_ProtoRtcpFeedback extends protobuf_1.Message {
        constructor(data) {
          super();
          this.type = "";
          this.parameter = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCodecCapability_ProtoRtcpFeedback, a, b);
        }
      };
      exports.ProtoRtpCodecCapability_ProtoRtcpFeedback = ProtoRtpCodecCapability_ProtoRtcpFeedback;
      ProtoRtpCodecCapability_ProtoRtcpFeedback.runtime = protobuf_1.proto3;
      ProtoRtpCodecCapability_ProtoRtcpFeedback.typeName = "ProtoRtpCodecCapability.ProtoRtcpFeedback";
      ProtoRtpCodecCapability_ProtoRtcpFeedback.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "parameter", kind: "scalar", T: 9 }
      ]);
      var ProtoRtpHeaderExtension = class _ProtoRtpHeaderExtension extends protobuf_1.Message {
        constructor(data) {
          super();
          this.kind = "";
          this.uri = "";
          this.preferredId = 0;
          this.preferredEncrypt = false;
          this.direction = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpHeaderExtension().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpHeaderExtension().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpHeaderExtension().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpHeaderExtension, a, b);
        }
      };
      exports.ProtoRtpHeaderExtension = ProtoRtpHeaderExtension;
      ProtoRtpHeaderExtension.runtime = protobuf_1.proto3;
      ProtoRtpHeaderExtension.typeName = "ProtoRtpHeaderExtension";
      ProtoRtpHeaderExtension.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "scalar", T: 9 },
        { no: 2, name: "uri", kind: "scalar", T: 9 },
        { no: 3, name: "preferredId", kind: "scalar", T: 5 },
        { no: 4, name: "preferredEncrypt", kind: "scalar", T: 8 },
        { no: 5, name: "direction", kind: "scalar", T: 9 }
      ]);
      var ProtoRtpCapabilities = class _ProtoRtpCapabilities extends protobuf_1.Message {
        constructor(data) {
          super();
          this.codecs = [];
          this.headerExtensions = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCapabilities().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCapabilities().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCapabilities().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCapabilities, a, b);
        }
      };
      exports.ProtoRtpCapabilities = ProtoRtpCapabilities;
      ProtoRtpCapabilities.runtime = protobuf_1.proto3;
      ProtoRtpCapabilities.typeName = "ProtoRtpCapabilities";
      ProtoRtpCapabilities.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "codecs", kind: "message", T: ProtoRtpCodecCapability, repeated: true },
        { no: 2, name: "headerExtensions", kind: "message", T: ProtoRtpHeaderExtension, repeated: true }
      ]);
    }
  });

  // ../protoc/dist/client/response_pb.js
  var require_response_pb = __commonJS({
    "../protoc/dist/client/response_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Response = exports.Error = exports.WaitingRoom = exports.LobbyPeerLeft = exports.PeerLeft = exports.RoomClosedProducers_CloseProducerReason = exports.RoomClosedProducers_CloseProducerInfo = exports.RoomClosedProducers = exports.RoomMetadataUpdated = exports.PeerMetadataUpdated = exports.ReceiveData = exports.NewPeerRole = exports.NewRoomControls = exports.NewPermissions = exports.NewLobbyPeer = exports.NewPeerJoined = exports.RestartTransportIceResponse = exports.CloseConsumerSuccess = exports.CloseProducerSuccess = exports.ConsumeResponse = exports.SyncMeetingStateResponse = exports.ConsumeDataResponse = exports.ProduceDataResponse = exports.ProduceResponse = exports.ConnectTransportResponse = exports.CreateTransportOnClient = exports.ConnectRoomResponse_RTCIceServer = exports.ConnectRoomResponse = exports.LobbyPeers = exports.RoomInfo = exports.PeersInfo_ProducerInfo = exports.PeersInfo = exports.RoomControls_ProduceSources = exports.RoomControls = exports.Hello = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var permissions_pb_js_1 = require_permissions_pb();
      var rtp_capabilities_pb_js_1 = require_rtp_capabilities_pb();
      var sdp_info_pb_js_1 = require_sdp_info_pb();
      var app_data_pb_js_1 = require_app_data_pb();
      var sctp_stream_parameters_pb_js_1 = require_sctp_stream_parameters_pb();
      var rtp_parameters_pb_js_1 = require_rtp_parameters_pb();
      var Hello = class _Hello extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Hello().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Hello().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Hello().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Hello, a, b);
        }
      };
      exports.Hello = Hello;
      Hello.runtime = protobuf_1.proto2;
      Hello.typeName = "Hello";
      Hello.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "roomId", kind: "scalar", T: 9 },
        { no: 3, name: "sessionId", kind: "scalar", T: 9 },
        { no: 4, name: "acl", kind: "message", T: permissions_pb_js_1.Permissions },
        { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var RoomControls = class _RoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControls, a, b);
        }
      };
      exports.RoomControls = RoomControls;
      RoomControls.runtime = protobuf_1.proto2;
      RoomControls.typeName = "RoomControls";
      RoomControls.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomLocked", kind: "scalar", T: 8 },
        { no: 2, name: "allowProduce", kind: "scalar", T: 8 },
        { no: 3, name: "allowProduceSources", kind: "message", T: RoomControls_ProduceSources },
        { no: 4, name: "allowConsume", kind: "scalar", T: 8 },
        { no: 5, name: "allowSendData", kind: "scalar", T: 8 }
      ]);
      var RoomControls_ProduceSources = class _RoomControls_ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControls_ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControls_ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControls_ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControls_ProduceSources, a, b);
        }
      };
      exports.RoomControls_ProduceSources = RoomControls_ProduceSources;
      RoomControls_ProduceSources.runtime = protobuf_1.proto2;
      RoomControls_ProduceSources.typeName = "RoomControls.ProduceSources";
      RoomControls_ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "cam", kind: "scalar", T: 8 },
        { no: 2, name: "mic", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
      var PeersInfo = class _PeersInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.producers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeersInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeersInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeersInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeersInfo, a, b);
        }
      };
      exports.PeersInfo = PeersInfo;
      PeersInfo.runtime = protobuf_1.proto2;
      PeersInfo.typeName = "PeersInfo";
      PeersInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "producers", kind: "message", T: PeersInfo_ProducerInfo, repeated: true }
      ]);
      var PeersInfo_ProducerInfo = class _PeersInfo_ProducerInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeersInfo_ProducerInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeersInfo_ProducerInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeersInfo_ProducerInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeersInfo_ProducerInfo, a, b);
        }
      };
      exports.PeersInfo_ProducerInfo = PeersInfo_ProducerInfo;
      PeersInfo_ProducerInfo.runtime = protobuf_1.proto2;
      PeersInfo_ProducerInfo.typeName = "PeersInfo.ProducerInfo";
      PeersInfo_ProducerInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "label", kind: "scalar", T: 9 }
      ]);
      var RoomInfo = class _RoomInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.peers = [];
          this.lobbyPeers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomInfo, a, b);
        }
      };
      exports.RoomInfo = RoomInfo;
      RoomInfo.runtime = protobuf_1.proto2;
      RoomInfo.typeName = "RoomInfo";
      RoomInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomLocked", kind: "scalar", T: 8 },
        { no: 2, name: "config", kind: "message", T: RoomControls },
        { no: 3, name: "peers", kind: "message", T: PeersInfo, repeated: true },
        { no: 4, name: "lobbyPeers", kind: "message", T: LobbyPeers, repeated: true },
        { no: 5, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "startTime", kind: "scalar", T: 3 }
      ]);
      var LobbyPeers = class _LobbyPeers extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _LobbyPeers().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _LobbyPeers().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _LobbyPeers().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_LobbyPeers, a, b);
        }
      };
      exports.LobbyPeers = LobbyPeers;
      LobbyPeers.runtime = protobuf_1.proto2;
      LobbyPeers.typeName = "LobbyPeers";
      LobbyPeers.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var ConnectRoomResponse = class _ConnectRoomResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          this.turnServers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoomResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoomResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoomResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoomResponse, a, b);
        }
      };
      exports.ConnectRoomResponse = ConnectRoomResponse;
      ConnectRoomResponse.runtime = protobuf_1.proto2;
      ConnectRoomResponse.typeName = "ConnectRoomResponse";
      ConnectRoomResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomId", kind: "scalar", T: 9 },
        { no: 2, name: "roomInfo", kind: "message", T: RoomInfo },
        { no: 3, name: "routerRTPCapabilities", kind: "message", T: rtp_capabilities_pb_js_1.ProtoRtpCapabilities },
        { no: 4, name: "turnServers", kind: "message", T: ConnectRoomResponse_RTCIceServer, repeated: true }
      ]);
      var ConnectRoomResponse_RTCIceServer = class _ConnectRoomResponse_RTCIceServer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoomResponse_RTCIceServer, a, b);
        }
      };
      exports.ConnectRoomResponse_RTCIceServer = ConnectRoomResponse_RTCIceServer;
      ConnectRoomResponse_RTCIceServer.runtime = protobuf_1.proto2;
      ConnectRoomResponse_RTCIceServer.typeName = "ConnectRoomResponse.RTCIceServer";
      ConnectRoomResponse_RTCIceServer.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "urls", kind: "scalar", T: 9 },
        { no: 2, name: "username", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "credential", kind: "scalar", T: 9, opt: true }
      ]);
      var CreateTransportOnClient = class _CreateTransportOnClient extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateTransportOnClient().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateTransportOnClient().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateTransportOnClient().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateTransportOnClient, a, b);
        }
      };
      exports.CreateTransportOnClient = CreateTransportOnClient;
      CreateTransportOnClient.runtime = protobuf_1.proto2;
      CreateTransportOnClient.typeName = "CreateTransportOnClient";
      CreateTransportOnClient.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportSDPInfo", kind: "message", T: sdp_info_pb_js_1.ProtoTransportSDPInfo }
      ]);
      var ConnectTransportResponse = class _ConnectTransportResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectTransportResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectTransportResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectTransportResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectTransportResponse, a, b);
        }
      };
      exports.ConnectTransportResponse = ConnectTransportResponse;
      ConnectTransportResponse.runtime = protobuf_1.proto2;
      ConnectTransportResponse.typeName = "ConnectTransportResponse";
      ConnectTransportResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportId", kind: "scalar", T: 9 }
      ]);
      var ProduceResponse = class _ProduceResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceResponse, a, b);
        }
      };
      exports.ProduceResponse = ProduceResponse;
      ProduceResponse.runtime = protobuf_1.proto2;
      ProduceResponse.typeName = "ProduceResponse";
      ProduceResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ProduceDataResponse = class _ProduceDataResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceDataResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceDataResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceDataResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceDataResponse, a, b);
        }
      };
      exports.ProduceDataResponse = ProduceDataResponse;
      ProduceDataResponse.runtime = protobuf_1.proto2;
      ProduceDataResponse.typeName = "ProduceDataResponse";
      ProduceDataResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "dataProducerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "peerId", kind: "scalar", T: 9 },
        { no: 5, name: "protocol", kind: "scalar", T: 9 },
        { no: 6, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ConsumeDataResponse = class _ConsumeDataResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConsumeDataResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConsumeDataResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConsumeDataResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConsumeDataResponse, a, b);
        }
      };
      exports.ConsumeDataResponse = ConsumeDataResponse;
      ConsumeDataResponse.runtime = protobuf_1.proto2;
      ConsumeDataResponse.typeName = "ConsumeDataResponse";
      ConsumeDataResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "dataProducerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "peerId", kind: "scalar", T: 9 },
        { no: 5, name: "protocol", kind: "scalar", T: 9 },
        { no: 6, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var SyncMeetingStateResponse = class _SyncMeetingStateResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SyncMeetingStateResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SyncMeetingStateResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SyncMeetingStateResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SyncMeetingStateResponse, a, b);
        }
      };
      exports.SyncMeetingStateResponse = SyncMeetingStateResponse;
      SyncMeetingStateResponse.runtime = protobuf_1.proto2;
      SyncMeetingStateResponse.typeName = "SyncMeetingStateResponse";
      SyncMeetingStateResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomInfo", kind: "message", T: RoomInfo }
      ]);
      var ConsumeResponse = class _ConsumeResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConsumeResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConsumeResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConsumeResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConsumeResponse, a, b);
        }
      };
      exports.ConsumeResponse = ConsumeResponse;
      ConsumeResponse.runtime = protobuf_1.proto2;
      ConsumeResponse.typeName = "ConsumeResponse";
      ConsumeResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "consumerId", kind: "scalar", T: 9 },
        { no: 3, name: "producerId", kind: "scalar", T: 9 },
        { no: 4, name: "kind", kind: "scalar", T: 9 },
        { no: 5, name: "rtpParameters", kind: "message", T: rtp_parameters_pb_js_1.ProtoRtpParameters },
        { no: 6, name: "producerPeerId", kind: "scalar", T: 9 },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var CloseProducerSuccess = class _CloseProducerSuccess extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseProducerSuccess().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseProducerSuccess().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseProducerSuccess().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseProducerSuccess, a, b);
        }
      };
      exports.CloseProducerSuccess = CloseProducerSuccess;
      CloseProducerSuccess.runtime = protobuf_1.proto2;
      CloseProducerSuccess.typeName = "CloseProducerSuccess";
      CloseProducerSuccess.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 }
      ]);
      var CloseConsumerSuccess = class _CloseConsumerSuccess extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseConsumerSuccess().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseConsumerSuccess().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseConsumerSuccess().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseConsumerSuccess, a, b);
        }
      };
      exports.CloseConsumerSuccess = CloseConsumerSuccess;
      CloseConsumerSuccess.runtime = protobuf_1.proto2;
      CloseConsumerSuccess.typeName = "CloseConsumerSuccess";
      CloseConsumerSuccess.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "consumerId", kind: "scalar", T: 9 }
      ]);
      var RestartTransportIceResponse = class _RestartTransportIceResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RestartTransportIceResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RestartTransportIceResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RestartTransportIceResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RestartTransportIceResponse, a, b);
        }
      };
      exports.RestartTransportIceResponse = RestartTransportIceResponse;
      RestartTransportIceResponse.runtime = protobuf_1.proto2;
      RestartTransportIceResponse.typeName = "RestartTransportIceResponse";
      RestartTransportIceResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "iceParameters", kind: "message", T: sdp_info_pb_js_1.ProtoIceParameters }
      ]);
      var NewPeerJoined = class _NewPeerJoined extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPeerJoined().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPeerJoined().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPeerJoined().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPeerJoined, a, b);
        }
      };
      exports.NewPeerJoined = NewPeerJoined;
      NewPeerJoined.runtime = protobuf_1.proto2;
      NewPeerJoined.typeName = "NewPeerJoined";
      NewPeerJoined.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "role", kind: "scalar", T: 9, opt: true }
      ]);
      var NewLobbyPeer = class _NewLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewLobbyPeer, a, b);
        }
      };
      exports.NewLobbyPeer = NewLobbyPeer;
      NewLobbyPeer.runtime = protobuf_1.proto2;
      NewLobbyPeer.typeName = "NewLobbyPeer";
      NewLobbyPeer.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var NewPermissions = class _NewPermissions extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPermissions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPermissions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPermissions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPermissions, a, b);
        }
      };
      exports.NewPermissions = NewPermissions;
      NewPermissions.runtime = protobuf_1.proto2;
      NewPermissions.typeName = "NewPermissions";
      NewPermissions.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 2, name: "acl", kind: "message", T: permissions_pb_js_1.Permissions }
      ]);
      var NewRoomControls = class _NewRoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewRoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewRoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewRoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewRoomControls, a, b);
        }
      };
      exports.NewRoomControls = NewRoomControls;
      NewRoomControls.runtime = protobuf_1.proto2;
      NewRoomControls.typeName = "NewRoomControls";
      NewRoomControls.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "controls", kind: "message", T: RoomControls }
      ]);
      var NewPeerRole = class _NewPeerRole extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPeerRole().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPeerRole().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPeerRole().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPeerRole, a, b);
        }
      };
      exports.NewPeerRole = NewPeerRole;
      NewPeerRole.runtime = protobuf_1.proto2;
      NewPeerRole.typeName = "NewPeerRole";
      NewPeerRole.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 }
      ]);
      var ReceiveData = class _ReceiveData extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ReceiveData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ReceiveData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ReceiveData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ReceiveData, a, b);
        }
      };
      exports.ReceiveData = ReceiveData;
      ReceiveData.runtime = protobuf_1.proto2;
      ReceiveData.typeName = "ReceiveData";
      ReceiveData.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "from", kind: "scalar", T: 9 },
        { no: 2, name: "payload", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9, opt: true }
      ]);
      var PeerMetadataUpdated = class _PeerMetadataUpdated extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeerMetadataUpdated().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeerMetadataUpdated().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeerMetadataUpdated().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeerMetadataUpdated, a, b);
        }
      };
      exports.PeerMetadataUpdated = PeerMetadataUpdated;
      PeerMetadataUpdated.runtime = protobuf_1.proto2;
      PeerMetadataUpdated.typeName = "PeerMetadataUpdated";
      PeerMetadataUpdated.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var RoomMetadataUpdated = class _RoomMetadataUpdated extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomMetadataUpdated().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomMetadataUpdated().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomMetadataUpdated().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomMetadataUpdated, a, b);
        }
      };
      exports.RoomMetadataUpdated = RoomMetadataUpdated;
      RoomMetadataUpdated.runtime = protobuf_1.proto2;
      RoomMetadataUpdated.typeName = "RoomMetadataUpdated";
      RoomMetadataUpdated.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var RoomClosedProducers = class _RoomClosedProducers extends protobuf_1.Message {
        constructor(data) {
          super();
          this.producers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers, a, b);
        }
      };
      exports.RoomClosedProducers = RoomClosedProducers;
      RoomClosedProducers.runtime = protobuf_1.proto2;
      RoomClosedProducers.typeName = "RoomClosedProducers";
      RoomClosedProducers.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producers", kind: "message", T: RoomClosedProducers_CloseProducerInfo, repeated: true },
        { no: 2, name: "reason", kind: "message", T: RoomClosedProducers_CloseProducerReason }
      ]);
      var RoomClosedProducers_CloseProducerInfo = class _RoomClosedProducers_CloseProducerInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers_CloseProducerInfo, a, b);
        }
      };
      exports.RoomClosedProducers_CloseProducerInfo = RoomClosedProducers_CloseProducerInfo;
      RoomClosedProducers_CloseProducerInfo.runtime = protobuf_1.proto2;
      RoomClosedProducers_CloseProducerInfo.typeName = "RoomClosedProducers.CloseProducerInfo";
      RoomClosedProducers_CloseProducerInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 }
      ]);
      var RoomClosedProducers_CloseProducerReason = class _RoomClosedProducers_CloseProducerReason extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers_CloseProducerReason, a, b);
        }
      };
      exports.RoomClosedProducers_CloseProducerReason = RoomClosedProducers_CloseProducerReason;
      RoomClosedProducers_CloseProducerReason.runtime = protobuf_1.proto2;
      RoomClosedProducers_CloseProducerReason.typeName = "RoomClosedProducers.CloseProducerReason";
      RoomClosedProducers_CloseProducerReason.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "code", kind: "scalar", T: 5 },
        { no: 2, name: "tag", kind: "scalar", T: 9 },
        { no: 3, name: "message", kind: "scalar", T: 9 }
      ]);
      var PeerLeft = class _PeerLeft extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeerLeft().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeerLeft().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeerLeft().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeerLeft, a, b);
        }
      };
      exports.PeerLeft = PeerLeft;
      PeerLeft.runtime = protobuf_1.proto2;
      PeerLeft.typeName = "PeerLeft";
      PeerLeft.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var LobbyPeerLeft = class _LobbyPeerLeft extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _LobbyPeerLeft().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _LobbyPeerLeft().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _LobbyPeerLeft().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_LobbyPeerLeft, a, b);
        }
      };
      exports.LobbyPeerLeft = LobbyPeerLeft;
      LobbyPeerLeft.runtime = protobuf_1.proto2;
      LobbyPeerLeft.typeName = "LobbyPeerLeft";
      LobbyPeerLeft.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "scalar", T: 9 },
        { no: 3, name: "message", kind: "scalar", T: 9, opt: true }
      ]);
      var WaitingRoom = class _WaitingRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _WaitingRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _WaitingRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _WaitingRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_WaitingRoom, a, b);
        }
      };
      exports.WaitingRoom = WaitingRoom;
      WaitingRoom.runtime = protobuf_1.proto2;
      WaitingRoom.typeName = "WaitingRoom";
      WaitingRoom.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "reason", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var Error2 = class _Error extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Error().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Error().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Error().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Error, a, b);
        }
      };
      exports.Error = Error2;
      Error2.runtime = protobuf_1.proto2;
      Error2.typeName = "Error";
      Error2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "event", kind: "scalar", T: 9 },
        { no: 2, name: "error", kind: "scalar", T: 9 }
      ]);
      var Response2 = class _Response extends protobuf_1.Message {
        constructor(data) {
          super();
          this.Response = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Response().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Response().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Response().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Response, a, b);
        }
      };
      exports.Response = Response2;
      Response2.runtime = protobuf_1.proto2;
      Response2.typeName = "Response";
      Response2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "hello", kind: "message", T: Hello, oneof: "Response" },
        { no: 2, name: "connectRoomResponse", kind: "message", T: ConnectRoomResponse, oneof: "Response" },
        { no: 3, name: "createTransportOnClient", kind: "message", T: CreateTransportOnClient, oneof: "Response" },
        { no: 4, name: "produceResponse", kind: "message", T: ProduceResponse, oneof: "Response" },
        { no: 25, name: "consumeDataResponse", kind: "message", T: ConsumeDataResponse, oneof: "Response" },
        { no: 5, name: "produceDataResponse", kind: "message", T: ProduceDataResponse, oneof: "Response" },
        { no: 6, name: "syncMeetingStateResponse", kind: "message", T: SyncMeetingStateResponse, oneof: "Response" },
        { no: 7, name: "consumeResponse", kind: "message", T: ConsumeResponse, oneof: "Response" },
        { no: 8, name: "closeProducerSuccess", kind: "message", T: CloseProducerSuccess, oneof: "Response" },
        { no: 9, name: "closeConsumerSuccess", kind: "message", T: CloseConsumerSuccess, oneof: "Response" },
        { no: 10, name: "connectTransportResponse", kind: "message", T: ConnectTransportResponse, oneof: "Response" },
        { no: 11, name: "restartTransportIceResponse", kind: "message", T: RestartTransportIceResponse, oneof: "Response" },
        { no: 12, name: "newPeerJoined", kind: "message", T: NewPeerJoined, oneof: "Response" },
        { no: 13, name: "newLobbyPeer", kind: "message", T: NewLobbyPeer, oneof: "Response" },
        { no: 14, name: "newPermissions", kind: "message", T: NewPermissions, oneof: "Response" },
        { no: 15, name: "newRoomControls", kind: "message", T: NewRoomControls, oneof: "Response" },
        { no: 16, name: "newPeerRole", kind: "message", T: NewPeerRole, oneof: "Response" },
        { no: 17, name: "receiveData", kind: "message", T: ReceiveData, oneof: "Response" },
        { no: 18, name: "peerMetadataUpdated", kind: "message", T: PeerMetadataUpdated, oneof: "Response" },
        { no: 19, name: "roomMetadataUpdated", kind: "message", T: RoomMetadataUpdated, oneof: "Response" },
        { no: 20, name: "roomClosedProducers", kind: "message", T: RoomClosedProducers, oneof: "Response" },
        { no: 21, name: "peerLeft", kind: "message", T: PeerLeft, oneof: "Response" },
        { no: 22, name: "lobbyPeerLeft", kind: "message", T: LobbyPeerLeft, oneof: "Response" },
        { no: 23, name: "waitingRoom", kind: "message", T: WaitingRoom, oneof: "Response" },
        { no: 24, name: "error", kind: "message", T: Error2, oneof: "Response" }
      ]);
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Consumer: () => Consumer_default,
    DeviceHandler: () => DeviceHandler_default,
    HuddleClient: () => HuddleClient_default,
    LocalPeer: () => LocalPeer_default,
    Permissions: () => Permissions_default,
    RemotePeer: () => RemotePeer_default,
    Room: () => Room_default,
    Socket: () => Socket_default,
    Transport: () => Transport_default
  });

  // src/LocalPeer.ts
  var import_mediasoup_client = __toESM(require_lib4(), 1);

  // src/common-js/EnhancedEventEmitter.ts
  var import_events = __toESM(require_events(), 1);
  var EnhancedEventEmitter = class {
    emitter;
    constructor() {
      this.emitter = new import_events.EventEmitter();
      this.emitter.setMaxListeners(Infinity);
    }
    on(eventName, listener) {
      this.emitter.on(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: need to override the type because default it's any[ and we cannot assign E[K] to any[]
        listener
      );
      return this;
    }
    off(eventName, listener) {
      this.emitter.off(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    listenerCount(eventName) {
      return this.emitter.listenerCount(eventName);
    }
    listeners(eventName) {
      return this.emitter.listeners(eventName);
    }
    emit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    safeEmit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    once(eventName, listener) {
      this.emitter.once(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    removeAllListeners(eventName) {
      if (eventName) {
        this.emitter.removeAllListeners(eventName);
      } else {
        this.emitter.removeAllListeners();
      }
      return this;
    }
  };

  // src/constants/rtpConstants.ts
  var VIDEO_CONSTRAINTS = {
    qvga: { width: { ideal: 320 }, height: { ideal: 240 } },
    vga: { width: { ideal: 640 }, height: { ideal: 480 } },
    hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
    fHd: { width: { ideal: 1920 }, height: { ideal: 1080 } },
    qHd: { width: { ideal: 4096 }, height: { ideal: 2160 } }
  };
  var WEBCAM_SIMULCAST_ENCODINGS = [
    {
      scaleResolutionDownBy: 4,
      maxBitrate: 3e5,
      // 300kbps
      rid: "r0",
      scalabilityMode: "S1T3",
      maxFramerate: 15
    },
    {
      scaleResolutionDownBy: 2,
      maxBitrate: 6e5,
      // 600kbps
      rid: "r1",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    },
    {
      scaleResolutionDownBy: 1,
      maxBitrate: 9e6,
      // 900kbps
      rid: "r2",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    }
  ];
  var encodingViaMediaType = {
    video: WEBCAM_SIMULCAST_ENCODINGS,
    "screen-share-video": void 0,
    audio: [{ maxBitrate: 128e3 }]
  };
  var codecOptionsViaKind = {
    audio: { opusStereo: true, opusFec: true, opusDtx: true },
    video: { videoGoogleStartBitrate: 1e3 }
  };

  // src/constants/deviceConstraints.ts
  var videoDefaultConstraints = {
    video: {
      ...VIDEO_CONSTRAINTS.hd
    }
  };
  var audioConstraints = {
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var shareConstraints = {
    video: {
      displaySurface: "monitor",
      logicalSurface: true,
      cursor: true,
      width: { ideal: 1920, max: 1920 },
      height: { ideal: 1080, max: 1080 },
      frameRate: { ideal: 25, max: 30 }
    },
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var defaultMediaConstraints = {
    cam: videoDefaultConstraints,
    mic: audioConstraints,
    screen: shareConstraints
  };
  var deviceConstraints_default = defaultMediaConstraints;

  // src/logger.ts
  var COLORS = {
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
    default: "\x1B[39m"
  };
  var defaultLevel = "error";
  var created = Date.now();
  function createDefaultLoggerFactory() {
    return () => {
      const trace = (...args) => {
        console.trace(...args);
      };
      const debug = (...args) => {
        console.debug(...args);
      };
      const info = (...args) => {
        console.info(...args);
      };
      const warn = (...args) => {
        console.warn(...args);
      };
      const error = (...args) => {
        console.error(...args);
      };
      return {
        trace,
        debug,
        info,
        warn,
        error
      };
    };
  }
  var wrapLogger = (logger12, moduleName, logLevel) => {
    let isTrace = false;
    let isDebug = false;
    let isInfo = false;
    let isWarning = false;
    let isError = false;
    let _level = logLevel;
    let _logger = logger12;
    const tracePrefix = `${COLORS.magenta}[TRACE]${COLORS.default} ${moduleName}`;
    const debugPrefix = `${COLORS.cyan}[DEBUG]${COLORS.default} ${moduleName}`;
    const infoPrefix = `${COLORS.green}[INFO]${COLORS.default} ${moduleName}`;
    const warnPrefix = `${COLORS.yellow}[WARN]${COLORS.default} ${moduleName}`;
    const errorPrefix = `${COLORS.red}[ERROR]${COLORS.default} ${moduleName}`;
    const result = new class {
      init() {
        isTrace = ["trace"].includes(_level ?? defaultLevel);
        isDebug = ["trace", "debug"].includes(_level ?? defaultLevel);
        isInfo = ["trace", "debug", "info"].includes(_level ?? defaultLevel);
        isWarning = ["trace", "debug", "info", "warn"].includes(
          _level ?? defaultLevel
        );
        isError = ["trace", "debug", "info", "warn", "error"].includes(
          _level ?? defaultLevel
        );
      }
      get logger() {
        return _logger;
      }
      set logger(value) {
        _logger = value;
      }
      get level() {
        return _level;
      }
      set level(value) {
        _level = value;
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      trace(...args) {
        if (isTrace) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.trace(tracePrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      debug(...args) {
        if (isDebug) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.debug(debugPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      info(...args) {
        if (isInfo) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.info(infoPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      warn(...args) {
        if (isWarning) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.warn(warnPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      error(...args) {
        if (isError) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.error(errorPrefix, ...args, elapsedInMs);
        }
      }
    }();
    return result;
  };
  var actualLoggerFactory = createDefaultLoggerFactory();
  var loggers = /* @__PURE__ */ new Map();
  var createLogger = (moduleName, logLevel) => {
    let wrappedLogger = loggers.get(moduleName);
    if (!wrappedLogger) {
      const logger12 = actualLoggerFactory();
      wrappedLogger = wrapLogger(logger12, moduleName, logLevel ?? defaultLevel);
      loggers.set(moduleName, wrappedLogger);
    } else {
      wrappedLogger.level = logLevel ?? defaultLevel;
    }
    wrappedLogger.init();
    return wrappedLogger;
  };
  var setLogLevel = (level) => {
    defaultLevel = level;
    for (const [moduleName] of Array.from(loggers.entries())) {
      loggers.set(moduleName, createLogger(moduleName, level));
    }
  };
  var mainLogger = {
    createSubLogger: (moduleName) => createLogger(`HuddleWebCore:${moduleName}`)
  };

  // src/DeviceHandler.ts
  var logger = mainLogger.createSubLogger("DeviceHandler");
  var CustomMediaKindToSystemKind = {
    cam: "videoinput",
    mic: "audioinput",
    speaker: "audiooutput"
  };
  var DeviceHandler = class extends EnhancedEventEmitter {
    SCREEN_DEFAULT_DEVICE = "monitor";
    /**
     * User Selected Devices, If no device is selected, it will use the default device of the system
     *
     * is preffered device is null, it will use the default device of the system
     *
     * `NOTE: User has the ability to select a preferred device for each media kind`
     */
    __preferredDevices = /* @__PURE__ */ new Map([
      ["cam", null],
      ["mic", null],
      ["speaker", null]
    ]);
    /**
     * Map the media devices currently present in the system
     */
    __mediaDevicesInfo = /* @__PURE__ */ new Map([
      ["cam", []],
      ["mic", []],
      ["speaker", []]
    ]);
    /**
     * Get all the devices which are currently available in the system
     */
    get devices() {
      return this.__mediaDevicesInfo;
    }
    get preferredDevices() {
      return this.__preferredDevices;
    }
    /**
     * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record
     *
     * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`
     *
     * @param deviceKind `cam` | `mic` | `speaker` | `undefined`
     * @returns - MediaDeviceInfo[] | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getMediaDevices = async (filterByDeviceKind, shouldFetchStream = false) => {
      logger.info("\u{1F4F9} Fetching Media Devices");
      let constraints;
      if (filterByDeviceKind === "speaker" || filterByDeviceKind === "device-change") {
        constraints = deviceConstraints_default.mic;
      } else if (filterByDeviceKind) {
        constraints = deviceConstraints_default[filterByDeviceKind];
      } else {
        constraints = {
          ...deviceConstraints_default.mic,
          ...deviceConstraints_default.cam
        };
      }
      let devices = [];
      if (shouldFetchStream) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints).catch((err) => {
          logger.error("fetching stream failed", err);
        });
        devices = await navigator.mediaDevices.enumerateDevices();
        if (stream) {
          const tracks = stream.getTracks();
          for (const track of tracks) {
            track.stop();
          }
        }
      } else {
        devices = await navigator.mediaDevices.enumerateDevices();
      }
      if (!filterByDeviceKind || filterByDeviceKind === "device-change") {
        this.__setMediaDeviceInfo({ devices, update: "all" });
      }
      if (filterByDeviceKind === "cam" || filterByDeviceKind === "mic") {
        this.__setMediaDeviceInfo({ devices, update: filterByDeviceKind });
      }
      const mediaDevices = devices.filter((device) => {
        if (device.deviceId === "" || device.label === "") {
          return false;
        }
        if (filterByDeviceKind && filterByDeviceKind !== "device-change") {
          const systemDeviceKind = CustomMediaKindToSystemKind[filterByDeviceKind];
          return device.kind === systemDeviceKind;
        }
        return true;
      });
      return mediaDevices;
    };
    /**
     * Get the device from the given facing type of device
     *
     * This function is used for only RN
     *
     * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }
     * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }
     * @returns - deviceId: string | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getDeviceFromFacingMode = (facing, mediaDeviceKind) => {
      const allDevices = this.__mediaDevicesInfo.get(mediaDeviceKind);
      if (allDevices) {
        const d = allDevices.find((device) => device.facing === facing);
        if (d) {
          if (mediaDeviceKind === "cam") {
            return facing || d.deviceId;
          }
          return d.deviceId;
        }
      }
      return null;
    };
    setPreferredDevice = (data) => {
      const { deviceId, deviceKind } = data;
      this.__preferredDevices.set(deviceKind, deviceId);
      this.emit("preferred-device-change", {
        deviceId,
        deviceKind
      });
    };
    /**
     * Fetches a stream of the screen of the device i.e the screen sharing stream
     * based on the selected choice from the pop up returns the audio and video stream
     * in one stream.
     *
     * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`
     * @returns
     */
    fetchScreen = async () => {
      const constraints = deviceConstraints_default.screen;
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
        return { stream };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        return {
          stream: null,
          error
        };
      }
    };
    /**
     * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.
     * by default the preferred device is the system default device
     *
     * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`
     * `Set the preferred device using setPreferredDevice()`
     *
     */
    fetchStream = async (data) => {
      const preferredDeviceId = this.__preferredDevices.get(data.mediaDeviceKind);
      logger.info("\u{1F4F9} Fetching Stream", {
        mediaDeviceKind: data.mediaDeviceKind,
        preferredDeviceId
      });
      navigator.mediaDevices.ondevicechange = async () => {
        const newMediaDevices = await this.getMediaDevices("device-change");
        for (const [deviceKind, deviceId] of this.__preferredDevices) {
          const device = newMediaDevices.find((d) => d.deviceId === deviceId);
          if (!device) {
            this.setPreferredDevice({ deviceId: null, deviceKind });
          }
        }
        this.emit("device-change");
      };
      try {
        let fetchStreamFunc;
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          fetchStreamFunc = this.__fetchStreamFromDeviceForRN;
        } else {
          fetchStreamFunc = this.__fetchStreamFromDeviceForWeb;
        }
        const { stream, deviceId } = await fetchStreamFunc({
          deviceId: preferredDeviceId ?? void 0,
          mediaKind: data.mediaDeviceKind === "mic" ? "mic" : "cam"
        });
        const track = data.mediaDeviceKind === "mic" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];
        if (!this.__preferredDevices.get(data.mediaDeviceKind)) {
          this.setPreferredDevice({ deviceId, deviceKind: data.mediaDeviceKind });
        }
        return {
          stream,
          track,
          deviceId
        };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        return {
          stream: null,
          track: null,
          deviceId: null,
          error
        };
      }
    };
    fetchStreamByGroupId = async (data) => {
      let constraints;
      if (data.mediaDeviceKind === "mic") {
        constraints = { audio: { groupId: data.groupId } };
      } else {
        constraints = { video: { groupId: data.groupId } };
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      return stream;
    };
    /**
     * Fetch the stream from the device for the React Native Based Application
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: "front" | "back" | "audio" | string; kind: "audioinput" | "videoinput" }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForRN = async (data) => {
      const constraints = deviceConstraints_default[data.mediaKind];
      let facingMode;
      if (data.mediaKind === "cam") {
        facingMode = data.deviceId === "environment" ? "environment" : "front";
        constraints.video = Object.assign({}, constraints.video, {
          facingMode
        });
      }
      if (data.mediaKind === "mic") {
        constraints.audio = Object.assign({}, constraints.audio, {
          deviceId: data.deviceId
        });
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = this.getDeviceFromFacingMode(
        facingMode,
        data.mediaKind === "mic" ? "mic" : "cam"
      );
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the SDK, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: streamDeviceId
      };
    };
    /**
     * Fetch the stream from the device for the web
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: string; kind: 'audio' | 'video' }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForWeb = async (data) => {
      const constraints = Object.assign(
        {},
        deviceConstraints_default[data.mediaKind]
      );
      if (data.mediaKind === "cam" && data.deviceId) {
        constraints.video = Object.assign({}, constraints.video, {
          deviceId: data.deviceId
        });
      }
      if (data.mediaKind === "mic" && data.deviceId) {
        constraints.audio = Object.assign({}, constraints.audio, {
          deviceId: {
            exact: data.deviceId
          }
        });
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = stream.getTracks()[0].getSettings().deviceId;
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the browser, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: streamDeviceId
      };
    };
    /**
     * @description Get the media permission for the given type
     * @param data  { type: 'video' | 'audio' }
     * @throws error { StreamPermissionsError }
     * @example await getMediaPermission({ type: 'video' })
     */
    getMediaPermission = async (data) => {
      const { mediaDeviceKind } = data;
      try {
        await this.getMediaDevices(mediaDeviceKind);
        this.emit("permission-granted", { deviceKind: mediaDeviceKind });
        return {
          permission: "granted"
        };
      } catch (err) {
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        this.emit("permission-denied", { deviceKind: mediaDeviceKind, error });
        return {
          permission: "denied",
          error
        };
      }
    };
    stopStream = (stream) => {
      if (!stream)
        return;
      for (const track of stream.getTracks()) {
        track.stop();
      }
    };
    destroy = () => {
      this.__preferredDevices.clear();
      this.__mediaDevicesInfo.clear();
      logger.info("\u2705 Destroyed StreamHandler");
    };
    /**
     * Set the Media devices info based on the latest devices available in the system
     */
    __setMediaDeviceInfo = (data) => {
      const { devices, update } = data;
      const camDevices = [];
      const micDevices = [];
      const speakerDevices = [];
      for (const device of devices) {
        if (device.label === "" || device.deviceId === "")
          continue;
        if (device.kind === "videoinput")
          camDevices.push(device);
        if (device.kind === "audioinput")
          micDevices.push(device);
        if (device.kind === "audiooutput")
          speakerDevices.push(device);
      }
      if (update === "all") {
        this.__mediaDevicesInfo.set("cam", camDevices);
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
      if (update === "cam")
        this.__mediaDevicesInfo.set("cam", camDevices);
      if (update === "mic") {
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
    };
  };
  var DeviceHandler_default = DeviceHandler;

  // src/Socket.ts
  var import_socket = __toESM(require_socket_types(), 1);

  // ../../node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[a-z][a-z0-9]*$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField2 = fieldSchema;
          while (newField2 instanceof ZodOptional) {
            newField2 = newField2._def.innerType;
          }
          newShape[key] = newField2;
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return _ZodEnum.create(values);
    }
    exclude(values) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if (isValid(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // src/validators/common.validators.ts
  var ConnectionParameterSchema = z.object({
    roomId: z.string({
      required_error: "Room id must provided"
    }),
    token: z.string({
      required_error: "Token must provided"
    })
  });
  var GeolocationSchema = z.object({
    country: z.string({
      required_error: "Country must provided"
    }),
    latitude: z.string({
      required_error: "Latitude must provided"
    }),
    longitude: z.string({
      required_error: "Longitude must provided"
    }),
    region: z.string({
      required_error: "Region must provided"
    }),
    globalRegion: z.string({
      required_error: "Global region must provided"
    }),
    ip: z.string({
      required_error: "IP must provided"
    })
  });
  var VolatileDataMessageSchema = z.object({
    from: z.string(),
    payload: z.unknown(),
    label: z.string().optional(),
    to: z.union([z.literal("*"), z.array(z.string())]).optional()
  });
  var DataMessageSchema = z.object({
    from: z.string(),
    payload: z.string(),
    label: z.string().optional()
  });

  // src/Socket.ts
  var import_request_pb = __toESM(require_request_pb(), 1);
  var import_response_pb = __toESM(require_response_pb(), 1);

  // src/request.events.ts
  var ProtoRequest = __toESM(require_request_pb(), 1);
  var ProtoRequestEvent = {
    acceptLobbyPeer: ProtoRequest.AcceptLobbyPeer,
    activateSpeakerNotification: ProtoRequest.ActivateSpeakerNotification,
    createDataConsumer: ProtoRequest.CreateDataConsumer,
    closeConsumer: ProtoRequest.CloseConsumer,
    closeProducer: ProtoRequest.CloseProducer,
    closeRoom: ProtoRequest.CloseRoom,
    connectRoom: ProtoRequest.ConnectRoom,
    closeStreamOfLabel: ProtoRequest.CloseStreamOfLabel,
    connectTransport: ProtoRequest.ConnectTransport,
    consume: ProtoRequest.Consume,
    createTransport: ProtoRequest.CreateTransport,
    denyLobbyPeer: ProtoRequest.DenyLobbyPeer,
    kickPeer: ProtoRequest.KickPeer,
    produce: ProtoRequest.Produce,
    produceData: ProtoRequest.ProduceData,
    restartTransportIce: ProtoRequest.RestartTransportIce,
    resumeConsumer: ProtoRequest.ResumeConsumer,
    sendData: ProtoRequest.SendData,
    syncMeetingState: ProtoRequest.SyncMeetingState,
    updatePeerMetadata: ProtoRequest.UpdatePeerMetadata,
    updatePeerPermission: ProtoRequest.UpdatePeerPermission,
    updatePeerRole: ProtoRequest.UpdatePeerRole,
    updateRoomControls: ProtoRequest.UpdateRoomControls,
    updateRoomMetadata: ProtoRequest.UpdateRoomMetadata
  };

  // src/Socket.ts
  var logger2 = mainLogger.createSubLogger("Socket.ts");
  var Socket = class _Socket extends EnhancedEventEmitter {
    /**
     * Socket Instance, Singleton class
     */
    static __instance = null;
    /**
     * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times
     */
    __retryCount = 0;
    /**
     * Current connection state of the socket connection
     */
    __connectionState = "uninitialized";
    /**
     * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null
     */
    __ws = null;
    /**
     * Map of all the subscribed events/topics for the socket connection
     */
    __subscribedMap = /* @__PURE__ */ new Map();
    /**
     * Region of the current socket connection, specific to the Local Peer who joined the meeting
     */
    __region = null;
    /**
     * Endpoint of the socket server, this is fetched from the API server
     */
    __ENDPOINT = null;
    /**
     * Flag to enable local development
     */
    isLocalDev = false;
    /**
     * Token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    token = null;
    /**
     * Returns the underlying WebSocket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    get ws() {
      if (!this.__ws) {
        throw new Error("\u{1F534} Socket Not Initialised");
      }
      return this.__ws;
    }
    /**
     * Getter for the region of the current socket connection
     */
    get region() {
      return this.__region;
    }
    /**
     * Returns the current connection state of the socket connection
     */
    get connectionState() {
      return this.__connectionState;
    }
    /**
     * Returns true if the socket connection is connected
     */
    get connected() {
      return this.__ws?.OPEN === 1 && this.connectionState === "connected";
    }
    /**
     * Returns true if the socket connection is connecting
     */
    get connecting() {
      return this.__ws?.CONNECTING === 0 && this.connectionState === "connecting";
    }
    /**
     * Returns true if the socket connection is closed
     */
    get closed() {
      return this.__ws?.CLOSED === 3 || this.__ws?.CLOSING === 2;
    }
    /**
     * Sets the current connection state of the socket connection
     */
    set connectionState(state) {
      logger2.info(`\u{1F50C} WebSocket state changed to ${state}`);
      this.__connectionState = state;
    }
    /**
     * Update the token for this socket
     * @throws `Error` if the token is already set
     */
    setToken(token) {
      if (this.token) {
        throw new Error("\u{1F534} Token Already Set");
      }
      this.token = token;
      this.emit("token-updated", token);
    }
    /**
     * Set a new region for the socket connection
     */
    setRegion(region) {
      this.__region = region;
      this.emit("region-updated", region);
    }
    /**
     * Creates the socket and returns the instance of the socket if already initialized
     * you need to call connect method to connect to the server
     * @param data
     * @returns
     */
    static create() {
      if (!this.__instance) {
        this.__instance = new _Socket();
      }
      return this.__instance;
    }
    /**
     * Returns the instance of the socket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    static getInstance() {
      if (!_Socket.__instance) {
        throw new Error(
          "\u{1F534} Socket Instance Not Initialised, You are trying to do something which is not possible"
        );
      }
      return _Socket.__instance;
    }
    constructor() {
      super();
    }
    /**
     *
     */
    __getRegion = async () => {
      const resp = await fetch(
        "https://shinigami.huddle01.com/api/get-geolocation"
      );
      const data = await resp?.json();
      const geolocationdata = GeolocationSchema.safeParse(data);
      if (!geolocationdata.success) {
        throw new Error("\u{1F534} Error While Finding the Region to connect to");
      }
      const region = geolocationdata.data.globalRegion;
      return region;
    };
    enableLocalDev = () => {
      this.isLocalDev = true;
    };
    /**
     * Connect to the socket server using the token
     * @param data - `{ token: string }`
     */
    connect = async (data) => {
      if (!_Socket.__instance) {
        throw new Error("\u{1F534} Socket Instance Not Initialised");
      }
      if (!this.token) {
        this.setToken(data.token);
      }
      if (this.connectionState === "connected") {
        logger2.error("\u{1F534} Socket Already Connected");
        return _Socket.__instance;
      }
      if (this.connectionState === "connecting") {
        logger2.error("\u{1F534} Socket Already Connecting");
        return _Socket.__instance;
      }
      if (this.__ws) {
        logger2.error("\u{1F534} Socket Already Initialized");
        return _Socket.__instance;
      }
      logger2.info("\u{1F50C} Connecting to the socket server");
      if (!this.__region) {
        const region = await this.__getRegion();
        this.__region = region;
      }
      const url = await this.__getConfigUrl(data.token, this.__region);
      this.connectionState = "connecting";
      this.emit("connecting");
      this.__ws = new WebSocket(url);
      this.__ws.binaryType = "arraybuffer";
      this.__ws.onmessage = this.__handleIncomingMessage;
      this.__registerSocketEvents(this.ws);
      const socketConnectionPromise = new Promise((resolve, reject) => {
        const handleSuccess = () => {
          logger2.info("\u2705 WebSocket Connection Established Promise Resolved");
          handleRemoveListeners();
          resolve();
        };
        const handleClose = () => {
          logger2.error(
            "\u{1F534} Error Connecting WebSocket, Closing the Connection, Try Again."
          );
          handleRemoveListeners();
          reject(
            new Error(
              "\u274C Error Connecting WebSocket, Closing the Connection, Try Again."
            )
          );
        };
        const handleRemoveListeners = () => {
          this.off("connected", handleSuccess);
          this.off("closed", handleClose);
        };
        this.once("connected", handleSuccess);
        this.once("closed", handleClose);
      });
      await socketConnectionPromise;
      return _Socket.__instance;
    };
    /**
     * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as
     * any other information related to the connection.
     * @param code `{ ESocketCloseCode }`
     */
    close = (code, reconnect = false) => {
      if (this.__ws) {
        this.__ws.onmessage = null;
      }
      const reason = import_socket.SocketCloseReason[code];
      const isNative = navigator?.product === "ReactNative";
      if (code >= 3e3 && code <= 4999 || code === 1e3 || // 1001 is going_away, which is the code for all server closes in react-native but could also be a cloudflare close,
      // if reconnect is true then cloudflare has dropped the connection so try reconnecting in both web and mobile
      //
      code === 1001 && isNative && !reconnect) {
        logger2.info(`\u{1F534} Closing the WebSocket Connection, ${code} ${reason}`);
        this.__ws?.close(code, reason);
        this.__ws = null;
        this.token = null;
        this.__ENDPOINT = null;
        this.emit("token-updated", null);
        this.connectionState = "closed";
        this.emit("closed", code);
        logger2.info("\u{1F50C} WebSocket Connection closed");
        return;
      }
      this.__ws?.close();
      if (this.__ws) {
        this.__unregisterSocketEvents(this.ws);
      }
      this.__ws = null;
      if (code === import_socket.ESocketCloseCode.ABNORMAL_CLOSURE || reconnect) {
        logger2.info(
          "\u{1F50C} Socket Connection closed abnormally, Trying to Reconnect",
          {
            code,
            reason
          }
        );
        if (this.__retryCount < 7) {
          const delay = 2 ** this.__retryCount * 1e3;
          setTimeout(() => {
            if (this.token) {
              try {
                logger2.info(
                  "\u{1F514} Trying to reconnect, Attempt:",
                  this.__retryCount
                );
                this.connectionState = "reconnecting";
                this.emit("reconnecting");
                this.connect({ token: this.token }).then(() => {
                  if (this.__retryCount > 0) {
                    this.emit("reconnected");
                  }
                  this.__retryCount = 0;
                }).catch(() => {
                  if (this.__retryCount === 7) {
                    logger2.error("All Reconnection Attempt failed");
                  }
                });
              } catch (err) {
                logger2.error(`Reconnection Attempt ${this.__retryCount} failed`);
              }
            }
          }, Math.min(delay, 2e4));
          this.__retryCount++;
        } else {
          logger2.error(
            "\u{1F534} Socket connection closed abnormally, reconnecting failed"
          );
          this.close(import_socket.ESocketCloseCode.CONNECTION_EXPIRED);
        }
      } else {
        logger2.info("\u{1F50C} Socket Connection closed", code, reason);
        this.connectionState = "closed";
        this.emit("closed", code);
      }
    };
    /**
     * Publish a message to the server using the socket connection based on some events/topics
     */
    publish = (event, data) => {
      try {
        const message = new import_request_pb.Request({
          request: {
            case: event,
            value: new ProtoRequestEvent[event](data)
          }
        });
        const binaryData = message.toBinary();
        this.ws.send(binaryData);
      } catch (error) {
        logger2.error("\u{1F534} Error While Sending the Message", error);
      }
    };
    /**
     * Subscribe to a specific event/topic from the server
     */
    subscribe = (event, fn) => {
      if (this.__subscribedMap.has(event)) {
        logger2.warn("\u26A0\uFE0F Overriding existing event handler");
      }
      this.__subscribedMap.set(event, fn);
    };
    /**
     * Get the config url for the socket connection based on the token and region
     * @param token Local Peer specific meeting token
     * @param region Local Peer specific region
     * @returns
     */
    async __getConfigUrl(token, region) {
      if (this.__ENDPOINT) {
        return this.__ENDPOINT;
      }
      const apiServerUrl = this.isLocalDev ? "http://localhost:8000/api/v1" : "https://apira.huddle01.media/api/v1";
      const res = await fetch(`${apiServerUrl}/getSushiUrl`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          authorization: `Bearer ${token}`
        }
      });
      if (!res.ok) {
        throw new Error("\u{1F534} Error While Fetching the Url");
      }
      const { url, sessionId } = await res.json();
      this.__ENDPOINT = url.replace("https://", "wss://").replace("http://", "ws://");
      const wssAddress = `${this.__ENDPOINT}/ws`;
      const wsAddress = `${wssAddress}?${[
        `token=${token}`,
        `version=${2}`,
        `region=${region}`,
        `sessionId=${sessionId}`
      ].join("&")}`;
      this.__ENDPOINT = wsAddress;
      return wsAddress;
    }
    /**
     * !Important
     * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler
     */
    __handleIncomingMessage = (event) => {
      try {
        const eventData = new Uint8Array(event.data);
        const msg = import_response_pb.Response.fromBinary(eventData).Response;
        logger2.debug("\u{1F4E8} Incoming message", msg);
        const eventName = msg.case;
        if (eventName === void 0) {
          throw new Error("\u{1F534} Can't find the event name, Found: { undefined }");
        }
        const data = JSON.parse(JSON.stringify(msg.value));
        logger2.info("\u{1F4E8} Incoming message event name: ", eventName);
        const fn = this.__subscribedMap.get(eventName);
        if (fn) {
          fn(data);
        }
      } catch (error) {
        logger2.error("\u{1F534} Error: Handling Incoming Message", error);
      }
    };
    __handleSocketError = (ev) => {
      logger2.error("\u274C Socket connection error", ev);
    };
    /**
     * @description Handle the socket close event which is sent by the server
     * @param ev CloseEvent
     */
    __handleSocketClose = async (ev) => {
      logger2.info("\u{1F514} Socket connection closed emitted", ev);
      const code = ev.code;
      const reason = ev.reason;
      const isCloudflareClose = reason?.toLowerCase().includes("cloudflare");
      this.close(code, isCloudflareClose);
    };
    /**
     * @description Handle the socket open event which is sent after the connection is established with the server
     * @param ev Event
     */
    __handleSocketOpen = (ev) => {
      logger2.debug("WebSocket Connection Open", ev);
      this.connectionState = "connected";
      this.emit("connected");
    };
    /**
     * @description Register the socket events
     * @param ws WebSocket
     */
    __registerSocketEvents = (ws) => {
      ws.onerror = this.__handleSocketError;
      ws.onclose = this.__handleSocketClose;
      ws.onopen = this.__handleSocketOpen;
    };
    /**
     * @description Unregister the socket events
     * @param ws WebSocket
     */
    __unregisterSocketEvents = (ws) => {
      ws.onerror = null;
      ws.onclose = null;
      ws.onopen = null;
    };
  };
  var Socket_default = Socket;

  // src/Permissions.ts
  var logger3 = mainLogger.createSubLogger("Permissions");
  var Permissions = class _Permissions extends EnhancedEventEmitter {
    /**
     * Get the Singleton Instance of the Permissions Class.
     */
    static __instance;
    /**
     * Admin Access of the Room.
     */
    __admin = false;
    /**
     * Can Consume Media Stream of the Room from RemotePeers;
     */
    __canConsume = false;
    /**
     * Can Produce Media Stream to the Room
     */
    __canProduce = true;
    /**
     * Allowed Sources to Produce Media Stream to the Room
     */
    __canProduceSources = {
      cam: true,
      mic: true,
      screen: true
    };
    /**
     * Can Send Data to the Room, e.g. Chat Messages, update of avatar, name etc. to the room
     */
    __canSendData = false;
    /**
     * Can Receive Data from the Room, e.g. Chat Messages, update of avatar, name etc. from other Remote Peers.
     */
    __canRecvData = false;
    /**
     * Can Update Metadata of the Room, e.g. DisplayName, Avatar, etc.
     */
    __canUpdateMetadata = false;
    /**
     * Custom Role of the Peer in the Room.
     */
    __role = null;
    /**
     * Getter for the role of the peer.
     */
    get role() {
      return this.__role;
    }
    set role(role) {
      this.__role = role;
    }
    /**
     * Get the Access Control List ( acl ) of the Local Peer in the Room.
     */
    get acl() {
      return {
        admin: this.__admin,
        canConsume: this.__canConsume,
        canProduce: this.__canProduce,
        canProduceSources: this.__canProduceSources,
        canSendData: this.__canSendData,
        canRecvData: this.__canRecvData,
        canUpdateMetadata: this.__canUpdateMetadata
      };
    }
    /**
     * Update the Permissions of the Local Peer in the Room. This will emit an event `updated` with the updated permissions.
     *
     * `NOTE: If the Peer is not an admin, then the permissions will not be updated on the server`
     */
    updatePermissions(permissions) {
      logger3.info("\u{1F514} Updating Permissions", permissions);
      this.__admin = permissions.admin ?? this.__admin;
      this.__canConsume = permissions.canConsume ?? this.__canConsume;
      this.__canProduce = permissions.canProduce ?? this.__canProduce;
      this.__canProduceSources = permissions.canProduceSources ?? this.__canProduceSources;
      this.__canSendData = permissions.canSendData ?? this.__canSendData;
      this.__canRecvData = permissions.canRecvData ?? this.__canRecvData;
      this.__canUpdateMetadata = permissions.canUpdateMetadata ?? this.__canUpdateMetadata;
    }
    static createInstance() {
      if (_Permissions.__instance)
        return _Permissions.__instance;
      _Permissions.__instance = new _Permissions();
      return _Permissions.__instance;
    }
    static getInstance() {
      if (!_Permissions.__instance) {
        throw new Error("Permissions Instance not created yet.");
      }
      return _Permissions.__instance;
    }
    constructor() {
      super();
    }
    reset() {
      this.__admin = false;
      this.__canConsume = false;
      this.__canProduce = true;
      this.__canProduceSources = {
        cam: true,
        mic: true,
        screen: true
      };
      this.__canSendData = false;
      this.__canRecvData = false;
      this.__canUpdateMetadata = false;
      this.__role = null;
    }
  };
  var checkPermissions = (permission) => {
    return {
      validate: (fn) => {
        return (...args) => {
          const peerPermission = Permissions.getInstance().acl;
          if (permission.admin && !peerPermission.admin) {
            throw new Error("Admin Access Required.");
          }
          if (permission.canConsume && !peerPermission.canConsume) {
            throw new Error("Can Consume Access Required.");
          }
          if (permission.canProduce && !peerPermission.canProduce) {
            throw new Error("Can Produce Access Required.");
          }
          if (permission.canProduceSources?.cam && !peerPermission.canProduceSources.cam) {
            throw new Error("Produce Sources Access Required. for 'cam'");
          }
          if (permission.canProduceSources?.mic && !peerPermission.canProduceSources.mic) {
            throw new Error("Produce Sources Access Required. for 'mic'");
          }
          if (permission.canProduceSources?.screen && !peerPermission.canProduceSources.screen) {
            throw new Error("Produce Sources Access Required. for 'screen'");
          }
          if (permission.canSendData && !peerPermission.canSendData) {
            throw new Error("Can Send Data Access Required.");
          }
          if (permission.canRecvData && !peerPermission.canRecvData) {
            throw new Error("Can Recv Data Access Required.");
          }
          return fn(...args);
        };
      }
    };
  };
  checkPermissions({
    canProduceSources: {
      cam: true,
      mic: true,
      screen: true
    }
  });
  var Permissions_default = Permissions;

  // src/Room.ts
  var logger4 = mainLogger.createSubLogger("Room.ts");
  var Room = class _Room extends EnhancedEventEmitter {
    /**
     * Room Instance, Singleton class
     */
    static __instance = null;
    /**
     * Socket Instance, Singleton class
     */
    __socket = Socket_default.getInstance();
    /**
     * Returns the instance of the socket connection
     */
    get socket() {
      return this.__socket;
    }
    /**
     * Room Id of the current room
     */
    __roomId = null;
    /**
     * session id
     */
    __sessionId = null;
    /**
     * Lobby PeerIds
     */
    __lobbyPeers = /* @__PURE__ */ new Map();
    /**
     * Removed Lobby PeerId from the lobby
     * @param peerId - PeerId of the peer who joined the room
     */
    removeLobbyPeer = (peerId) => {
      this.__lobbyPeers.delete(peerId);
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    };
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    __config = {
      roomLocked: false,
      allowProduce: true,
      allowProduceSources: {
        cam: true,
        mic: true,
        screen: true
      },
      allowConsume: true,
      allowSendData: true
    };
    /**
     * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
     *
     * @default true
     *
     * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
     * - if set to false, the user will have to manually consume the media streams of the remote peers
     * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    autoConsume = true;
    /**
     * Handler for the ActiveSpeaker
     */
    __activeSpeakers = null;
    /**
     * Get the active speakers instance
     */
    get activeSpeakers() {
      return this.__activeSpeakers;
    }
    set activeSpeakers(activeSpeakers) {
      if (this.__activeSpeakers) {
        logger4.warn(
          "Active Speakers is already set, Ignoring the new active speakers, end this room and create a new room"
        );
      }
      this.__activeSpeakers = activeSpeakers;
    }
    /**
     * State of the Room
     */
    __state = "idle";
    /**
     * Room Stats
     */
    __stats = {
      startTime: 0
    };
    /**
     * Set the state of the room
     */
    set state(newState) {
      if (this.state !== newState) {
        this.__state = newState;
      }
    }
    /**
     * State of the room
     */
    get state() {
      return this.__state;
    }
    /**
     * Get the lobby peers in the form of map
     * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
     * @example
     * ```ts
     * const lobbyPeers = room.lobbyPeersMap;
     *
     * for (const [peerId, metadata] of lobbyPeers) {}
     *
     * ```
     */
    get lobbyPeersMap() {
      return this.__lobbyPeers;
    }
    /**
     * Get lobby peers in the form of array
     */
    get lobbyPeerIds() {
      return Array.from(this.__lobbyPeers.keys());
    }
    /**
     * Get lobby peers in the form of array
     * @returns - Array of Lobby PeerIds
     */
    get lobbyPeers() {
      return this.__lobbyPeers;
    }
    /**
     * Set lobby peers in the form of map
     * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
     */
    set lobbyPeersMap(peers) {
      this.__lobbyPeers = peers;
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Get Room Stats
     */
    get stats() {
      return this.__stats;
    }
    /**
     * Set Room Stats
     */
    set stats(stats) {
      this.__stats = stats;
    }
    /**
     * Get
     * @returns
     */
    getLobbyPeerMetadata = (peerId) => {
      const lobbyPeer = this.lobbyPeers.get(peerId);
      let metadata = {};
      if (lobbyPeer?.metadata) {
        metadata = JSON.parse(lobbyPeer.metadata);
      }
      return {
        peerId,
        metadata
      };
    };
    /**
     * Set lobby peers in the form of array
     */
    set newlobbyPeers(peers) {
      for (const peer of peers) {
        this.__lobbyPeers.set(peer.peerId, peer);
      }
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    get config() {
      return this.__config;
    }
    set config(config) {
      this.__config = config;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    remotePeers = /* @__PURE__ */ new Map();
    /**
     * Metadata of the room.
     */
    __metadata = "{}";
    /**
     * Setter function for the metadata of the room
     * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
     * `To notify everyone in the room about the metadata change, use the updateMetadata function`
     */
    set metadata(metadata) {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", parse);
    }
    /**
     * Get the metadata of the room
     */
    getMetadata = () => {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    };
    /**
     * Update Metadata of the room
     */
    updateMetadata = checkPermissions({}).validate(
      (data) => {
        try {
          if (this.state === "closed" || this.state === "failed" || this.state === "left") {
            logger4.error(
              "\u274C Cannot Update Metadata, You have not joined the room yet"
            );
            return;
          }
          const metadata = JSON.stringify(data);
          this.metadata = metadata;
          this.socket.publish("updateRoomMetadata", {
            metadata
          });
        } catch (error) {
          logger4.error("\u274C Error Updating Metadata");
          logger4.error(error);
        }
      }
    );
    /**
     * Create a new Room Instance if not created, else return the existing Room Instance
     *
     * @returns - Room Instance
     */
    static create(data) {
      if (_Room.__instance) {
        return _Room.__instance;
      }
      logger4.debug({ data });
      _Room.__instance = new _Room(data);
      return _Room.__instance;
    }
    /**
     * Get the Room Instance if its not initialized it will throw an error
     * @returns - Room Instance
     * @throws { Error } If the Room Instance is not initialized
     */
    static getInstance = () => {
      if (!_Room.__instance) {
        throw new Error("\u274C Room Instance Not Initialized");
      }
      return _Room.__instance;
    };
    /**
     * RoomId of the currently joined room.
     */
    get roomId() {
      return this.__roomId;
    }
    /**
     *
     */
    get sessionId() {
      return this.__sessionId;
    }
    set roomId(roomId) {
      if (this.__roomId) {
        logger4.warn(
          "RoomId is already set, Ignoring the new roomId, end this room and create a new room"
        );
        return;
      }
      this.__roomId = roomId;
    }
    set sessionId(sessionId) {
      if (this.__sessionId) {
        logger4.warn(
          "sessionId is already set, Ignoring the new sessionId, end this room and create a new room"
        );
        return;
      }
      this.__sessionId = sessionId;
    }
    /**
     * Returns the PeerIds of the remote peers
     */
    get peerIds() {
      return Array.from(this.remotePeers.keys());
    }
    /**
     * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
     * @param data: TNewRoomControls
     */
    updateRoomControls = checkPermissions({
      admin: true
    }).validate((data) => {
      logger4.info("\u{1F514} Updating Room Controls", data);
      this.config[data.type] = data.value;
      this.emit("room-controls-updated");
      if (data.type === "allowProduceSources") {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "produceSourcesControl",
            value: data
          }
        });
      } else {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "roomControl",
            value: data
          }
        });
      }
    });
    /**
     * Close a particular stream of remote peers
     *  @param data: { label: string; peerIds?: string[] }
     *  @param label: Label of the stream
     *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
     */
    closeStreamOfLabel = checkPermissions({}).validate(
      (data) => {
        logger4.info("\u{1F514} Closing Stream of Label", data);
        this.socket.publish("closeStreamOfLabel", data);
      }
    );
    /**
     * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
     *
     * `NOTE: This will target all the audio stream in the room with the label "audio"`
     */
    muteEveryone = checkPermissions({ admin: true }).validate(() => {
      logger4.info("\u{1F514} Muting Everyone");
      this.socket.publish("closeStreamOfLabel", {
        label: "audio"
      });
    });
    /**
     * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
     *
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @return - null if the peer is not present in the room
     */
    remotePeerExists = (peerId) => {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        return null;
      }
      return peer;
    };
    /**
     * Returns the Remote Peer if present in room.
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @throws { Error } If the Remote Peer is not found
     */
    getRemotePeerById(peerId) {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);
      }
      return peer;
    }
    constructor(data) {
      super();
      if (data?.autoConsume !== void 0) {
        this.autoConsume = data.autoConsume;
      }
    }
    /**
     * Connects to the room and returns the instance of the room
     * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
     */
    connect = () => {
      if (_Room.__instance === null) {
        throw new Error("Room Instance Not Initialized");
      }
      if (!this.socket.connected) {
        throw new Error("Socket is Not Connected");
      }
      if (this.socket.connecting) {
        throw new Error("Socket is Connecting, Wait for it to be connected");
      }
      if (!this.roomId) {
        throw new Error("Room Id is required to connect to the room");
      }
      logger4.info("\u{1F514} Connecting to the room");
      this.socket.publish("connectRoom", { roomId: this.roomId });
      this.__state = "connecting";
      this.emit("room-connecting");
      return _Room.__instance;
    };
    /**
     * Admit a Peer to the room who is in the lobby
     */
    admitPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("acceptLobbyPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error admitting peer", error);
        }
      }
    );
    /**
     * Denies the peer from joining the room, who is in the lobby
     */
    denyPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("denyLobbyPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * kick peer from room with respective peerId
     */
    kickPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.socket.publish("kickPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * @deprecated Use `leaveRoom` from `huddleClient` instead
     * closing the room for the current user, room will keep on running for the remote users
     */
    close = (reason) => {
      try {
        logger4.info("\u{1F534} Leaving the room");
        this.__roomId = null;
        this.remotePeers.clear();
        this.lobbyPeers.clear();
        this.metadata = "{}";
        this.state = "left";
        this.emit("room-closed", { reason: reason || "LEFT" });
      } catch (error) {
        logger4.error("Error: Leaving the Room");
      }
    };
  };
  var Room_default = Room;

  // src/RemotePeer.ts
  var logger5 = mainLogger.createSubLogger("RemotePeer");
  var RemotePeer = class extends EnhancedEventEmitter {
    /**
     * peerId of the remote peer, this is unique for each peer
     */
    peerId;
    /**
     * Stores the Metadata for the Remote Peer.
     */
    __metadata = "{}";
    /**
     * Stores the Role of the Remote Peer.
     */
    __role = null;
    /**
     * Labels are the unique identifier for the media stream that the remote peer is producing
     */
    __labelsToProducerId = /* @__PURE__ */ new Map();
    /**
     * Returns the list of labels that the remote peer is producing
     */
    get labels() {
      return Array.from(this.__labelsToProducerId.keys());
    }
    get producerIds() {
      return Array.from(this.__labelsToProducerId.values()).map(
        (labelData) => labelData.producerId
      );
    }
    /**
     * Role of the Peer.
     * @returns The Role of the Peer which if passed in the options when creating the token
     */
    get role() {
      if (!this.__role)
        return null;
      return this.__role;
    }
    set role(role) {
      this.__role = role;
      this.emit("role-updated", {
        role
      });
    }
    /**
     * Checks if the remote peer is producing the label
     * @param label - Label to check if the remote peer is producing
     * @returns - Returns true if the remote peer is producing the label
     */
    hasLabel(label) {
      return this.__labelsToProducerId.has(label);
    }
    /**
     * Returns the data associated to the label, this is the producerId
     *
     * @returns
     * producerId - Unique identifier for the producer
     */
    getLabelData(label) {
      return this.__labelsToProducerId.get(label);
    }
    /**
     * Get the associated consumer for the label
     * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string
     * @returns Consumer | null
     */
    getConsumer(label) {
      try {
        const localPeer = LocalPeer_default.getInstance();
        const consumer = localPeer.recvTransport.getConsumer({
          label,
          peerId: this.peerId
        });
        return consumer;
      } catch (error) {
        return null;
      }
    }
    /**
     * Returns the metadata associated to the RemotePeer
     */
    getMetadata() {
      return this.__metadata;
    }
    /**
     * Setter function to update the Remote Peer Metadata
     *
     * `NOTE: This will NOT notify other Remote Peers of the update`
     */
    set metadata(data) {
      this.__metadata = data;
      this.emit("metadata-updated", {
        metadata: data
      });
    }
    /**
     * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.
     */
    updatePermissions = checkPermissions({
      admin: true
    }).validate(async (data) => {
      try {
        logger5.info("\u{1F514} Updating Permissions", data);
        const localPeer = LocalPeer_default.getInstance();
        const socket = localPeer.socket;
        socket.publish("updatePeerPermission", {
          peerId: this.peerId,
          permissions: data
        });
      } catch (error) {
        logger5.error("\u{1F514} Error Updating Permissions");
        logger5.error(error);
      }
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     */
    updateRole = checkPermissions({
      admin: true
    }).validate((data) => {
      try {
        logger5.info("\u{1F514} Updating Peer Role", data);
        if (data.role === this.__role) {
          logger5.warn("\u{1F514} Role is already set to", data.role);
          return;
        }
        const localPeer = LocalPeer_default.getInstance();
        const socket = localPeer.socket;
        socket.publish("updatePeerRole", {
          peerId: this.peerId,
          role: data.role
        });
      } catch (error) {
        logger5.error("\u{1F514} Error Updating Role", data);
        logger5.error(error);
      }
    });
    /**
     * Removes all the states of the remote peer and clears memory;
     *
     * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer
     */
    close = () => {
      logger5.info("Closing Remote Peer");
      this.removeAllListeners();
    };
    constructor(data) {
      super();
      this.peerId = data.peerId;
      if (data.metadata) {
        this.metadata = JSON.parse(data.metadata);
      }
      if (data.role) {
        this.__role = data.role;
      }
    }
    /**
     * @protected
     * Add a New Label to the Remote Peer and associate it with the ProducerId
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to add the new label `label` and the `producerId` to associate it with
     */
    _addLabelData = async (data) => {
      const { label, producerId } = data;
      this.__labelsToProducerId.set(label, { producerId });
      try {
        const autoConsume = Room_default.getInstance().autoConsume;
        const localPeer = LocalPeer_default.getInstance();
        if (autoConsume) {
          logger5.debug(
            "AUTO CONSUME IS ENABLED, CONSUMING THE PRODUCER'S STREAM"
          );
          localPeer.consume({
            appData: {},
            label,
            peerId: this.peerId
          });
        } else {
          this.emit("stream-available", {
            label,
            labelData: {
              producerId
            }
          });
        }
      } catch (error) {
        logger5.error("\u274C Error While Consuming", {
          label,
          peerId: this.peerId
        });
        logger5.error(error);
        this.emit("stream-available", {
          label,
          labelData: {
            producerId
          }
        });
      }
    };
    /**
     * @protected
     * Remove a Label from the Remote Peer and emit a `stream-closed` event
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to remove the label from the Remote Peer
     */
    _removeLabelData = (label, reason) => {
      this.__labelsToProducerId.delete(label);
      this.emit("stream-closed", {
        label,
        reason
      });
    };
  };
  var RemotePeer_default = RemotePeer;

  // src/Consumer.ts
  var logger6 = mainLogger.createSubLogger("Consumer");
  var Consumer = class _Consumer extends EnhancedEventEmitter {
    /**
     * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
     */
    producerId;
    /**
     * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
     */
    producerPeerId;
    /**
     * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
     */
    label;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     */
    __consuming = false;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consuming() {
      return this.__consuming;
    }
    /**
     * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.
     * @remarks This is a private property and should not be accessed directly.
     *
     * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.
     */
    #mediasoupConsumer = null;
    /**
     * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
     */
    get id() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     *
     * @param consumer Sets the mediasoupConsumer for the Consumer
     */
    setMediaSoupConsumer(consumer) {
      if (this.consuming) {
        throw new Error("Consumer is already consuming");
      }
      if (this.#mediasoupConsumer) {
        throw new Error("Consumer already has a mediasoupConsumer");
      }
      this.#mediasoupConsumer = consumer;
      this.__consuming = true;
    }
    /**
     * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consumerId() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get track() {
      return this.#mediasoupConsumer?.track;
    }
    /**
     * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get kind() {
      return this.#mediasoupConsumer?.kind;
    }
    /**
     * If the Consumer is paused, it is only available when the Consumer is consuming a media.
     *
     * if paused the user is not consuming any media for the given producerId.
     */
    get paused() {
      return this.#mediasoupConsumer?.paused;
    }
    /**
     * AppData of the Consumer, it is only available when the Consumer is consuming a media.
     */
    get appData() {
      return this.#mediasoupConsumer?.appData;
    }
    /**
     * State of a Consumer is defined by the following:
     * - `playable` - The Consumer is ready to play the media.
     * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
     * - `paused` - The Consumer is paused and is not playing the media.
     * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
     */
    get state() {
      if (this?.consuming)
        return "playable";
      if (this?.paused)
        return "paused";
      return "available";
    }
    /**
     * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
     * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
     * @returns - RTCStatsReport | null
     */
    getStats = async () => {
      const stats = await this.#mediasoupConsumer?.getStats();
      return stats;
    };
    /**
     * Resume the consumer, if the state of the consumer is `paused`.
     */
    resume = () => {
      this.#mediasoupConsumer?.resume();
    };
    /**
     * Removes all the eventListeners attached to the Consumer.
     */
    removeListeners = () => {
      this.removeAllListeners();
    };
    /**
     * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
     */
    static create = (data) => {
      try {
        const consumer = new _Consumer(data);
        return consumer;
      } catch (error) {
        logger6.error(error);
        throw new Error("\u274C Error creating Consumer");
      }
    };
    close = () => {
      try {
        this.#mediasoupConsumer?.close();
        this.__consuming = false;
        this.emit("closed");
        this.removeAllListeners();
      } catch (error) {
        logger6.error("\u274C Error Closing Consumer");
        logger6.error({
          consumerId: this.consumerId,
          producerId: this.producerId
        });
      }
    };
    constructor(data) {
      super();
      this.producerPeerId = data.producerPeerId;
      this.producerId = data.producerId;
      this.label = data.label;
    }
  };
  var Consumer_default = Consumer;

  // src/helpers/index.ts
  var getMediaStreamKind = (stream) => {
    let kind = null;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === "audio") {
        kind = "audio";
        break;
      } else if (track.kind === "video") {
        kind = "video";
        break;
      }
    }
    if (!kind) {
      throw new Error("Stream Kind Not Found");
    }
    return kind;
  };
  var getMediaDeviceKind = (track) => {
    if (track.kind === "audio") {
      return "mic";
    } else if (track.kind === "video") {
      const settings = track.getSettings();
      if (settings.displaySurface) {
        return "screen";
      } else {
        return "cam";
      }
    }
    return "cam";
  };
  var getMediaTrack = (data) => {
    const { stream, kind } = data;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === kind) {
        return track;
      }
    }
    throw new Error("Track Not Found");
  };
  var estimateSize = (obj) => {
    const str = JSON.stringify(obj);
    return new TextEncoder().encode(str).length;
  };

  // src/common-js/EnhancedMap.ts
  var defaultCompareFn = (a, b) => {
    if (a < b) {
      return false;
    }
    if (a > b) {
      return true;
    }
    return false;
  };
  var EnhancedMap = class {
    map;
    compareFn;
    getKey = (a, b) => {
      const key = this.compareFn(a, b) ? `${a}_${b}` : `${b}_${a}`;
      return key;
    };
    get size() {
      return this.map.size;
    }
    get data() {
      return this.map;
    }
    get = (a, b) => {
      const key = this.getKey(a, b);
      const value = this.map.get(key);
      return value;
    };
    set = (a, b, value) => {
      const key = this.getKey(a, b);
      this.map.set(key, value);
      return value;
    };
    delete = (a, b) => {
      const key = this.getKey(a, b);
      return this.map.delete(key);
    };
    clear = () => {
      this.map.clear();
    };
    constructor(data) {
      this.map = /* @__PURE__ */ new Map();
      if (data.compareFn)
        this.compareFn = data.compareFn;
      else
        this.compareFn = defaultCompareFn;
    }
  };

  // src/helpers/ProtooParsing.ts
  var import_rtp_parameters_pb = __toESM(require_rtp_parameters_pb(), 1);
  var parseRouterRtpCapabilities = (rtpCapabilities) => {
    const parsedRouterRtpCapabilites = rtpCapabilities;
    if (parsedRouterRtpCapabilites.codecs)
      for (const codec of parsedRouterRtpCapabilites.codecs) {
        if (codec.parameters) {
          const keys = Object.keys(codec.parameters);
          for (const key of keys) {
            if (key === "apt") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "level-asymmetry-allowed") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "packetization-mode") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "x-google-start-bitrate") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "profile-id") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
          }
        }
      }
    return parsedRouterRtpCapabilites;
  };
  var parseRtpParameters = (rtpParameters) => {
    const parsedRtpParameters = rtpParameters;
    for (const codec of parsedRtpParameters.codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
        }
      }
    }
    if (parsedRtpParameters.encodings) {
      for (const encoding of parsedRtpParameters.encodings) {
        encoding.dtx = false;
        encoding.ssrc = Number(encoding.ssrc);
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        if (encoding.rtx?.ssrc !== void 0) {
          if (Number(encoding.rtx.ssrc) === 0) {
            encoding.rtx = void 0;
          } else {
            encoding.rtx.ssrc = Number(encoding.rtx.ssrc);
          }
        } else {
          encoding.rtx = void 0;
        }
      }
    }
    const headerExtensions = parsedRtpParameters.headerExtensions;
    if (headerExtensions) {
      headerExtensions.map((headerExtension) => {
        headerExtension.encrypt = false;
        headerExtension.parameters = {};
      });
    }
    return parsedRtpParameters;
  };
  var parseToProtoRtpParameters = (rtpParameters) => {
    const protoEncodings = [];
    const codecs = rtpParameters.codecs;
    for (const codec of codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
        }
      }
    }
    const encodings = rtpParameters.encodings;
    if (encodings) {
      for (const encoding of encodings) {
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        const protoEncoding = new import_rtp_parameters_pb.ProtoEncodings({
          ssrc: encoding.ssrc ? BigInt(encoding.ssrc) : void 0,
          rid: encoding.rid,
          codecPayloadType: encoding.codecPayloadType,
          rtx: {
            ssrc: encoding.rtx?.ssrc ? BigInt(encoding.rtx.ssrc) : void 0
          },
          dtx: encoding.dtx,
          scalabilityMode: encoding.scalabilityMode,
          scaleResolutionDownBy: encoding.scaleResolutionDownBy,
          maxBitrate: encoding.maxBitrate
        });
        protoEncodings.push(protoEncoding);
      }
    }
    return rtpParameters;
  };

  // src/Transport.ts
  var logger7 = mainLogger.createSubLogger("Transport");
  var Transport = class _Transport extends EnhancedEventEmitter {
    /**
     * Peer Id, which handles the peer id.
     */
    peerId;
    /**
     *  MediaSoup Device Instance, which handles the browsers or mobile device init.
     */
    __device;
    /**
     * MediaSoup Transport Instance, which handles the media transport.
     */
    __mediasoupTransport;
    /**
     * Socket Instance, which handles the socket connection.
     */
    __socket;
    /**
     * Map of Producers, which handles the producers. ( Sending out Media Streams )
     *
     * `Mapped with {producerId => Producer}`
     */
    __producers = /* @__PURE__ */ new Map();
    /**
     * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
     *
     * `Mapped with {label => DataProducer}`
     */
    __dataProducers = /* @__PURE__ */ new Map();
    /**
     * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:label => DataConsumer}`
     */
    __dataConsumers = /* @__PURE__ */ new Map();
    /**
     * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:RemotePeerId => Consumer}`
     */
    __consumers = new EnhancedMap({});
    /**
     * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
     *
     * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
     */
    labelToProducerId = /* @__PURE__ */ new Map();
    /**
     * Transport Type, which handles the transport type. ( `send | recv` )
     */
    transportType;
    /**
     * Pending Producer Tasks, which handles the pending producer tasks.
     * callback function is necessary to be called when the producer is created
     * on the server as well as on the client side.
     */
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    /**
     * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
     * more requests to restart ice.
     */
    __iceRestartDebounce = false;
    get device() {
      return this.__device;
    }
    get mediasoupTransport() {
      return this.__mediasoupTransport;
    }
    get connectionState() {
      return this.__mediasoupTransport.connectionState;
    }
    get producers() {
      return this.__producers;
    }
    get dataProducers() {
      return this.__dataProducers;
    }
    get dataConsumers() {
      return this.__dataConsumers;
    }
    get consumers() {
      return this.__consumers;
    }
    getProducerById(producerId) {
      const producer = this.__producers.get(producerId);
      if (!producer)
        throw new Error("Producer not found");
      return producer;
    }
    removeProducerById(producerId) {
      logger7.info(`\u{1F514} Removing Producer, id: ${producerId}`);
      return this.__producers.delete(producerId);
    }
    /**
     * Get the consumer by label and peerId
     * @param data
     * @returns Consumer | null; Returns null if consumer is not found
     */
    getConsumer = (data) => {
      const consumer = this.__consumers.get(data.label, data.peerId);
      if (!consumer)
        return null;
      return consumer;
    };
    get transport() {
      const transport = this.__mediasoupTransport;
      if (!transport)
        throw new Error("Transport Not Initialized");
      return transport;
    }
    addPendingProducerTask = (data) => {
      const key = `${data.peerId}-${data?.label}`;
      logger7.info("\u{1F514} Adding Pending Producer Task, key", key);
      if (this.__pendingProducerTasks.has(key)) {
        logger7.debug("\u{1F534} Producer Creation is Pending for key: ", key);
        return;
      }
      this.__pendingProducerTasks.set(key, data.callback);
    };
    resolvePendingProducerTask = (data) => {
      const key = `${data.peerId}-${data.label}`;
      logger7.info("\u{1F514} Resolving Pending Producer Task, key", key);
      const callback = this.__pendingProducerTasks.get(key);
      if (!callback) {
        logger7.error("\u{1F534} Producer Creation is not Pending for key: ", key);
        return;
      }
      callback({ id: data.id });
      this.__pendingProducerTasks.delete(key);
    };
    static create = (data) => {
      try {
        logger7.info(
          `\u{1F514} Creating Client Side Transport, type: ${data.transportType}`
        );
        const { transportType, device } = data;
        const payload = {
          id: data.sdpInfo.id,
          iceParameters: data.sdpInfo.iceParameters,
          iceCandidates: data.sdpInfo.iceCandidates,
          iceServers: data.iceServers,
          dtlsParameters: data.sdpInfo.dtlsParameters,
          sctpParameters: data.sdpInfo.sctpParameters,
          proprietaryConstraints: {},
          appData: {}
        };
        const mediasoupTransport = transportType === "send" ? device.createSendTransport(payload) : device.createRecvTransport(payload);
        const transport = new _Transport({
          peerId: data.peerId,
          device: data.device,
          transportType: data.transportType,
          mediasoupTransport
        });
        return transport;
      } catch (error) {
        logger7.error(`\u274C Transport.create(), type: ${data.transportType}`);
        logger7.error(error);
        throw error;
      }
    };
    constructor(data) {
      super();
      this.__socket = Socket_default.getInstance();
      this.__device = data.device;
      this.transportType = data.transportType;
      this.__mediasoupTransport = data.mediasoupTransport;
      this.__mediasoupTransport.on("connectionstatechange", (state) => {
        this.__connectionStateChangeHandler(state);
      });
      this.peerId = data.peerId;
      this.__listenTransportConnect();
      this.__listenTransportProduce();
      if (this.transportType === "send")
        this.__listenTransportDataProduce();
      logger7.info(`\u2705 ${data.transportType} Transport Initialized`);
    }
    __listenTransportConnect = () => {
      this.__mediasoupTransport.on(
        "connect",
        ({ dtlsParameters }, callback, errback) => {
          logger7.info("\u{1F514} Transport Connect Event Called");
          try {
            this.once("connectTransportResponse", () => {
              callback();
            });
            this.__socket.publish("connectTransport", {
              dtlsParameters,
              transportType: this.transportType
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Connect Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    __listenTransportProduce = () => {
      this.__mediasoupTransport.on(
        "produce",
        async ({ kind, rtpParameters, appData }, callback, errback) => {
          logger7.info(`\u{1F514} ${this.transportType} Produce Event Called`);
          try {
            const label = appData?.label;
            if (!label)
              throw new Error("\u{1F534} Stream Identifier Not Found");
            const parsedProtoRtpParameters = parseToProtoRtpParameters(rtpParameters);
            this.__socket.publish("produce", {
              rtpParameters: parsedProtoRtpParameters,
              kind,
              label,
              appData,
              paused: false
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Produce Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    __listenTransportDataProduce = () => {
      logger7.info(`\u{1F514} producedata: ${this.transportType} `);
      this.__mediasoupTransport.on(
        "producedata",
        async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {
          logger7.info(`\u{1F514} ${this.transportType} Produce Data Event Called`);
          try {
            this.__socket.publish("produceData", {
              transportId: this.__mediasoupTransport.id,
              sctpStreamParameters,
              label,
              protocol,
              appData
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Produce Data Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    produce = async (data) => {
      const kind = getMediaStreamKind(data.stream);
      const track = getMediaTrack({ stream: data.stream, kind });
      logger7.info(`\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);
      try {
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        if (!this.__device.canProduce(kind)) {
          throw new Error(`Device Cannot produce ${kind}`);
        }
        if (this.transportType !== "send") {
          throw new Error(`Cannot produce on ${this.transportType} transport`);
        }
        const codecs = this.__device.rtpCapabilities?.codecs;
        if (!codecs) {
          throw new Error("\u274C Device RTP Capabilities not found");
        }
        const codecViaMediaType = {
          video: codecs.find(
            (codec) => codec.mimeType.toLowerCase() === "video/h264"
          ),
          "screen-share-video": codecs.find(
            (codec) => codec.mimeType.toLowerCase() === "video/h264"
          ),
          audio: void 0
        };
        const mediaType = data.label === "screen-share-video" ? "screen-share-video" : kind;
        const mediasoupProducer = await this.__mediasoupTransport.produce({
          track,
          encodings: encodingViaMediaType[mediaType],
          codecOptions: codecOptionsViaKind[kind],
          codec: codecViaMediaType[mediaType],
          stopTracks: data.stopTrackOnClose,
          zeroRtpOnPause: true,
          disableTrackOnPause: true,
          appData: {
            ...data.appData,
            producerPeerId: this.peerId
          }
        });
        this.__producers.set(mediasoupProducer.id, mediasoupProducer);
        this.labelToProducerId.set(data.label, mediasoupProducer.id);
        logger7.info(`\u{1F514} Producer Created sucessfully with label : ${data.label}`);
        return mediasoupProducer;
      } catch (error) {
        logger7.error("\u274C Error Transport Produce Event");
        logger7.error(error);
        throw error;
      }
    };
    produceData = async (data) => {
      logger7.info(`\u{1F514} Produce Data Called for label: ${data.label}`);
      try {
        if (this.transportType !== "send") {
          throw new Error(`Cannot produce on ${this.transportType} transport`);
        }
        const dataProducer = await this.__mediasoupTransport.produceData({
          label: data.label,
          appData: {
            ordered: true,
            ...data.appData,
            producerPeerId: this.peerId,
            label: data.label
          }
        });
        this.__dataProducers.set(dataProducer.label, dataProducer);
        return dataProducer;
      } catch (error) {
        logger7.error("\u274C Error Transport Produce Data Event");
        logger7.error(error);
        throw error;
      }
    };
    consume = async (data) => {
      const { label, producerPeerId, kind } = data;
      logger7.info(
        `\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        const consumer = Consumer_default.create({
          producerId: data.producerId,
          producerPeerId,
          label
        });
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const parsedRtpParameters = parseRtpParameters(data.rtpParameters);
        const mediaSoupConsumer = await this.__mediasoupTransport.consume({
          id: data.consumerId,
          rtpParameters: parsedRtpParameters,
          kind: data.kind,
          producerId: data.producerId,
          appData: data.appData
        });
        mediaSoupConsumer.on("transportclose", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        mediaSoupConsumer.on("trackended", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);
        consumer.setMediaSoupConsumer(mediaSoupConsumer);
        return { consumer, mediaSoupConsumer };
      } catch (error) {
        logger7.error(error);
        throw new Error("\u274C Error calling consume()");
      }
    };
    consumeData = async (data) => {
      const {
        label,
        appData,
        dataProducerId,
        protocol,
        id,
        peerId,
        sctpStreamParameters
      } = data;
      logger7.info(
        `\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const dataConsumer = await this.transport.consumeData({
          id,
          dataProducerId,
          sctpStreamParameters: {
            ...sctpStreamParameters,
            maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime === 0 ? void 0 : sctpStreamParameters.maxPacketLifeTime,
            maxRetransmits: sctpStreamParameters.maxRetransmits === 0 ? void 0 : sctpStreamParameters.maxRetransmits
          },
          label,
          protocol,
          appData
        });
        dataConsumer.on("open", () => {
          logger7.info(`\u2705 DataConsumer with ${label} opened`);
        });
        dataConsumer.on("close", () => {
          logger7.warn(`\u2705 DataConsumer with ${label} closed`);
          this.__dataConsumers.delete(label);
        });
        dataConsumer.on("error", (error) => {
          logger7.error(`\u2705 DataConsumer "error": ${error} closed`);
        });
        this.__dataConsumers.set(label, dataConsumer);
        return dataConsumer;
      } catch (error) {
        logger7.error(error);
        throw new Error("\u274C Error calling consumeData()");
      }
    };
    closeConsumer = (data) => {
      try {
        const consumer = this.getConsumer(data);
        if (!consumer) {
          throw new Error(
            `\u274C Consumer not found label: ${data.label}, peerId: ${data.peerId}`
          );
        }
        consumer.close();
        this.__consumers.delete(data.label, data.peerId);
      } catch (error) {
        logger7.error("\u274C Error closing consumer");
        logger7.error(error);
      }
    };
    close = async (data) => {
      try {
        if (data.retries <= 0) {
          logger7.error("\u274C Error closing transport, max retries exceeded");
          return;
        }
        logger7.info(`\u{1F514} Closing ${this.transportType} transport`);
        this.__mediasoupTransport.close();
        logger7.info(`\u2705 ${this.transportType} transport closed`);
      } catch (error) {
        logger7.error("\u274C Error closing transport");
        logger7.error(error);
        logger7.error("Retrying...");
        this.close({ retries: data.retries - 1 });
      }
    };
    __connectionStateChangeHandler = (state) => {
      try {
        logger7.debug(
          `\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`
        );
        const transportType = this.transportType;
        const handler = {
          connected: () => {
            logger7.debug(`\u{1F514} ${this.transportType} Transport Connected`);
          },
          disconnected: () => {
            if (this.__iceRestartDebounce)
              return;
            this.__iceRestartDebounce = true;
            this.__socket.publish("restartTransportIce", {
              transportId: this.__mediasoupTransport.id,
              transportType
            });
            setTimeout(() => {
              this.__iceRestartDebounce = false;
            }, 3e3);
            logger7.debug(`\u{1F514} ${transportType} Transport Disconnected`);
          },
          failed: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport Failed`);
          },
          connecting: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport Connecting`);
          },
          closed: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport closed`);
          },
          new: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport new`);
          }
        };
        handler[state]();
      } catch (err) {
        logger7.error("\u274C Error in connectionStateChangeHandler");
        logger7.error(err);
      }
    };
  };
  var Transport_default = Transport;

  // src/ActiveSpeakers.ts
  var logger8 = mainLogger.createSubLogger("ActiveSpeakers");
  var ActiveSpeakers = class _ActiveSpeakers extends EnhancedEventEmitter {
    /**
     * Instance of the ActiveSpeakers Class; used for singleton pattern.
     */
    static __instance;
    /**
     * Get the instance of the ActiveSpeakers Class.
     * @returns ActiveSpeakers instance.
     */
    static getInstance() {
      if (!_ActiveSpeakers.__instance) {
        throw new Error("ActiveSpeakers not initialized");
      }
      return _ActiveSpeakers.__instance;
    }
    /**
     * Create the instance of the ActiveSpeakers Class.
     * @returns ActiveSpeakers instance.
     */
    static createInstance(data) {
      if (_ActiveSpeakers.__instance) {
        return _ActiveSpeakers.__instance;
      }
      _ActiveSpeakers.__instance = new _ActiveSpeakers(data);
      return _ActiveSpeakers.__instance;
    }
    /**
     * Room instance.
     */
    __room = Room_default.getInstance();
    /**
     * Bot instance which has the data producer connected directly to the room bot.
     * This is used to handle all the states of the room and its functionality.
     */
    __bot;
    /**
     * Is the notification active.
     */
    __active;
    /**
     * Is the notification active.
     */
    get active() {
      return this.__active;
    }
    /**
     * Maximum number of entries in the list.
     */
    MAX_SIZE = 20;
    /**
     * Size by which the active speakers list will be notified.
     * `note: default size is 8`
     */
    __size;
    /**
     * Size by which the active speakers list will be notified.
     */
    get size() {
      return this.__size;
    }
    /**
     * Array of ActiveSpeakers ordered by volume.
     */
    __activePeerIds = [];
    /**
     * Update the number of peerIds to notify.
     * @param size
     */
    updateSize = (size) => {
      logger8.info("\u{1F514} Updating Active Speaker Size to", size);
      if (size > this.MAX_SIZE) {
        logger8.error(
          "\u{1F514} Active Speaker Size cannot be greater than",
          this.MAX_SIZE
        );
        return;
      }
      this.__size = size;
    };
    /**
     * Handle all the events emitted by the bot.
     */
    __handleBotEvents = () => {
      if (this.__bot.listenerCount("active-speakers-change") === 0) {
        this.__bot.on("active-speakers-change", this.__handleActiveSpeakerChange);
      }
    };
    __handleClosingAllEvents = () => {
      this.on("close", () => {
        this.__active = false;
        this.__bot.off(
          "active-speakers-change",
          this.__handleActiveSpeakerChange
        );
      });
    };
    __handleActiveSpeakerChange = (data) => {
      try {
        const { peerIds } = data;
        this.__activePeerIds = peerIds;
        logger8.debug("\u{1F514} Active Speakers Change", this.__activePeerIds);
        const slicedPeerData = peerIds.slice(0, this.__size);
        this.__room.emit("active-speakers-change", {
          peerIds: slicedPeerData ?? [],
          dominantSpeaker: peerIds?.[0] ?? ""
        });
      } catch (error) {
        logger8.error("Error: Handling New Active Speakers Notification", error);
        logger8.error(error);
      }
    };
    constructor(data) {
      super();
      this.__bot = data.bot;
      this.__size = data?.size ?? 8;
      this.__active = true;
      this.__handleBotEvents();
      this.__handleClosingAllEvents();
    }
  };
  var ActiveSpeakers_default = ActiveSpeakers;

  // src/Bot.ts
  var logger9 = mainLogger.createSubLogger("Bot");
  var Bot = class _Bot extends EnhancedEventEmitter {
    /**
     * Instance of the Bot Class; used for singleton pattern.
     */
    static __instance;
    /**
     * Bot Data Consumer
     */
    __botDataConsumer = null;
    /**
     * Get the instance of the Bot Class.
     * @returns Bot instance.
     */
    static getInstance() {
      if (!_Bot.__instance) {
        _Bot.__instance = new _Bot();
        return _Bot.__instance;
      }
      return _Bot.__instance;
    }
    constructor() {
      super();
    }
    setDataConsumer = (dataConsumer) => {
      logger9.debug("\u{1F514} Setting a new data consumer");
      try {
        this.__botDataConsumer?.close();
        this.__botDataConsumer = dataConsumer;
        this.__botDataConsumer.on("message", (message) => {
          try {
            logger9.debug("\u{1F514} Bot Data Message", message);
            const parsedJsonData = JSON.parse(message);
            if (parsedJsonData.label === "lastN") {
              this.emit("active-speakers-change", {
                peerIds: parsedJsonData?.payload?.activeSpeakers ?? []
              });
            }
          } catch (error) {
            logger9.error("\u274C Error in bot data consumer message", error);
          }
        });
      } catch (error) {
        logger9.error("Error in setting data consumer", error);
      }
    };
  };
  var Bot_default = Bot;

  // src/LocalPeer.ts
  var logger10 = mainLogger.createSubLogger("LocalPeer");
  var MAX_DATA_MESSAGE_SIZE = 1 * 1024;
  var LocalPeer = class _LocalPeer extends EnhancedEventEmitter {
    /**
     * LocalPeer Instance, Singleton class, only one instance of this class can be created
     */
    static __instance = null;
    /**
     * PeerId of the current client, specific to the Local Peer who joined the meeting
     *
     * `NOTE: Until you dont join the room, this will be *null*`
     */
    peerId = null;
    /**
     * Current Devices of the current client
     * e.g. Chrome, Firefox, Safari, ReactNative
     */
    __device = null;
    /**
     * SendTransport handles the sending of media from the client to the server
     */
    __sendTransport = null;
    /**
     * RecvTransport handles the receiving of media from the server to the client
     */
    __recvTransport = null;
    /**
     * Returns the room instance, throws an error if the room is not created
     *
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer
     */
    get room() {
      const room = Room_default.getInstance();
      if (!room)
        throw new Error("\u274C Room Not Initialized");
      return room;
    }
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      const socket = Socket_default.getInstance();
      if (!socket)
        throw new Error("\u274C Socket Not Initialized");
      return socket;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    get __remotePeers() {
      return this.room.remotePeers;
    }
    /**
     * Turn Server used for this client
     */
    __turn = [
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=udp",
        credential: "test-turn"
      },
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=tcp",
        credential: "test-turn"
      }
    ];
    /**
     * Get the current device ( chrome, firefox, safari, reactnative ) for this client
     *
     * @throws { Error } If the device is not initialized
     */
    get device() {
      if (!this.__device)
        throw new Error("Device Not Initialized");
      const loaded = this.__device.loaded;
      if (!loaded)
        throw new Error("Device Not Loaded");
      return this.__device;
    }
    // !important
    // Consumer creation tasks awaiting to be processed.
    // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }
    __pendingConsumerTasks = /* @__PURE__ */ new Map();
    // !important
    // Producer creation tasks awaiting to be processed.
    // Stores the lables of the pending producers { label: string }
    // Used to handle transport callbacks most important;
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    // !important
    // Map to store pending tasks, Stores the label and the promise of the task
    __pendingTasks = /* @__PURE__ */ new Map();
    /**
     * Pending Transport Tasks, Stores the transportType and the promise of the transport
     *
     * `NOTE: Useful to check if the transport is already being created and pause all producing
     * and consuming until the transport is created`
     */
    __pendingTransportTasks = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending fetching stream tasks which are awaiting to be processed
     * If fetching called multiple times at once, it will handle the concurrency issues
     */
    __pendingFetchingStream = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending produce tasks which are awaiting to be processed
     * Mostly used when the room is not joined and produce functionality needs to be handled
     *
     * Cases such as socket experiencing a reconnect and produce is called.
     * Or in the cases where room is not joined and enableVideo or enableAudio is called
     */
    __waitingToProduce = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending consume tasks which are waiting for recv transport to be re-connected
     */
    __waitingToConsume = [];
    /**
     * DeviceHandler Instance, Handles the media devices for this client
     * e.g. Camera, Microphone
     */
    deviceHandler = new DeviceHandler_default();
    /**
     * ActiveStream Map holds MediaStream as Value and Key as Label
     */
    __activeStreams = /* @__PURE__ */ new Map();
    /**
     * Handle the Client Side Permission for the Local Peer.
     */
    __permissions = Permissions_default.createInstance();
    /**
     * Stores the Metadata for the Local Peer.
     */
    __metadata = null;
    /**
     * Variable to check if the user has joined the room
     */
    joined = false;
    /**
     * Return the labels of the Media Stream that the Local Peer is producing to the room
     */
    get labels() {
      const sendTransport = this.__sendTransport;
      if (sendTransport) {
        const labels = Array.from(sendTransport.labelToProducerId.keys());
        return labels;
      }
      return [];
    }
    /**
     * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)
     */
    get permissions() {
      const acl = this.__permissions.acl;
      return acl;
    }
    /**
     * Get the Role of the Local Peer.
     */
    get role() {
      return this.__permissions.role;
    }
    /**
     * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    get token() {
      return this.socket.token;
    }
    /**
     * Returns the roomId of the current joined room.
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Returns the SendTransport
     * @returns { Transport } SendTransport
     * @throws { Error } If the SendTransport is not initialized
     */
    get sendTransport() {
      if (!this.__sendTransport)
        throw new Error("Send Transport Not Initialized");
      return this.__sendTransport;
    }
    /**
     * Returns the recvTransport
     * @returns { Transport } recvTransport
     * @throws { Error } If the recvTransport is not initialized
     */
    get recvTransport() {
      if (!this.__recvTransport)
        throw new Error("Recv Transport Not Initialized");
      return this.__recvTransport;
    }
    /**
     * Returns the metadata associated to the LocalPeer
     */
    getMetadata() {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    }
    /**
     * getStream returns the stream with the given label
     */
    getStream = (data) => {
      const stream = this.__activeStreams.get(data.label);
      if (stream === void 0) {
        return null;
      }
      return stream;
    };
    /**
     * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event
     * @param metadata
     */
    __updateMetadata = (metadata) => {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", {
        metadata: parse
      });
    };
    /**
     * Returns the producer with the given label
     * @param label - Identifier of the producer
     * @returns { Producer } Producer
     * @returns { null } If the producer is not found
     */
    getProducerWithLabel = (label) => {
      try {
        const producerId = this.__sendTransport?.labelToProducerId.get(label);
        if (producerId) {
          const producer = this.sendTransport.getProducerById(producerId);
          return producer;
        }
        return null;
      } catch (error) {
        logger10.error("\u274C Cannot Find Producer With Identifier: ", label);
        logger10.error(error);
        return null;
      }
    };
    /**
     * Registers the event handlers for the socket connection
     * @param socket - Socket Instance
     */
    __registerHandlerEvents = (socket) => {
      let cnt = 0;
      const keys = Object.keys(this.__handler);
      for (const key of keys) {
        try {
          const fn = this.__handler[key];
          if (fn)
            socket.subscribe(key, fn);
        } catch (error) {
          logger10.error(`\u274C Error Registered For Event: ${key}`);
          logger10.error(error);
        }
        cnt++;
      }
      logger10.info("\u2705 LocalPeerEventHandler Registered");
    };
    /**
     * Can be used to check which `direction` of webRTC connection is currently active for the peer.
     *
     * **NOTE: Peers with role as Bot will not have `recv` transport;**
     * @param transportType
     */
    transportExists = (transportType) => {
      if (transportType === "recv") {
        return this.__recvTransport;
      }
      return this.__sendTransport;
    };
    static create() {
      if (_LocalPeer.__instance) {
        return _LocalPeer.__instance;
      }
      _LocalPeer.__instance = new _LocalPeer();
      return _LocalPeer.__instance;
    }
    static getInstance() {
      if (!_LocalPeer.__instance) {
        throw new Error("LocalPeer not initialized");
      }
      return _LocalPeer.__instance;
    }
    constructor() {
      super();
      this.__registerHandlerEvents(this.socket);
      this.socket.on("reconnected", () => {
        logger10.info("\u{1F514} LocalPeer Reconnected, Syncing Meeting States");
        this.socket.publish("syncMeetingState", void 0);
        if (this.__sendTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__sendTransport.mediasoupTransport.id,
            transportType: "send"
          });
        }
        if (this.__recvTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__recvTransport.mediasoupTransport.id,
            transportType: "recv"
          });
        }
      });
    }
    /**
     * Destroy the current peer, closes all the transports, producers and consumers
     *
     * @param code - Close Code
     */
    close = () => {
      this.__device = null;
      navigator.mediaDevices.ondevicechange = null;
      this.__pendingConsumerTasks.clear();
      this.__pendingProducerTasks.clear();
      this.__pendingTransportTasks.clear();
      this.__pendingFetchingStream.clear();
      this.__waitingToProduce.clear();
      for (const stream of this.__activeStreams.values()) {
        for (const track of stream.getTracks())
          track.stop();
      }
      this.joined = false;
      this.deviceHandler.destroy();
      if (this.__sendTransport) {
        this.__sendTransport.close({ retries: 3 });
      }
      if (this.__recvTransport) {
        this.__recvTransport.close({ retries: 3 });
      }
      this.__sendTransport = null;
      this.__recvTransport = null;
      this.__permissions.reset();
      this.emit("permissions-updated", {
        permissions: this.permissions,
        role: this.role ?? ""
      });
    };
    /**
     * LocalPeer Handler Functions Begins Here 👇
     */
    /**
     * Produce a stream with a given label and appData to all the Remote Peers
     *
     * `canProduce must be true to produce a stream`
     *
     * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`
     *
     * @param data - Data to produce a stream
     *  - `label` - Unique Identifier for the stream ( string )
     *  - `stream` - MediaStream to produce ( MediaStream )
     *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )
     *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )
     *
     * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised
     * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers
     *
     * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room
     *
     * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`
     */
    produce = checkPermissions({
      canProduce: true
    }).validate(
      async (data) => {
        const track = data.stream.getTracks()[0];
        if (track) {
          track.addEventListener("ended", () => {
            this.stopProducing({ label: data.label });
          });
        }
        if (!this.joined || this.__sendTransport && this.__sendTransport?.connectionState !== "connected") {
          return new Promise((resolve) => {
            const fn = async () => {
              const producer2 = await this.produce(data).then((data2) => {
                resolve(data2);
                return data2;
              }).finally(() => {
                this.__pendingProducerTasks.delete(data.label);
              });
              return producer2;
            };
            this.__waitingToProduce.set(data.label, fn);
          });
        }
        const { stream } = data;
        const producerPromise = this.__pendingProducerTasks.get(data.label);
        if (producerPromise) {
          logger10.info(
            "\u{1F514} Producer Task Already Pending for this label ",
            data.label
          );
          const producer2 = await producerPromise;
          return producer2;
        }
        if (!this.__sendTransport) {
          await this.__createTransportOnServer({
            transportType: "send"
          });
        }
        const ongoingPromise = this.__pendingProducerTasks.get(data.label);
        if (ongoingPromise) {
          const producer2 = await ongoingPromise;
          return producer2;
        }
        const promise = this.__createProducer({
          stream,
          label: data.label,
          appData: { ...data.appData, label: data.label }
        });
        this.__pendingProducerTasks.set(data.label, promise);
        const producer = await promise.catch(() => {
          logger10.error("\u274C Error Create Producer Failed");
          throw new Error("\u274C Error Create Producer Failed");
        }).finally(() => {
          this.__pendingProducerTasks.delete(data.label);
        });
        return producer;
      }
    );
    /**
     * Enables the local web cam and starts producing the stream with the label `video`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local web cam fetches the stream opens you web cam indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`
     *
     * @throws { Error } If the stream is not found
     */
    enableVideo = checkPermissions({
      canProduce: true
    }).validate(async (customVideoStream) => {
      try {
        if (!this.permissions.canProduceSources.cam) {
          logger10.error("\u274C Cannot Enable Video, Permission Denied");
          throw new Error("\u274C Cannot Enable Video, Permission Denied");
        }
        const existingStream = this.__activeStreams.get("video");
        if (existingStream) {
          logger10.warn("\u{1F514} Cam Stream Already Enabled");
          return;
        }
        let stream;
        if (customVideoStream) {
          stream = customVideoStream;
        } else {
          const ongoingStreamPromise = this.__pendingFetchingStream.get("cam");
          if (ongoingStreamPromise) {
            await ongoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchStream({
              mediaDeviceKind: "cam"
            });
            this.__pendingFetchingStream.set("cam", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("cam");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Promise Not Found");
            return;
          }
          const { stream: fetchedStream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Stream From Device");
          }
          if (!fetchedStream) {
            logger10.error("\u274C Stream Not Found, cannot do enableVideo");
            throw new Error("\u274C Stream Not Found");
          }
          stream = fetchedStream;
        }
        this.__activeStreams.set("video", stream);
        this.emit("stream-fetched", {
          mediaKind: "cam",
          label: "video",
          stream
        });
        this.produce({
          label: "video",
          stream,
          appData: {
            producerPeerId: this.peerId
          },
          stopTrackOnClose: true
        }).then(() => {
          this.__pendingProducerTasks.delete("video");
        }).catch((error) => {
          logger10.error("\u274C Error Producing Video");
          this.deviceHandler.stopStream(this.__activeStreams.get("video"));
          this.__activeStreams.delete("video");
          this.__pendingFetchingStream.delete("cam");
          logger10.error(error);
        });
        this.__pendingFetchingStream.delete("cam");
        return stream;
      } catch (error) {
        logger10.error("\u274C Error Enabling Video");
        logger10.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("video"));
        this.__activeStreams.delete("video");
        this.__pendingFetchingStream.delete("cam");
        throw error;
      }
    });
    /**
     * Enables the local screen share  and starts producing the screen sharing stream
     *
     *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     *
     */
    startScreenShare = checkPermissions({ canProduce: true }).validate(
      async () => {
        try {
          if (!this.permissions.canProduceSources.screen) {
            logger10.error("\u274C Cannot Enable Screen Share, Permission Denied");
            throw new Error("\u274C Cannot Enable Screen Share, Permission Denied");
          }
          const existingStream = this.__activeStreams.get("screen-share");
          if (existingStream) {
            logger10.warn("\u{1F514} Screen Stream Already Enabled");
            return;
          }
          const onGoingStreamPromise = this.__pendingFetchingStream.get("screen-share");
          if (onGoingStreamPromise) {
            await onGoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchScreen();
            this.__pendingFetchingStream.set("screen-share", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("screen-share");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Screen Share Promise Not Found");
            return;
          }
          const { stream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Screen Share Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Screen ShareStream From Device");
          }
          if (!stream) {
            logger10.error("\u274C Stream Not Found, cannot do startScreenShare");
            throw new Error("\u274C Stream Not Found, cannot do startScreenShare");
          }
          this.__activeStreams.set("screen-share", stream);
          this.emit("stream-fetched", {
            mediaKind: "screen",
            label: "screen-share",
            stream
          });
          const videoTrack = stream.getVideoTracks()?.[0];
          const audioTrack = stream.getAudioTracks()?.[0];
          const videoProduce = async () => {
            return this.produce({
              label: "screen-share-video",
              stream: new MediaStream([videoTrack]),
              appData: {
                producerPeerId: this.peerId
              },
              stopTrackOnClose: true
            });
          };
          const audioProduce = async () => {
            return this.produce({
              label: "screen-share-audio",
              stream: new MediaStream([audioTrack]),
              appData: {
                producerPeerId: this.peerId
              },
              stopTrackOnClose: true
            });
          };
          if (videoTrack) {
            videoProduce().then(() => {
              this.__pendingProducerTasks.delete("screen-share-video");
            }).catch((error2) => {
              logger10.error("\u274C Error Producing Screen Share Video");
              this.deviceHandler.stopStream(
                this.__activeStreams.get("screen-share")
              );
              this.__activeStreams.delete("screen-share");
              logger10.error(error2);
            });
          }
          if (audioTrack) {
            audioProduce().then(() => {
              this.__pendingProducerTasks.delete("screen-share-audio");
            }).catch((error2) => {
              logger10.error("\u274C Error Producing Audio");
              this.deviceHandler.stopStream(
                this.__activeStreams.get("screen-share")
              );
              this.__activeStreams.delete("screen-share");
              logger10.error(error2);
            });
          }
          this.__pendingFetchingStream.delete("screen-share");
          return stream;
        } catch (error) {
          logger10.error("\u274C Error Enabling Screen Share");
          logger10.error(error);
          this.deviceHandler.stopStream(this.__activeStreams.get("screen-share"));
          this.__activeStreams.delete("screen-share");
          this.__pendingFetchingStream.delete("screen-share");
          throw error;
        }
      }
    );
    /**
     * Enables the local mic and starts producing the stream with the label `audio`
     *
     *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     */
    enableAudio = checkPermissions({
      canProduce: true
    }).validate(async (customAudioStream) => {
      try {
        if (!this.permissions.canProduceSources.mic) {
          logger10.error("\u274C Cannot Enable Audio, Permission Denied");
          throw new Error("\u274C Cannot Enable Audio, Permission Denied");
        }
        const existingStream = this.__activeStreams.get("audio");
        if (existingStream) {
          logger10.warn("\u{1F514} Mic Stream Already Enabled");
          return;
        }
        let stream;
        if (customAudioStream) {
          stream = customAudioStream;
        } else {
          const ongoingStreamPromise = this.__pendingFetchingStream.get("mic");
          if (ongoingStreamPromise) {
            await ongoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchStream({
              mediaDeviceKind: "mic"
            });
            this.__pendingFetchingStream.set("mic", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("mic");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Mic Promise Not Found");
            return;
          }
          const { stream: fetchedStream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Stream From Device");
          }
          if (!fetchedStream) {
            logger10.error("\u274C Stream Not Found, cannot do enableAudio");
            throw new Error("\u274C Stream Not Found");
          }
          stream = fetchedStream;
        }
        this.__activeStreams.set("audio", stream);
        this.emit("stream-fetched", {
          mediaKind: "mic",
          stream,
          label: "audio"
        });
        this.produce({
          label: "audio",
          stream,
          appData: {
            producerPeerId: this.peerId
          },
          stopTrackOnClose: true
        }).then(() => {
          this.__pendingProducerTasks.delete("audio");
        }).catch((error) => {
          logger10.error("\u274C Error Producing Audio");
          this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
          this.__activeStreams.delete("audio");
          logger10.error(error);
        });
        this.__pendingFetchingStream.delete("mic");
        return stream;
      } catch (error) {
        logger10.error("\u274C Error Enabling Audio");
        logger10.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
        this.__activeStreams.delete("audio");
        this.__pendingFetchingStream.delete("mic");
        throw error;
      }
    });
    /**
     * Stops the underlying producing of a stream for a particular label
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     *
     * @param data Data to stop producing { label: string }
     */
    stopProducing = (data) => {
      this.__waitingToProduce.delete(data.label);
      this.__pendingProducerTasks.delete(data.label);
      let closedStream = false;
      const producer = this.getProducerWithLabel(data.label);
      if (producer) {
        logger10.info("\u{1F514} Closing Producer", {
          label: data.label,
          producerId: producer.id
        });
        producer.close();
        producer.on("trackended", () => {
          console.debug("\u{1F514} Track Ended For the Producer");
        });
        this.__sendTransport?.removeProducerById(producer.id);
        closedStream = true;
        this.socket.publish("closeProducer", {
          producerId: producer.id
        });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const stream = this.__activeStreams.get(closedStreamLabel);
      if (stream) {
        this.deviceHandler.stopStream(stream);
        this.__activeStreams.delete(closedStreamLabel);
        closedStream = true;
      }
      if (closedStream) {
        this.emit("stream-closed", {
          label: data.label,
          reason: {
            code: 1200,
            tag: "STREAM_CLOSED",
            message: "Stopped Streaming"
          }
        });
      }
    };
    /**
     * Stops the underlying producing of a camera stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     *
     * @param data Data to stop producing { label: string }
     */
    disableVideo = async () => {
      this.stopProducing({
        label: "video"
      });
    };
    /**
     * Replaces the current video stream with the new stream
     *
     * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream
     * @param stream - New Video Stream
     */
    replaceVideoStream = async (stream) => {
      await this.replaceStream({
        label: "video",
        newStream: stream
      });
    };
    /**
     * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId
     * @param deviceId
     */
    changeVideoSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "cam"
      });
      const stream = this.__activeStreams.get("video");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "cam"
      });
      if (!newStream)
        return;
      await this.replaceVideoStream(newStream);
    };
    /**
     * Replaces the current audio stream with the new stream
     * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream
     * @param stream - New Audio Stream
     *
     */
    replaceAudioStream = async (stream) => {
      await this.replaceStream({
        label: "audio",
        newStream: stream
      });
    };
    /**
     * Replace the current stream with the new stream based on the label used to produce the stream
     *
     * @example
     * For Video
     * await localPeer.replaceStream({
     *  label: 'video',
     *  newStream: newStream
     * })
     *
     * For Screen-Share
     * await localPeer.replaceStream({
     *  label: 'screen-share-video',
     *  newStream: newStream
     * })
     *
     * If any custom label used
     * await localPeer.replaceStream({
     *  label: 'custom',
     *  newStream: newStream
     * })
     *
     * @param data - { label: string, newStream: MediaStream }
     */
    replaceStream = async (data) => {
      logger10.info(`\u{1F514} Replacing ${data.label} Stream `);
      const producer = this.getProducerWithLabel(data.label);
      const track = data.newStream.getTracks()[0];
      if (track) {
        track.addEventListener("ended", () => {
          this.stopProducing({ label: data.label });
        });
      }
      if (producer) {
        await producer.replaceTrack({ track });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const prevStream = this.__activeStreams.get(closedStreamLabel);
      if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {
        this.deviceHandler.stopStream(prevStream);
        this.__activeStreams.delete(closedStreamLabel);
        this.__activeStreams.set(closedStreamLabel, data.newStream);
      } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {
        for (const track2 of prevStream.getTracks()) {
          prevStream.removeTrack(track2);
          track2.stop();
        }
        for (const track2 of data.newStream.getTracks()) {
          prevStream.addTrack(track2);
        }
      }
      const mediaDeviceKind = getMediaDeviceKind(track);
      this.emit("stream-fetched", {
        label: data.label,
        stream: data.newStream,
        mediaKind: mediaDeviceKind
      });
    };
    /**
     * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId
     * @param deviceId
     */
    changeAudioSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "mic"
      });
      const stream = this.__activeStreams.get("audio");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "mic"
      });
      if (!newStream)
        return;
      await this.replaceAudioStream(newStream);
    };
    /**
     * Stops the underlying producing of a microphone stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     */
    disableAudio = async () => {
      this.stopProducing({
        label: "audio"
      });
    };
    /**
     * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     */
    stopScreenShare = async () => {
      try {
        this.stopProducing({
          label: "screen-share-video"
        });
        this.stopProducing({
          label: "screen-share-audio"
        });
      } catch (error) {
        logger10.error(error);
        logger10.error("Error Disabling Screen Share");
      }
    };
    /**
     * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which
     * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.
     *
     * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`
     * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.
     * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.
     *
     * To get the consumer back you can use
     *
     * const remotePeer = this.room.getRemotePeerById(data.peerId);
     *
     * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`
     *
     * @param data - {peerId: string, label: string, appData: Record<string, unknown>}
     *
     */
    consume = checkPermissions({
      canConsume: true
    }).validate(
      async (data) => {
        const remotePeer = this.__remotePeers.get(data.peerId);
        if (!remotePeer) {
          throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);
        }
        const labelData = remotePeer.getLabelData(data.label);
        if (!labelData) {
          throw new Error(
            `Remote Peer is not producing with Label ${data.label}`
          );
        }
        const consumerExists = remotePeer.getConsumer(data.label);
        if (consumerExists?.consuming) {
          logger10.warn("\u{1F514} Consumer Already Exists with label ", data.label);
          return consumerExists;
        }
        const pendingPromise = this.__pendingConsumerTasks.get(
          labelData?.producerId
        );
        if (pendingPromise) {
          logger10.warn(
            `\u{1F514} Consumer Task Pending to be Consumed with label ${data.label}, Returning`
          );
          const consumer2 = await pendingPromise;
          return consumer2;
        }
        logger10.info("\u{1F514} Consuming Stream with label ", data.label);
        if (!this.__recvTransport) {
          logger10.info(
            "\u{1F514} Recv Transport Not Initialized, Creaitng RecvTransport"
          );
          await this.__createTransportOnServer({
            transportType: "recv"
          });
        }
        const consumerPromise = new Promise((resolve) => {
          const handleStreamPlayable = (streamData) => {
            if (streamData.label === data.label) {
              remotePeer.off("stream-playable", handleStreamPlayable);
              resolve(streamData.consumer);
            }
          };
          remotePeer.once("stream-playable", handleStreamPlayable);
          this.socket.publish("consume", {
            appData: data.appData,
            producerId: labelData.producerId,
            producerPeerId: data.peerId
          });
        });
        this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);
        const consumer = await consumerPromise.catch((error) => {
          logger10.error("\u274C Error Consuming Stream");
          logger10.error(error);
          throw error;
        }).finally(() => {
          this.__pendingConsumerTasks.delete(labelData.producerId);
        });
        return consumer;
      }
    );
    /**
     * Stops the underlying consuming of a stream for a particular label
     *
     * `NOTE: This does not notify the remote peers that you are not consuming a stream`
     *
     * @param data
     */
    stopConsuming = (data) => {
      const remotePeer = this.room.getRemotePeerById(data.peerId);
      if (!remotePeer.hasLabel(data.label)) {
        logger10.error(
          `\u274C Remote Peer is not producing anything with label: ${data.label}`
        );
        return;
      }
      const consumer = this.recvTransport.getConsumer(data);
      if (!consumer) {
        logger10.error("\u274C Consumer Not Found", data);
        return;
      }
      if (!consumer.consuming) {
        logger10.error("\u274C You are not Consuming any Stream, Consumer Not Found");
        return;
      }
      const consumerId = consumer.id;
      if (!consumerId) {
        logger10.error("\u274C ConsumerId Not Found");
        return;
      }
      this.socket.publish("closeConsumer", {
        consumerId: consumer.id
      });
      remotePeer.emit("stream-closed", {
        label: data.label
      });
      this.recvTransport.closeConsumer(data);
    };
    /**
     * Activate Getting Active Speaker of the Remote Peers in the Room in decreasing order.
     * i.e. Speaker who are speaking the most in the room.
     *
     * if autoConsume is false, you have to manually consume speaker to get there notification
     */
    activateActiveSpeakersNotification = async (size) => {
      try {
        logger10.info("\u{1F514} Activating Speakers Notification Functionality");
        if (this.room.activeSpeakers) {
          logger10.info("\u{1F514} Speakers Notification Functionality Already Activated");
          return;
        }
        const botDataConsume = this.__sendTransport?.dataConsumers.get("bot");
        if (botDataConsume) {
          logger10.debug("\u{1F514} Bot Data Consumer Already Exists");
          return;
        }
        const ongoingActiveSpeakerPromise = this.__pendingTasks.get("bot");
        if (ongoingActiveSpeakerPromise) {
          logger10.debug("\u{1F514} Bot Data Consumer Task Pending");
          await ongoingActiveSpeakerPromise;
        } else {
          const fn = async () => {
            if (!this.__recvTransport) {
              logger10.debug(
                "\u{1F514} Recv Transport Not Initialized, Creating RecvTransport"
              );
              await this.__createTransportOnServer({
                transportType: "recv"
              });
            }
            this.socket.publish("createDataConsumer", {
              label: "bot"
            });
            return size ?? 8;
          };
          const promise = fn();
          this.__pendingTasks.set("bot", promise);
          await promise;
        }
      } catch (error) {
        logger10.error(
          "\u274C Error Activating Speakers Notification Functionality",
          error
        );
      }
    };
    sendData = checkPermissions({
      canSendData: true
    }).validate(
      (data) => {
        if (estimateSize(data.payload) > MAX_DATA_MESSAGE_SIZE) {
          logger10.error("\u274C Data message exceeds 1kb in size");
          return;
        }
        const parsedTo = data.to === "*" ? ["*"] : data.to;
        this.socket.publish("sendData", {
          to: parsedTo,
          payload: data.payload,
          label: data.label
        });
      }
    );
    produceData = () => {
      logger10.info("\u{1F514} Producing Data,");
    };
    /**
     * Send Message to update the metadata of the Local Peer
     *
     * `NOTE: This will notify every user in the room about the metadata update`
     */
    updateMetadata = checkPermissions({
      canUpdateMetadata: true
    }).validate((data) => {
      if (!this.joined) {
        logger10.error(
          "\u274C Cannot Update Metadata, You have not joined the room yet"
        );
        return;
      }
      const peerId = this.peerId;
      if (!peerId) {
        logger10.error("\u274C Cannot Update Metadata, PeerId Not Found");
        return;
      }
      const newMetadata = JSON.stringify(data);
      this.socket.publish("updatePeerMetadata", {
        peerId,
        metadata: newMetadata
      });
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     */
    updateRole = (data) => {
      try {
        if (!this.joined) {
          throw new Error(
            "\u274C Cannot Update Role, You have not joined the room yet"
          );
        }
        if (data.role === this.role) {
          logger10.warn("\u{1F514} Peer Role is already set to", data.role);
          return;
        }
        if (!this.peerId) {
          logger10.error(
            "\u274C Cannot Update Role, PeerId Not Found, (You have not joined the room yet)"
          );
          return;
        }
        this.socket.publish("updatePeerRole", {
          peerId: this.peerId,
          role: data.role
        });
      } catch (error) {
        logger10.error("\u{1F514} Error Updating Role", data);
        logger10.error(error);
      }
    };
    __handler = {
      error: (data) => {
        logger10.error("\u274C Error Event");
        logger10.error(data);
      },
      /**
       * When Huddle01 Node has successfully accepted the connection request
       * it sents back some usefull metadata for the client to use
       * at this point the socket is assumed to the connected and the localPeer is ready to join the room
       *
       * @param data - Data from server { peerId }
       */
      hello: (data) => {
        logger10.info("\u2705 Hello From Server, Connection Success", data);
        const { acl, peerId } = data;
        this.peerId = peerId;
        this.room.sessionId = data.sessionId;
        this.__permissions.updatePermissions(data.acl);
        if (data?.role)
          this.__permissions.role = data.role;
        this.emit("permissions-updated", {
          permissions: acl,
          role: data.role
        });
        if (data.metadata) {
          this.__updateMetadata(data.metadata);
        }
      },
      waitingRoom: (data) => {
        logger10.info("\u{1F514} Waiting Room", data);
        this.room.emit("room-waiting", data);
      },
      /**
       * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.
       * @emits "room-joined" - When the client has successfully joined the room.
       * @emits "join-error" - When the client has failed to join the room.
       * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }
       */
      connectRoomResponse: async (data) => {
        logger10.info("\u2705 Join Success Event");
        try {
          const { roomInfo, routerRTPCapabilities, turnServers } = data;
          this.room.config = roomInfo.config;
          this.room.metadata = roomInfo.metadata ?? "{}";
          this.room.stats.startTime = roomInfo.startTime;
          const deviceType = (0, import_mediasoup_client.detectDevice)();
          if (!deviceType) {
            logger10.error(
              "\u274C Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'"
            );
            throw new Error("\u274C Device is not supported");
          }
          this.__device = new import_mediasoup_client.Device({ handlerName: deviceType });
          const parsedRouterRtpCapabilites = parseRouterRtpCapabilities({
            codecs: routerRTPCapabilities.codecs,
            headerExtensions: routerRTPCapabilities.headerExtensions
          });
          await this.__device.load({
            routerRtpCapabilities: parsedRouterRtpCapabilites
          });
          if (!this.device.loaded) {
            throw new Error("\u274C Cannot Load Device");
          }
          this.emit("device-created", { device: this.__device });
          this.__setRemotePeers(roomInfo);
          this.__setLobbyPeers(roomInfo);
          if (turnServers?.length) {
            logger10.info("\u{1F514} Setting Turn Server", turnServers);
            this.__turn = [...turnServers, ...this.__turn];
          }
          this.room.state = "connected";
          this.joined = true;
          this.room.emit("room-joined");
        } catch (error) {
          logger10.error("\u274C Error Joining Room");
          logger10.error(error);
          this.room.emit("room-joined-failed", {
            message: "\u274C Error Joining Room",
            status: "ROOM_ERRORED"
          });
        }
        this.__handleWaitingToProduce();
      },
      /**
       * @description update the remote peers in the room , remove the remote peers which are not in the room anymore
       * @param roomInfo
       */
      syncMeetingStateResponse: async (data) => {
        try {
          logger10.info("\u2705 Client recovered after reconnecting", data);
          const { peers: latestPeers } = data.roomInfo;
          const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));
          for (const [peerId, peer] of this.__remotePeers.entries()) {
            if (!latestPeersSet.has(peerId)) {
              for (const label of peer.labels) {
                this.__closeRemotePeerConsumer({
                  peerId,
                  label
                });
              }
              peer.close();
              this.__remotePeers.delete(peerId);
              this.room.emit("peer-left", peerId);
              continue;
            }
            const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);
            if (!latestPeerInfo)
              continue;
            const newProducerSet = new Set(
              latestPeerInfo.producers.map((p) => p.label)
            );
            for (const label of peer.labels) {
              if (!newProducerSet.has(label)) {
                this.__closeRemotePeerConsumer({ peerId, label });
              }
            }
            const currentProducerSet = new Set(peer.producerIds);
            for (const producer of latestPeerInfo.producers) {
              if (!currentProducerSet.has(producer.id)) {
                if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                  peer._addLabelData({
                    producerId: producer.id,
                    label: producer.label
                  });
                } else {
                  this.__waitingToConsume.push(
                    () => peer._addLabelData({
                      producerId: producer.id,
                      label: producer.label
                    })
                  );
                }
              }
            }
          }
          const filteredPeers = latestPeers.filter(
            (latestPeer) => !this.__remotePeers.has(latestPeer.peerId) && latestPeer.peerId !== this.peerId
          ).values();
          for (const latestPeer of filteredPeers) {
            const remotePeer = new RemotePeer_default({
              peerId: latestPeer.peerId,
              role: latestPeer.role,
              metadata: latestPeer.metadata
            });
            this.__remotePeers.set(latestPeer.peerId, remotePeer);
            const remoteProducers = latestPeer.producers;
            for (const p of remoteProducers) {
              if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                remotePeer._addLabelData({ producerId: p.id, label: p.label });
              } else {
                this.__waitingToConsume.push(
                  () => remotePeer._addLabelData({
                    producerId: p.id,
                    label: p.label
                  })
                );
              }
            }
            this.room.emit("new-peer-joined", { peer: remotePeer });
          }
        } catch (error) {
          logger10.error("\u274C Error Syncing Meeting State, Can't Recover");
          logger10.error(error);
        }
      },
      /**
       * Upon creation of server side transport, the server sends back some usefull metadata for the client to use
       * to create a client side transport, i.e. `send | recv` Transport.
       * @param data - Data from server { transportSDPInfo, transportType }
       */
      createTransportOnClient: async (data) => {
        try {
          const device = this.device;
          if (!this.peerId) {
            throw new Error(
              "\u274C Cannot Create Transport, No PeerId Found for the user."
            );
          }
          const transport = Transport_default.create({
            device,
            peerId: this.peerId,
            socket: this.socket,
            sdpInfo: data.transportSDPInfo,
            iceServers: this.__turn,
            transportType: data.transportType
          });
          if (transport.transportType === "send") {
            this.__sendTransport = transport;
            this.__sendTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToProduce();
                }
              }
            );
            this.emit("new-send-transport", {
              transport
            });
          }
          if (transport.transportType === "recv") {
            this.__recvTransport = transport;
            this.__recvTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToConsume();
                }
              }
            );
            this.emit("new-recv-transport", {
              transport
            });
          }
        } catch (error) {
          logger10.error(
            "\u274C Error Creating MediasoupTransport On Client, transportType",
            data.transportType
          );
          logger10.error(error);
        }
      },
      /**
       * !Important
       * When the server has successfully connected the transport, it sends a ack back to the client
       * which handles the callback() function which triggers the process of creation of producer and consumer
       * for reference see: packages/nezuko/src/Transport.ts
       * @param data
       */
      connectTransportResponse: async (data) => {
        logger10.info(
          `\u2705 Connect ${data.transportType} Transport On Server Response`
        );
        try {
          const transportType = data.transportType;
          const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
          if (!transport) {
            throw new Error(`${transportType} Transport Not Initialized`);
          }
          transport.emit("connectTransportResponse");
        } catch (error) {
          logger10.error("\u274C Error Connecting Transport On Server Response");
          logger10.error(error);
        }
      },
      produceResponse: async (data) => {
        logger10.info("\u2705 Produce Response");
        logger10.info(data);
        try {
          const { peerId, producerId, label } = data;
          if (!producerId || !label || !peerId) {
            logger10.error("\u274C ProducerId or Label or PeerId Not Found");
            return;
          }
          if (peerId === this.peerId) {
            this.sendTransport.resolvePendingProducerTask({
              id: producerId,
              label,
              peerId
            });
          } else {
            const remotePeer = this.room.getRemotePeerById(peerId);
            if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
              remotePeer._addLabelData({
                producerId,
                label
              });
            } else {
              this.__waitingToConsume.push(
                () => remotePeer._addLabelData({
                  producerId,
                  label
                })
              );
            }
          }
        } catch (error) {
          logger10.error("\u274C Error Produce Response");
          logger10.error(error);
        }
      },
      consumeDataResponse: async (data) => {
        logger10.debug("\u2705 Consume Data Response, label", data.label);
        try {
          const {
            id,
            peerId,
            dataProducerId,
            label,
            protocol,
            sctpStreamParameters
          } = data;
          if (label !== "bot") {
            logger10.warn("\u{1F514} Consume Data Response, label is not bot, returning");
            return;
          }
          if (label === "bot") {
            const botDataConsumer = this.recvTransport.dataConsumers.get(label);
            if (botDataConsumer) {
              logger10.error("\u274C Bot Data Consumer Already Exists, Can't Create", {
                label
              });
              return;
            }
            const dataConsumer = await this.recvTransport.consumeData({
              id,
              dataProducerId,
              label,
              peerId,
              protocol,
              sctpStreamParameters,
              appData: {}
            });
            const bot = Bot_default.getInstance();
            bot.setDataConsumer(dataConsumer);
            const pendingTask = await this.__pendingTasks.get("bot");
            const activeSpeakers = this.room.activeSpeakers;
            let size = 8;
            if (typeof pendingTask === "number" && pendingTask > 0) {
              size = pendingTask;
            }
            if (!activeSpeakers) {
              this.room.activeSpeakers = ActiveSpeakers_default.createInstance({
                bot,
                size
              });
            }
            this.__pendingTasks.delete("bot");
          }
        } catch (error) {
          logger10.error("\u274C Error: Consume Data Response", error);
        }
      },
      produceDataResponse: async (data) => {
        logger10.debug("\u2705 Produce Data Response consumerIdFromServer", data.id);
        try {
          const {
            id,
            peerId,
            dataProducerId,
            label,
            protocol,
            sctpStreamParameters
          } = data;
          if (peerId === this.peerId && label !== "bot") {
            this.sendTransport.resolvePendingProducerTask({
              id: dataProducerId,
              label,
              peerId
            });
          }
          const botDataConsumer = this.recvTransport.dataConsumers.get(label);
          if (botDataConsumer) {
            logger10.error("\u274C Bot Data Consumer Already Exists, Can't Create", {
              label
            });
            return;
          }
          const dataConsumer = await this.recvTransport.consumeData({
            id,
            dataProducerId,
            label,
            peerId,
            protocol,
            sctpStreamParameters,
            appData: {}
          });
          dataConsumer.on("message", (message) => {
            const parsedJsonData = JSON.parse(message);
            const result = VolatileDataMessageSchema.safeParse(parsedJsonData);
            if (result.success) {
              this.emit("receive-volatile-data", result.data);
            } else {
              throw new Error(
                "\u274C Data Consumer Message Schema Validation Failed"
              );
            }
          });
          if (label === "bot") {
            this.__pendingTasks.delete("bot");
          }
        } catch (error) {
          logger10.error("\u274C Error Produce Data Response");
          logger10.error({ error });
        }
      },
      consumeResponse: async (data) => {
        logger10.info("\u2705 Consume Response", data);
        try {
          const remotePeer = this.room.getRemotePeerById(data.producerPeerId);
          if (!remotePeer.hasLabel(data.label)) {
            logger10.error("\u274C Remote Peer is not producing this label", {
              label: data.label
            });
            throw new Error(
              `\u274C Remote Peer is not producing this label: ${data.label}`
            );
          }
          const { consumer, mediaSoupConsumer } = await this.recvTransport.consume({
            ...data,
            kind: data.kind,
            rtpParameters: {
              codecs: data.rtpParameters.codecs,
              mid: data.rtpParameters.mid,
              encodings: data.rtpParameters.encodings,
              headerExtensions: data.rtpParameters.headerExtensions,
              rtcp: data.rtpParameters.rtcp
            }
          });
          remotePeer.emit("stream-playable", {
            consumer,
            label: consumer.label
          });
          this.room.emit("stream-added", {
            label: consumer.label,
            peerId: data.producerPeerId
          });
          this.socket.publish("resumeConsumer", {
            consumerId: data.consumerId,
            producerPeerId: data.producerPeerId
          });
          mediaSoupConsumer.resume();
        } catch (error) {
          logger10.error("\u274C Error Consume Response");
          logger10.error(error);
          this.__pendingConsumerTasks.delete(data.producerId);
        }
      },
      closeProducerSuccess: async (data) => {
        logger10.info("\u2705 Producer Closed", data);
        if (this.peerId === data.peerId)
          return;
        const { peerId, label } = data;
        try {
          this.__closeRemotePeerConsumer({
            peerId,
            label
          });
        } catch (err) {
          logger10.error("\u274C Error Closing Producer");
          logger10.error(err);
        }
      },
      closeConsumerSuccess: async (data) => {
        logger10.info("\u2705 Consumer Closed, ", data);
      },
      restartTransportIceResponse: async (data) => {
        const { transportType, iceParameters } = data;
        logger10.info("\u2705 Restart Transport Ice Response ", transportType);
        const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (!transport) {
          logger10.error(`\u274C ${transportType} Transport Not Found`);
          return;
        }
        try {
          await transport.mediasoupTransport.restartIce({
            iceParameters
          });
          logger10.info("\u2705 Restarted Ice for type: ", transportType);
        } catch (error) {
          logger10.error("\u274C Error Restarting Ice for type: ", transportType);
          logger10.error(error);
        }
      },
      newPeerJoined: (data) => {
        if (this.peerId === data.peerId)
          return;
        logger10.info("\u2705 New Peer Joined", { data });
        try {
          const { peerId, role, metadata } = data;
          if (!peerId) {
            return;
          }
          const remotePeer = new RemotePeer_default({
            peerId,
            role,
            metadata
          });
          this.__remotePeers.set(peerId, remotePeer);
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
          this.room.emit("new-peer-joined", { peer: remotePeer });
        } catch (error) {
          logger10.error("\u274C Error New Peer Joined");
          logger10.error(error);
        }
      },
      newLobbyPeer: (data) => {
        try {
          logger10.info("\u2705 New Lobby Peer", { data });
          const parsedData = data;
          this.room.newlobbyPeers = [parsedData];
        } catch (error) {
          logger10.error("\u274C Error New Lobby Peer");
          logger10.error(error);
        }
      },
      newPermissions: (data) => {
        try {
          const parsedData = data.acl;
          this.__permissions.updatePermissions(parsedData);
          this.emit("permissions-updated", {
            permissions: this.permissions
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Permissions");
          logger10.error(error);
        }
      },
      newRoomControls: (data) => {
        logger10.info("\u2705 Received New Room Controls", { data });
        try {
          const { controls } = data;
          this.room.config = controls;
          this.room.emit("room-controls-updated");
        } catch (error) {
          logger10.error("\u274C Error Updating Room Controls");
          logger10.error(error);
        }
      },
      newPeerRole: (data) => {
        logger10.info("\u2705 Received New Peer's Role", { data });
        try {
          const { peerId, role } = data;
          if (peerId === this.peerId) {
            logger10.info("\u2705 Updating Local Peer's Role");
            this.__permissions.role = role;
            this.emit("role-updated", {
              role
            });
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          const prevRole = remotePeer.role ?? "";
          remotePeer.role = role;
          this.room.emit("room-role-updated", {
            peerId,
            newRole: role,
            prevRole
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Peer's Role");
          logger10.error(error);
        }
      },
      roomClosedProducers: (data) => {
        logger10.info("\u2705 Received Room's Closed Producers", { data });
        try {
          const { producers, reason } = data;
          for (const producer of producers) {
            const { label, peerId } = producer;
            if (peerId === this.peerId && label) {
              this.stopProducing({ label });
              continue;
            }
            try {
              const remotePeer = this.room.getRemotePeerById(peerId);
              const consumer = this.recvTransport.getConsumer({
                label,
                peerId
              });
              if (consumer) {
                this.recvTransport.closeConsumer({ label, peerId });
                remotePeer._removeLabelData(label);
                this.room.emit("stream-closed", {
                  label,
                  peerId
                });
              }
            } catch (error) {
              logger10.error("\u274C Error Closing Producer");
              logger10.error(error);
            }
          }
          this.room.emit("room-notification", {
            code: reason?.code ?? 4004,
            message: reason?.message ?? "Room Closed",
            tag: reason?.tag ?? "ROOM_CLOSED"
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Room's Closed Producers");
          logger10.error(error);
        }
      },
      receiveData: (data) => {
        logger10.info("\u2705 Received Data", { data });
        try {
          const { from, label, payload } = data;
          this.emit("receive-data", {
            from,
            label,
            payload
          });
        } catch (error) {
          logger10.error("\u274C Error Receive Data");
          logger10.error(error);
        }
      },
      peerMetadataUpdated: (data) => {
        try {
          logger10.info("\u2705 Metadata Updated", { data });
          const { peerId, metadata } = data;
          if (this.peerId === peerId) {
            this.__updateMetadata(metadata);
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          remotePeer.metadata = JSON.parse(metadata);
        } catch (error) {
          logger10.error("\u274C Error Updating Metadata");
          logger10.error(error);
        }
      },
      roomMetadataUpdated: (data) => {
        logger10.info("\u2705 Room Metadata Updated", { data });
        try {
          const { metadata } = data;
          this.room.metadata = metadata;
        } catch (error) {
          logger10.error("\u274C Error Updating Room Metadata");
          logger10.error(error);
        }
      },
      peerLeft: (data) => {
        logger10.info("\u2705 Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const remotePeer = this.room.getRemotePeerById(peerId);
          const labels = remotePeer.labels;
          for (const label of labels) {
            this.__closeRemotePeerConsumer({
              peerId: remotePeer.peerId,
              label
            });
          }
          remotePeer.close();
          this.__remotePeers.delete(peerId);
          this.room.emit("peer-left", peerId);
        } catch (error) {
          logger10.error("\u274C Error Peer Left");
          logger10.error(error);
        }
      },
      lobbyPeerLeft: (data) => {
        logger10.info("\u2705 Lobby Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
        } catch (error) {
          logger10.error("\u274C Error Lobby Peer's Left");
          logger10.error(error);
        }
      }
    };
    /**
     * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer
     * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }
     * @returns - Producer
     */
    __createProducer = async (data) => {
      if (!this.__sendTransport) {
        throw new Error("\u274C Send Transport Not Initialized, Internal Error");
      }
      const producer = await this.__sendTransport.produce({
        stream: data.stream,
        stopTrackOnClose: data.stopTrackOnClose ?? true,
        label: data.label,
        appData: {
          ...data.appData,
          label: data.label
        }
      });
      producer.on("transportclose", () => {
        this.stopProducing({ label: data.label });
      });
      this.emit("stream-playable", {
        label: data.label,
        producer
      });
      return producer;
    };
    __createTransportOnServer = async (data) => {
      const pendingPromise = this.__pendingTransportTasks.get(data.transportType);
      if (pendingPromise) {
        logger10.info(
          `\u{1F514} Transport Task Already Pending for this transportType ${data.transportType}`
        );
        return pendingPromise;
      }
      const { transportType } = data;
      const promise = new Promise((resolve, reject) => {
        const handleNewTransport = (data2) => {
          if (data2.transport.transportType === transportType) {
            this.__pendingTransportTasks.delete(transportType);
            resolve(data2.transport);
          }
        };
        if (transportType === "send") {
          this.once("new-send-transport", handleNewTransport);
        }
        if (transportType === "recv") {
          this.once("new-recv-transport", handleNewTransport);
        }
        const device = this.device;
        const transport = data.transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (transport) {
          reject(
            new Error(`\u274C Transport Already Initialized, type: ${transportType}`)
          );
        }
        logger10.info(`\u{1F514} Creating ${data.transportType} Transport On Server`);
        this.socket.publish("createTransport", {
          sctpCapabilities: device.sctpCapabilities,
          transportType: data.transportType
        });
      });
      this.__pendingTransportTasks.set(data.transportType, promise);
      return promise;
    };
    /**
     * Sets the Remote Peers in the Room
     * @param roomInfo
     */
    __setRemotePeers = (roomInfo) => {
      const { peers } = roomInfo;
      for (const peer of peers) {
        if (peer.peerId === this.peerId)
          continue;
        const remotePeer = new RemotePeer_default({
          peerId: peer.peerId,
          metadata: peer.metadata,
          role: peer.role
        });
        const producers = peer.producers;
        this.__remotePeers.set(peer.peerId, remotePeer);
        producers.map((p) => {
          if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
            remotePeer._addLabelData({
              producerId: p.id,
              label: p.label
            });
          } else {
            this.__waitingToConsume.push(
              () => remotePeer._addLabelData({
                producerId: p.id,
                label: p.label
              })
            );
          }
        });
      }
    };
    /**
     * Sets the Lobby Peers in the Room
     * @param roomInfo - RoomInfo
     */
    __setLobbyPeers = (roomInfo) => {
      const { lobbyPeers } = roomInfo;
      this.room.newlobbyPeers = lobbyPeers;
    };
    /**
     * Helper Function to close the consumer of a remote peer
     * @param data - Data to close the consumer { peerId, label }
     */
    __closeRemotePeerConsumer = (data) => {
      try {
        const { peerId, label } = data;
        const remotePeer = this.room.getRemotePeerById(peerId);
        const consumer = this.recvTransport.getConsumer({
          label,
          peerId
        });
        if (consumer) {
          this.recvTransport.closeConsumer({ label, peerId });
          remotePeer._removeLabelData(label);
        }
        this.room.emit("stream-closed", {
          label,
          peerId: data.peerId
        });
      } catch (error) {
        logger10.error("\u274C Error Closing Remote Peer's Consumer");
        logger10.error(error);
      }
    };
    /**
     * !important
     * Handler Function to handle the waiting to produce tasks when user is joining
     * the room with active stream, check if the user has valid permissions and based on
     * that allows the user to produce the stream
     */
    __handleWaitingToProduce = () => {
      try {
        const permissions = this.permissions;
        const closeStream = (label) => {
          const stream = this.__activeStreams.get(label);
          if (stream) {
            this.deviceHandler.stopStream(stream);
            this.__activeStreams.delete(label);
            this.emit("stream-closed", {
              label,
              reason: {
                code: 4444,
                message: "User's Permissions Denied",
                tag: "CLOSED_BY_ADMIN"
              }
            });
          }
          this.__waitingToProduce.delete(label);
        };
        if (!permissions.canProduce) {
          for (const [label, _] of this.__waitingToProduce) {
            closeStream(label);
          }
          this.__waitingToProduce.clear();
          return;
        }
        for (const [label, pendingStreamTask] of this.__waitingToProduce) {
          if (label === "video" && !permissions.canProduceSources.cam) {
            closeStream(label);
            continue;
          }
          if (label === "audio" && !permissions.canProduceSources.mic) {
            closeStream(label);
            continue;
          }
          pendingStreamTask().catch((error) => {
            logger10.error(
              "\u274C Error Producing Stream which was waiting to be produced with label :",
              label
            );
            logger10.error(error);
            closeStream(label);
          });
        }
        this.__waitingToProduce.clear();
      } catch (error) {
        logger10.error("\u274C Error Handling Waiting To Produce");
        logger10.error(error);
      }
    };
    __handleWaitingToConsume = () => {
      for (const consumeTask of this.__waitingToConsume) {
        consumeTask().catch(() => {
          logger10.error("Unable to Consume after ice restart");
        });
      }
      this.__waitingToConsume = [];
    };
  };
  var LocalPeer_default = LocalPeer;

  // src/HuddleClient.ts
  var import_socket2 = __toESM(require_socket_types(), 1);
  var logger11 = mainLogger.createSubLogger("HuddleClient");
  var HuddleClient = class {
    /**
     * Connection Manager Instance, Hanlder socket connection and stores information about the connection
     */
    __socket;
    /**
     * Room Instance, Handles the room and its connection
     */
    __room;
    /**
     * Local Peer Instance, Handles the local peer and its connection
     */
    __localPeer;
    /**
     * Project Id of the Huddle01 Project
     */
    projectId;
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      if (!this.__socket) {
        throw new Error(
          "Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first"
        );
      }
      return this.__socket;
    }
    /**
     * Returns the room instance, throws an error if the room is not created
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room
     */
    get room() {
      return this.__room;
    }
    get localPeer() {
      return this.__localPeer;
    }
    /**
     * Room Id of the current room
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Set a new region for the Huddle01 Media Servers
     */
    setRegion = (region) => {
      logger11.info("Setting a new region, ", region);
      this.socket.setRegion(region);
    };
    constructor(data) {
      if (data.options?.logging) {
        setLogLevel("trace");
      }
      logger11.info("\u2705 Initializing HuddleClient");
      this.projectId = data.projectId;
      this.__socket = Socket_default.create();
      this.__room = Room_default.create({
        autoConsume: data.options?.autoConsume
      });
      this.__localPeer = LocalPeer_default.create();
      const isLocalDev = this.projectId === "development";
      if (isLocalDev) {
        logger11.info("\u{1F534} Local Development Mode");
        this.socket.enableLocalDev();
      }
      this.__socket.on("closed", (code) => {
        logger11.info(
          "\u{1F50C} Socket Connection closed, closing the room and LocalPeer"
        );
        if (code === import_socket2.ESocketCloseCode.ROOM_CLOSED) {
          this.room.close("CLOSED");
        } else if (code === import_socket2.ESocketCloseCode.ROOM_ENTRY_DENIED) {
          this.room.close("DENIED");
        } else if (code === import_socket2.ESocketCloseCode.CONNECTION_EXPIRED) {
          logger11.info("\u{1F514} Room closed due to connection expired");
          this.room.close();
        } else if (code === import_socket2.ESocketCloseCode.KICKED) {
          this.room.close("KICKED");
        } else {
          this.room.close();
        }
        this.localPeer.close();
      });
      if (data.options?.activeSpeakers?.size) {
        this.__room.once("room-joined", () => {
          this.localPeer.activateActiveSpeakersNotification(
            data.options?.activeSpeakers?.size
          ).catch((error) => {
            logger11.error(
              "\u{1F534} Error while activating active speakers notification",
              error
            );
          });
        });
      }
    }
    /**
     * Default method to connect to the Huddle01 Media Room.
     *
     * This method connects to socket, creates a room, and then connects to the room;
     */
    joinRoom = async (data) => {
      logger11.info("\u{1F514} Joining the room with roomId,", data.roomId);
      if (this.socket.connectionState === "connecting") {
        logger11.warn(
          "\u{1F514} Socket is already connecting, waiting for the connection to be established"
        );
        return this.room;
      }
      if (this.room.state === "connecting") {
        logger11.warn("\u{1F514} Room join already in progress");
        return this.room;
      }
      if (this.localPeer.joined) {
        logger11.warn("\u{1F514} Already joined the room");
        return this.room;
      }
      try {
        await this.socket.connect({ token: data.token });
        logger11.debug("\u{1F680} Connecting to Room");
        this.room.roomId = data.roomId;
        const room = this.room.connect();
        return room;
      } catch (error) {
        logger11.error("\u{1F534} Error While Joining the Room");
        logger11.error(error);
        throw error;
      }
    };
    /**
     * Leave the room and disconnect from the socket
     */
    leaveRoom = () => {
      logger11.info("Leaving the room");
      this.socket.close(import_socket2.ESocketCloseCode.NORMAL_CLOSURE);
    };
    /**
     * Close the room and disconnect from the socket
     */
    closeRoom = () => {
      logger11.info("Closing the room");
      this.socket.publish("closeRoom", void 0);
    };
  };
  var HuddleClient_default = HuddleClient;
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/